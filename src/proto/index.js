/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader,
	$Writer = $protobuf.Writer,
	$util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.ClientResponseEncrypted = (function () {
	/**
	 * Properties of a ClientResponseEncrypted.
	 * @exports IClientResponseEncrypted
	 * @interface IClientResponseEncrypted
	 * @property {ILoginCredentials} loginCredentials ClientResponseEncrypted loginCredentials
	 * @property {AccountCreation|null} [accountCreation] ClientResponseEncrypted accountCreation
	 * @property {IFingerprintResponseUnion|null} [fingerprintResponse] ClientResponseEncrypted fingerprintResponse
	 * @property {IPeerTicketUnion|null} [peerTicket] ClientResponseEncrypted peerTicket
	 * @property {ISystemInfo} systemInfo ClientResponseEncrypted systemInfo
	 * @property {string|null} [platformModel] ClientResponseEncrypted platformModel
	 * @property {string|null} [versionString] ClientResponseEncrypted versionString
	 * @property {ILibspotifyAppKey|null} [appkey] ClientResponseEncrypted appkey
	 * @property {IClientInfo|null} [clientInfo] ClientResponseEncrypted clientInfo
	 */

	/**
	 * Constructs a new ClientResponseEncrypted.
	 * @exports ClientResponseEncrypted
	 * @classdesc Represents a ClientResponseEncrypted.
	 * @implements IClientResponseEncrypted
	 * @constructor
	 * @param {IClientResponseEncrypted=} [properties] Properties to set
	 */
	function ClientResponseEncrypted(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientResponseEncrypted loginCredentials.
	 * @member {ILoginCredentials} loginCredentials
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.loginCredentials = null;

	/**
	 * ClientResponseEncrypted accountCreation.
	 * @member {AccountCreation} accountCreation
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.accountCreation = 1;

	/**
	 * ClientResponseEncrypted fingerprintResponse.
	 * @member {IFingerprintResponseUnion|null|undefined} fingerprintResponse
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.fingerprintResponse = null;

	/**
	 * ClientResponseEncrypted peerTicket.
	 * @member {IPeerTicketUnion|null|undefined} peerTicket
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.peerTicket = null;

	/**
	 * ClientResponseEncrypted systemInfo.
	 * @member {ISystemInfo} systemInfo
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.systemInfo = null;

	/**
	 * ClientResponseEncrypted platformModel.
	 * @member {string} platformModel
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.platformModel = "";

	/**
	 * ClientResponseEncrypted versionString.
	 * @member {string} versionString
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.versionString = "";

	/**
	 * ClientResponseEncrypted appkey.
	 * @member {ILibspotifyAppKey|null|undefined} appkey
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.appkey = null;

	/**
	 * ClientResponseEncrypted clientInfo.
	 * @member {IClientInfo|null|undefined} clientInfo
	 * @memberof ClientResponseEncrypted
	 * @instance
	 */
	ClientResponseEncrypted.prototype.clientInfo = null;

	/**
	 * Creates a new ClientResponseEncrypted instance using the specified properties.
	 * @function create
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {IClientResponseEncrypted=} [properties] Properties to set
	 * @returns {ClientResponseEncrypted} ClientResponseEncrypted instance
	 */
	ClientResponseEncrypted.create = function create(properties) {
		return new ClientResponseEncrypted(properties);
	};

	/**
	 * Encodes the specified ClientResponseEncrypted message. Does not implicitly {@link ClientResponseEncrypted.verify|verify} messages.
	 * @function encode
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {IClientResponseEncrypted} message ClientResponseEncrypted message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientResponseEncrypted.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		$root.LoginCredentials.encode(message.loginCredentials, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.accountCreation != null && Object.hasOwnProperty.call(message, "accountCreation"))
			writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.accountCreation);
		if (message.fingerprintResponse != null && Object.hasOwnProperty.call(message, "fingerprintResponse"))
			$root.FingerprintResponseUnion.encode(message.fingerprintResponse, writer.uint32(/* id 30, wireType 2 =*/ 242).fork()).ldelim();
		if (message.peerTicket != null && Object.hasOwnProperty.call(message, "peerTicket"))
			$root.PeerTicketUnion.encode(message.peerTicket, writer.uint32(/* id 40, wireType 2 =*/ 322).fork()).ldelim();
		$root.SystemInfo.encode(message.systemInfo, writer.uint32(/* id 50, wireType 2 =*/ 402).fork()).ldelim();
		if (message.platformModel != null && Object.hasOwnProperty.call(message, "platformModel"))
			writer.uint32(/* id 60, wireType 2 =*/ 482).string(message.platformModel);
		if (message.versionString != null && Object.hasOwnProperty.call(message, "versionString"))
			writer.uint32(/* id 70, wireType 2 =*/ 562).string(message.versionString);
		if (message.appkey != null && Object.hasOwnProperty.call(message, "appkey"))
			$root.LibspotifyAppKey.encode(message.appkey, writer.uint32(/* id 80, wireType 2 =*/ 642).fork()).ldelim();
		if (message.clientInfo != null && Object.hasOwnProperty.call(message, "clientInfo"))
			$root.ClientInfo.encode(message.clientInfo, writer.uint32(/* id 90, wireType 2 =*/ 722).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ClientResponseEncrypted message, length delimited. Does not implicitly {@link ClientResponseEncrypted.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {IClientResponseEncrypted} message ClientResponseEncrypted message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientResponseEncrypted.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientResponseEncrypted message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientResponseEncrypted} ClientResponseEncrypted
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientResponseEncrypted.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientResponseEncrypted();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.loginCredentials = $root.LoginCredentials.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.accountCreation = reader.int32();
					break;
				}
				case 30: {
					message.fingerprintResponse = $root.FingerprintResponseUnion.decode(reader, reader.uint32());
					break;
				}
				case 40: {
					message.peerTicket = $root.PeerTicketUnion.decode(reader, reader.uint32());
					break;
				}
				case 50: {
					message.systemInfo = $root.SystemInfo.decode(reader, reader.uint32());
					break;
				}
				case 60: {
					message.platformModel = reader.string();
					break;
				}
				case 70: {
					message.versionString = reader.string();
					break;
				}
				case 80: {
					message.appkey = $root.LibspotifyAppKey.decode(reader, reader.uint32());
					break;
				}
				case 90: {
					message.clientInfo = $root.ClientInfo.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("loginCredentials"))
			throw $util.ProtocolError("missing required 'loginCredentials'", { instance: message });
		if (!message.hasOwnProperty("systemInfo")) throw $util.ProtocolError("missing required 'systemInfo'", { instance: message });
		return message;
	};

	/**
	 * Decodes a ClientResponseEncrypted message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientResponseEncrypted} ClientResponseEncrypted
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientResponseEncrypted.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientResponseEncrypted message.
	 * @function verify
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientResponseEncrypted.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		{
			var error = $root.LoginCredentials.verify(message.loginCredentials);
			if (error) return "loginCredentials." + error;
		}
		if (message.accountCreation != null && message.hasOwnProperty("accountCreation"))
			switch (message.accountCreation) {
				default:
					return "accountCreation: enum value expected";
				case 1:
				case 3:
					break;
			}
		if (message.fingerprintResponse != null && message.hasOwnProperty("fingerprintResponse")) {
			var error = $root.FingerprintResponseUnion.verify(message.fingerprintResponse);
			if (error) return "fingerprintResponse." + error;
		}
		if (message.peerTicket != null && message.hasOwnProperty("peerTicket")) {
			var error = $root.PeerTicketUnion.verify(message.peerTicket);
			if (error) return "peerTicket." + error;
		}
		{
			var error = $root.SystemInfo.verify(message.systemInfo);
			if (error) return "systemInfo." + error;
		}
		if (message.platformModel != null && message.hasOwnProperty("platformModel"))
			if (!$util.isString(message.platformModel)) return "platformModel: string expected";
		if (message.versionString != null && message.hasOwnProperty("versionString"))
			if (!$util.isString(message.versionString)) return "versionString: string expected";
		if (message.appkey != null && message.hasOwnProperty("appkey")) {
			var error = $root.LibspotifyAppKey.verify(message.appkey);
			if (error) return "appkey." + error;
		}
		if (message.clientInfo != null && message.hasOwnProperty("clientInfo")) {
			var error = $root.ClientInfo.verify(message.clientInfo);
			if (error) return "clientInfo." + error;
		}
		return null;
	};

	/**
	 * Creates a ClientResponseEncrypted message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientResponseEncrypted} ClientResponseEncrypted
	 */
	ClientResponseEncrypted.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientResponseEncrypted) return object;
		var message = new $root.ClientResponseEncrypted();
		if (object.loginCredentials != null) {
			if (typeof object.loginCredentials !== "object") throw TypeError(".ClientResponseEncrypted.loginCredentials: object expected");
			message.loginCredentials = $root.LoginCredentials.fromObject(object.loginCredentials);
		}
		switch (object.accountCreation) {
			default:
				if (typeof object.accountCreation === "number") {
					message.accountCreation = object.accountCreation;
					break;
				}
				break;
			case "ACCOUNT_CREATION_ALWAYS_PROMPT":
			case 1:
				message.accountCreation = 1;
				break;
			case "ACCOUNT_CREATION_ALWAYS_CREATE":
			case 3:
				message.accountCreation = 3;
				break;
		}
		if (object.fingerprintResponse != null) {
			if (typeof object.fingerprintResponse !== "object")
				throw TypeError(".ClientResponseEncrypted.fingerprintResponse: object expected");
			message.fingerprintResponse = $root.FingerprintResponseUnion.fromObject(object.fingerprintResponse);
		}
		if (object.peerTicket != null) {
			if (typeof object.peerTicket !== "object") throw TypeError(".ClientResponseEncrypted.peerTicket: object expected");
			message.peerTicket = $root.PeerTicketUnion.fromObject(object.peerTicket);
		}
		if (object.systemInfo != null) {
			if (typeof object.systemInfo !== "object") throw TypeError(".ClientResponseEncrypted.systemInfo: object expected");
			message.systemInfo = $root.SystemInfo.fromObject(object.systemInfo);
		}
		if (object.platformModel != null) message.platformModel = String(object.platformModel);
		if (object.versionString != null) message.versionString = String(object.versionString);
		if (object.appkey != null) {
			if (typeof object.appkey !== "object") throw TypeError(".ClientResponseEncrypted.appkey: object expected");
			message.appkey = $root.LibspotifyAppKey.fromObject(object.appkey);
		}
		if (object.clientInfo != null) {
			if (typeof object.clientInfo !== "object") throw TypeError(".ClientResponseEncrypted.clientInfo: object expected");
			message.clientInfo = $root.ClientInfo.fromObject(object.clientInfo);
		}
		return message;
	};

	/**
	 * Creates a plain object from a ClientResponseEncrypted message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {ClientResponseEncrypted} message ClientResponseEncrypted
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientResponseEncrypted.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.loginCredentials = null;
			object.accountCreation = options.enums === String ? "ACCOUNT_CREATION_ALWAYS_PROMPT" : 1;
			object.fingerprintResponse = null;
			object.peerTicket = null;
			object.systemInfo = null;
			object.platformModel = "";
			object.versionString = "";
			object.appkey = null;
			object.clientInfo = null;
		}
		if (message.loginCredentials != null && message.hasOwnProperty("loginCredentials"))
			object.loginCredentials = $root.LoginCredentials.toObject(message.loginCredentials, options);
		if (message.accountCreation != null && message.hasOwnProperty("accountCreation"))
			object.accountCreation =
				options.enums === String
					? $root.AccountCreation[message.accountCreation] === undefined
						? message.accountCreation
						: $root.AccountCreation[message.accountCreation]
					: message.accountCreation;
		if (message.fingerprintResponse != null && message.hasOwnProperty("fingerprintResponse"))
			object.fingerprintResponse = $root.FingerprintResponseUnion.toObject(message.fingerprintResponse, options);
		if (message.peerTicket != null && message.hasOwnProperty("peerTicket"))
			object.peerTicket = $root.PeerTicketUnion.toObject(message.peerTicket, options);
		if (message.systemInfo != null && message.hasOwnProperty("systemInfo"))
			object.systemInfo = $root.SystemInfo.toObject(message.systemInfo, options);
		if (message.platformModel != null && message.hasOwnProperty("platformModel")) object.platformModel = message.platformModel;
		if (message.versionString != null && message.hasOwnProperty("versionString")) object.versionString = message.versionString;
		if (message.appkey != null && message.hasOwnProperty("appkey"))
			object.appkey = $root.LibspotifyAppKey.toObject(message.appkey, options);
		if (message.clientInfo != null && message.hasOwnProperty("clientInfo"))
			object.clientInfo = $root.ClientInfo.toObject(message.clientInfo, options);
		return object;
	};

	/**
	 * Converts this ClientResponseEncrypted to JSON.
	 * @function toJSON
	 * @memberof ClientResponseEncrypted
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientResponseEncrypted.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientResponseEncrypted
	 * @function getTypeUrl
	 * @memberof ClientResponseEncrypted
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientResponseEncrypted.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientResponseEncrypted";
	};

	return ClientResponseEncrypted;
})();

$root.LoginCredentials = (function () {
	/**
	 * Properties of a LoginCredentials.
	 * @exports ILoginCredentials
	 * @interface ILoginCredentials
	 * @property {string|null} [username] LoginCredentials username
	 * @property {AuthenticationType} typ LoginCredentials typ
	 * @property {Uint8Array|null} [authData] LoginCredentials authData
	 */

	/**
	 * Constructs a new LoginCredentials.
	 * @exports LoginCredentials
	 * @classdesc Represents a LoginCredentials.
	 * @implements ILoginCredentials
	 * @constructor
	 * @param {ILoginCredentials=} [properties] Properties to set
	 */
	function LoginCredentials(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * LoginCredentials username.
	 * @member {string} username
	 * @memberof LoginCredentials
	 * @instance
	 */
	LoginCredentials.prototype.username = "";

	/**
	 * LoginCredentials typ.
	 * @member {AuthenticationType} typ
	 * @memberof LoginCredentials
	 * @instance
	 */
	LoginCredentials.prototype.typ = 0;

	/**
	 * LoginCredentials authData.
	 * @member {Uint8Array} authData
	 * @memberof LoginCredentials
	 * @instance
	 */
	LoginCredentials.prototype.authData = $util.newBuffer([]);

	/**
	 * Creates a new LoginCredentials instance using the specified properties.
	 * @function create
	 * @memberof LoginCredentials
	 * @static
	 * @param {ILoginCredentials=} [properties] Properties to set
	 * @returns {LoginCredentials} LoginCredentials instance
	 */
	LoginCredentials.create = function create(properties) {
		return new LoginCredentials(properties);
	};

	/**
	 * Encodes the specified LoginCredentials message. Does not implicitly {@link LoginCredentials.verify|verify} messages.
	 * @function encode
	 * @memberof LoginCredentials
	 * @static
	 * @param {ILoginCredentials} message LoginCredentials message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCredentials.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.username != null && Object.hasOwnProperty.call(message, "username"))
			writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.username);
		writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.typ);
		if (message.authData != null && Object.hasOwnProperty.call(message, "authData"))
			writer.uint32(/* id 30, wireType 2 =*/ 242).bytes(message.authData);
		return writer;
	};

	/**
	 * Encodes the specified LoginCredentials message, length delimited. Does not implicitly {@link LoginCredentials.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof LoginCredentials
	 * @static
	 * @param {ILoginCredentials} message LoginCredentials message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCredentials.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a LoginCredentials message from the specified reader or buffer.
	 * @function decode
	 * @memberof LoginCredentials
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {LoginCredentials} LoginCredentials
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCredentials.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.LoginCredentials();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.username = reader.string();
					break;
				}
				case 20: {
					message.typ = reader.int32();
					break;
				}
				case 30: {
					message.authData = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("typ")) throw $util.ProtocolError("missing required 'typ'", { instance: message });
		return message;
	};

	/**
	 * Decodes a LoginCredentials message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof LoginCredentials
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {LoginCredentials} LoginCredentials
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCredentials.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a LoginCredentials message.
	 * @function verify
	 * @memberof LoginCredentials
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	LoginCredentials.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.username != null && message.hasOwnProperty("username"))
			if (!$util.isString(message.username)) return "username: string expected";
		switch (message.typ) {
			default:
				return "typ: enum value expected";
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
				break;
		}
		if (message.authData != null && message.hasOwnProperty("authData"))
			if (!((message.authData && typeof message.authData.length === "number") || $util.isString(message.authData)))
				return "authData: buffer expected";
		return null;
	};

	/**
	 * Creates a LoginCredentials message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof LoginCredentials
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {LoginCredentials} LoginCredentials
	 */
	LoginCredentials.fromObject = function fromObject(object) {
		if (object instanceof $root.LoginCredentials) return object;
		var message = new $root.LoginCredentials();
		if (object.username != null) message.username = String(object.username);
		switch (object.typ) {
			default:
				if (typeof object.typ === "number") {
					message.typ = object.typ;
					break;
				}
				break;
			case "AUTHENTICATION_USER_PASS":
			case 0:
				message.typ = 0;
				break;
			case "AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS":
			case 1:
				message.typ = 1;
				break;
			case "AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS":
			case 2:
				message.typ = 2;
				break;
			case "AUTHENTICATION_SPOTIFY_TOKEN":
			case 3:
				message.typ = 3;
				break;
			case "AUTHENTICATION_FACEBOOK_TOKEN":
			case 4:
				message.typ = 4;
				break;
		}
		if (object.authData != null)
			if (typeof object.authData === "string")
				$util.base64.decode(object.authData, (message.authData = $util.newBuffer($util.base64.length(object.authData))), 0);
			else if (object.authData.length >= 0) message.authData = object.authData;
		return message;
	};

	/**
	 * Creates a plain object from a LoginCredentials message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof LoginCredentials
	 * @static
	 * @param {LoginCredentials} message LoginCredentials
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	LoginCredentials.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.username = "";
			object.typ = options.enums === String ? "AUTHENTICATION_USER_PASS" : 0;
			if (options.bytes === String) object.authData = "";
			else {
				object.authData = [];
				if (options.bytes !== Array) object.authData = $util.newBuffer(object.authData);
			}
		}
		if (message.username != null && message.hasOwnProperty("username")) object.username = message.username;
		if (message.typ != null && message.hasOwnProperty("typ"))
			object.typ =
				options.enums === String
					? $root.AuthenticationType[message.typ] === undefined
						? message.typ
						: $root.AuthenticationType[message.typ]
					: message.typ;
		if (message.authData != null && message.hasOwnProperty("authData"))
			object.authData =
				options.bytes === String
					? $util.base64.encode(message.authData, 0, message.authData.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.authData)
					: message.authData;
		return object;
	};

	/**
	 * Converts this LoginCredentials to JSON.
	 * @function toJSON
	 * @memberof LoginCredentials
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	LoginCredentials.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for LoginCredentials
	 * @function getTypeUrl
	 * @memberof LoginCredentials
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	LoginCredentials.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/LoginCredentials";
	};

	return LoginCredentials;
})();

/**
 * AuthenticationType enum.
 * @exports AuthenticationType
 * @enum {number}
 * @property {number} AUTHENTICATION_USER_PASS=0 AUTHENTICATION_USER_PASS value
 * @property {number} AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS=1 AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS value
 * @property {number} AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS=2 AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS value
 * @property {number} AUTHENTICATION_SPOTIFY_TOKEN=3 AUTHENTICATION_SPOTIFY_TOKEN value
 * @property {number} AUTHENTICATION_FACEBOOK_TOKEN=4 AUTHENTICATION_FACEBOOK_TOKEN value
 */
$root.AuthenticationType = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "AUTHENTICATION_USER_PASS")] = 0;
	values[(valuesById[1] = "AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS")] = 1;
	values[(valuesById[2] = "AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS")] = 2;
	values[(valuesById[3] = "AUTHENTICATION_SPOTIFY_TOKEN")] = 3;
	values[(valuesById[4] = "AUTHENTICATION_FACEBOOK_TOKEN")] = 4;
	return values;
})();

/**
 * AccountCreation enum.
 * @exports AccountCreation
 * @enum {number}
 * @property {number} ACCOUNT_CREATION_ALWAYS_PROMPT=1 ACCOUNT_CREATION_ALWAYS_PROMPT value
 * @property {number} ACCOUNT_CREATION_ALWAYS_CREATE=3 ACCOUNT_CREATION_ALWAYS_CREATE value
 */
$root.AccountCreation = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[1] = "ACCOUNT_CREATION_ALWAYS_PROMPT")] = 1;
	values[(valuesById[3] = "ACCOUNT_CREATION_ALWAYS_CREATE")] = 3;
	return values;
})();

$root.FingerprintResponseUnion = (function () {
	/**
	 * Properties of a FingerprintResponseUnion.
	 * @exports IFingerprintResponseUnion
	 * @interface IFingerprintResponseUnion
	 * @property {IFingerprintGrainResponse|null} [grain] FingerprintResponseUnion grain
	 * @property {IFingerprintHmacRipemdResponse|null} [hmacRipemd] FingerprintResponseUnion hmacRipemd
	 */

	/**
	 * Constructs a new FingerprintResponseUnion.
	 * @exports FingerprintResponseUnion
	 * @classdesc Represents a FingerprintResponseUnion.
	 * @implements IFingerprintResponseUnion
	 * @constructor
	 * @param {IFingerprintResponseUnion=} [properties] Properties to set
	 */
	function FingerprintResponseUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * FingerprintResponseUnion grain.
	 * @member {IFingerprintGrainResponse|null|undefined} grain
	 * @memberof FingerprintResponseUnion
	 * @instance
	 */
	FingerprintResponseUnion.prototype.grain = null;

	/**
	 * FingerprintResponseUnion hmacRipemd.
	 * @member {IFingerprintHmacRipemdResponse|null|undefined} hmacRipemd
	 * @memberof FingerprintResponseUnion
	 * @instance
	 */
	FingerprintResponseUnion.prototype.hmacRipemd = null;

	/**
	 * Creates a new FingerprintResponseUnion instance using the specified properties.
	 * @function create
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {IFingerprintResponseUnion=} [properties] Properties to set
	 * @returns {FingerprintResponseUnion} FingerprintResponseUnion instance
	 */
	FingerprintResponseUnion.create = function create(properties) {
		return new FingerprintResponseUnion(properties);
	};

	/**
	 * Encodes the specified FingerprintResponseUnion message. Does not implicitly {@link FingerprintResponseUnion.verify|verify} messages.
	 * @function encode
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {IFingerprintResponseUnion} message FingerprintResponseUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintResponseUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.grain != null && Object.hasOwnProperty.call(message, "grain"))
			$root.FingerprintGrainResponse.encode(message.grain, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.hmacRipemd != null && Object.hasOwnProperty.call(message, "hmacRipemd"))
			$root.FingerprintHmacRipemdResponse.encode(message.hmacRipemd, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified FingerprintResponseUnion message, length delimited. Does not implicitly {@link FingerprintResponseUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {IFingerprintResponseUnion} message FingerprintResponseUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintResponseUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a FingerprintResponseUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {FingerprintResponseUnion} FingerprintResponseUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintResponseUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.FingerprintResponseUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.grain = $root.FingerprintGrainResponse.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.hmacRipemd = $root.FingerprintHmacRipemdResponse.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a FingerprintResponseUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {FingerprintResponseUnion} FingerprintResponseUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintResponseUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a FingerprintResponseUnion message.
	 * @function verify
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	FingerprintResponseUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.grain != null && message.hasOwnProperty("grain")) {
			var error = $root.FingerprintGrainResponse.verify(message.grain);
			if (error) return "grain." + error;
		}
		if (message.hmacRipemd != null && message.hasOwnProperty("hmacRipemd")) {
			var error = $root.FingerprintHmacRipemdResponse.verify(message.hmacRipemd);
			if (error) return "hmacRipemd." + error;
		}
		return null;
	};

	/**
	 * Creates a FingerprintResponseUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {FingerprintResponseUnion} FingerprintResponseUnion
	 */
	FingerprintResponseUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.FingerprintResponseUnion) return object;
		var message = new $root.FingerprintResponseUnion();
		if (object.grain != null) {
			if (typeof object.grain !== "object") throw TypeError(".FingerprintResponseUnion.grain: object expected");
			message.grain = $root.FingerprintGrainResponse.fromObject(object.grain);
		}
		if (object.hmacRipemd != null) {
			if (typeof object.hmacRipemd !== "object") throw TypeError(".FingerprintResponseUnion.hmacRipemd: object expected");
			message.hmacRipemd = $root.FingerprintHmacRipemdResponse.fromObject(object.hmacRipemd);
		}
		return message;
	};

	/**
	 * Creates a plain object from a FingerprintResponseUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {FingerprintResponseUnion} message FingerprintResponseUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	FingerprintResponseUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.grain = null;
			object.hmacRipemd = null;
		}
		if (message.grain != null && message.hasOwnProperty("grain"))
			object.grain = $root.FingerprintGrainResponse.toObject(message.grain, options);
		if (message.hmacRipemd != null && message.hasOwnProperty("hmacRipemd"))
			object.hmacRipemd = $root.FingerprintHmacRipemdResponse.toObject(message.hmacRipemd, options);
		return object;
	};

	/**
	 * Converts this FingerprintResponseUnion to JSON.
	 * @function toJSON
	 * @memberof FingerprintResponseUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	FingerprintResponseUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for FingerprintResponseUnion
	 * @function getTypeUrl
	 * @memberof FingerprintResponseUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	FingerprintResponseUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/FingerprintResponseUnion";
	};

	return FingerprintResponseUnion;
})();

$root.FingerprintGrainResponse = (function () {
	/**
	 * Properties of a FingerprintGrainResponse.
	 * @exports IFingerprintGrainResponse
	 * @interface IFingerprintGrainResponse
	 * @property {Uint8Array} encryptedKey FingerprintGrainResponse encryptedKey
	 */

	/**
	 * Constructs a new FingerprintGrainResponse.
	 * @exports FingerprintGrainResponse
	 * @classdesc Represents a FingerprintGrainResponse.
	 * @implements IFingerprintGrainResponse
	 * @constructor
	 * @param {IFingerprintGrainResponse=} [properties] Properties to set
	 */
	function FingerprintGrainResponse(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * FingerprintGrainResponse encryptedKey.
	 * @member {Uint8Array} encryptedKey
	 * @memberof FingerprintGrainResponse
	 * @instance
	 */
	FingerprintGrainResponse.prototype.encryptedKey = $util.newBuffer([]);

	/**
	 * Creates a new FingerprintGrainResponse instance using the specified properties.
	 * @function create
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {IFingerprintGrainResponse=} [properties] Properties to set
	 * @returns {FingerprintGrainResponse} FingerprintGrainResponse instance
	 */
	FingerprintGrainResponse.create = function create(properties) {
		return new FingerprintGrainResponse(properties);
	};

	/**
	 * Encodes the specified FingerprintGrainResponse message. Does not implicitly {@link FingerprintGrainResponse.verify|verify} messages.
	 * @function encode
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {IFingerprintGrainResponse} message FingerprintGrainResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintGrainResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.encryptedKey);
		return writer;
	};

	/**
	 * Encodes the specified FingerprintGrainResponse message, length delimited. Does not implicitly {@link FingerprintGrainResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {IFingerprintGrainResponse} message FingerprintGrainResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintGrainResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a FingerprintGrainResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {FingerprintGrainResponse} FingerprintGrainResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintGrainResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.FingerprintGrainResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.encryptedKey = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("encryptedKey")) throw $util.ProtocolError("missing required 'encryptedKey'", { instance: message });
		return message;
	};

	/**
	 * Decodes a FingerprintGrainResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {FingerprintGrainResponse} FingerprintGrainResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintGrainResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a FingerprintGrainResponse message.
	 * @function verify
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	FingerprintGrainResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.encryptedKey && typeof message.encryptedKey.length === "number") || $util.isString(message.encryptedKey)))
			return "encryptedKey: buffer expected";
		return null;
	};

	/**
	 * Creates a FingerprintGrainResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {FingerprintGrainResponse} FingerprintGrainResponse
	 */
	FingerprintGrainResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.FingerprintGrainResponse) return object;
		var message = new $root.FingerprintGrainResponse();
		if (object.encryptedKey != null)
			if (typeof object.encryptedKey === "string")
				$util.base64.decode(
					object.encryptedKey,
					(message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey))),
					0,
				);
			else if (object.encryptedKey.length >= 0) message.encryptedKey = object.encryptedKey;
		return message;
	};

	/**
	 * Creates a plain object from a FingerprintGrainResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {FingerprintGrainResponse} message FingerprintGrainResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	FingerprintGrainResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.encryptedKey = "";
			else {
				object.encryptedKey = [];
				if (options.bytes !== Array) object.encryptedKey = $util.newBuffer(object.encryptedKey);
			}
		if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
			object.encryptedKey =
				options.bytes === String
					? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.encryptedKey)
					: message.encryptedKey;
		return object;
	};

	/**
	 * Converts this FingerprintGrainResponse to JSON.
	 * @function toJSON
	 * @memberof FingerprintGrainResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	FingerprintGrainResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for FingerprintGrainResponse
	 * @function getTypeUrl
	 * @memberof FingerprintGrainResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	FingerprintGrainResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/FingerprintGrainResponse";
	};

	return FingerprintGrainResponse;
})();

$root.FingerprintHmacRipemdResponse = (function () {
	/**
	 * Properties of a FingerprintHmacRipemdResponse.
	 * @exports IFingerprintHmacRipemdResponse
	 * @interface IFingerprintHmacRipemdResponse
	 * @property {Uint8Array} hmac FingerprintHmacRipemdResponse hmac
	 */

	/**
	 * Constructs a new FingerprintHmacRipemdResponse.
	 * @exports FingerprintHmacRipemdResponse
	 * @classdesc Represents a FingerprintHmacRipemdResponse.
	 * @implements IFingerprintHmacRipemdResponse
	 * @constructor
	 * @param {IFingerprintHmacRipemdResponse=} [properties] Properties to set
	 */
	function FingerprintHmacRipemdResponse(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * FingerprintHmacRipemdResponse hmac.
	 * @member {Uint8Array} hmac
	 * @memberof FingerprintHmacRipemdResponse
	 * @instance
	 */
	FingerprintHmacRipemdResponse.prototype.hmac = $util.newBuffer([]);

	/**
	 * Creates a new FingerprintHmacRipemdResponse instance using the specified properties.
	 * @function create
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {IFingerprintHmacRipemdResponse=} [properties] Properties to set
	 * @returns {FingerprintHmacRipemdResponse} FingerprintHmacRipemdResponse instance
	 */
	FingerprintHmacRipemdResponse.create = function create(properties) {
		return new FingerprintHmacRipemdResponse(properties);
	};

	/**
	 * Encodes the specified FingerprintHmacRipemdResponse message. Does not implicitly {@link FingerprintHmacRipemdResponse.verify|verify} messages.
	 * @function encode
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {IFingerprintHmacRipemdResponse} message FingerprintHmacRipemdResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintHmacRipemdResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.hmac);
		return writer;
	};

	/**
	 * Encodes the specified FingerprintHmacRipemdResponse message, length delimited. Does not implicitly {@link FingerprintHmacRipemdResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {IFingerprintHmacRipemdResponse} message FingerprintHmacRipemdResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintHmacRipemdResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a FingerprintHmacRipemdResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {FingerprintHmacRipemdResponse} FingerprintHmacRipemdResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintHmacRipemdResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.FingerprintHmacRipemdResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.hmac = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("hmac")) throw $util.ProtocolError("missing required 'hmac'", { instance: message });
		return message;
	};

	/**
	 * Decodes a FingerprintHmacRipemdResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {FingerprintHmacRipemdResponse} FingerprintHmacRipemdResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintHmacRipemdResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a FingerprintHmacRipemdResponse message.
	 * @function verify
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	FingerprintHmacRipemdResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.hmac && typeof message.hmac.length === "number") || $util.isString(message.hmac))) return "hmac: buffer expected";
		return null;
	};

	/**
	 * Creates a FingerprintHmacRipemdResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {FingerprintHmacRipemdResponse} FingerprintHmacRipemdResponse
	 */
	FingerprintHmacRipemdResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.FingerprintHmacRipemdResponse) return object;
		var message = new $root.FingerprintHmacRipemdResponse();
		if (object.hmac != null)
			if (typeof object.hmac === "string")
				$util.base64.decode(object.hmac, (message.hmac = $util.newBuffer($util.base64.length(object.hmac))), 0);
			else if (object.hmac.length >= 0) message.hmac = object.hmac;
		return message;
	};

	/**
	 * Creates a plain object from a FingerprintHmacRipemdResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {FingerprintHmacRipemdResponse} message FingerprintHmacRipemdResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	FingerprintHmacRipemdResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.hmac = "";
			else {
				object.hmac = [];
				if (options.bytes !== Array) object.hmac = $util.newBuffer(object.hmac);
			}
		if (message.hmac != null && message.hasOwnProperty("hmac"))
			object.hmac =
				options.bytes === String
					? $util.base64.encode(message.hmac, 0, message.hmac.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.hmac)
					: message.hmac;
		return object;
	};

	/**
	 * Converts this FingerprintHmacRipemdResponse to JSON.
	 * @function toJSON
	 * @memberof FingerprintHmacRipemdResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	FingerprintHmacRipemdResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for FingerprintHmacRipemdResponse
	 * @function getTypeUrl
	 * @memberof FingerprintHmacRipemdResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	FingerprintHmacRipemdResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/FingerprintHmacRipemdResponse";
	};

	return FingerprintHmacRipemdResponse;
})();

$root.PeerTicketUnion = (function () {
	/**
	 * Properties of a PeerTicketUnion.
	 * @exports IPeerTicketUnion
	 * @interface IPeerTicketUnion
	 * @property {IPeerTicketPublicKey|null} [publicKey] PeerTicketUnion publicKey
	 * @property {IPeerTicketOld|null} [oldTicket] PeerTicketUnion oldTicket
	 */

	/**
	 * Constructs a new PeerTicketUnion.
	 * @exports PeerTicketUnion
	 * @classdesc Represents a PeerTicketUnion.
	 * @implements IPeerTicketUnion
	 * @constructor
	 * @param {IPeerTicketUnion=} [properties] Properties to set
	 */
	function PeerTicketUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * PeerTicketUnion publicKey.
	 * @member {IPeerTicketPublicKey|null|undefined} publicKey
	 * @memberof PeerTicketUnion
	 * @instance
	 */
	PeerTicketUnion.prototype.publicKey = null;

	/**
	 * PeerTicketUnion oldTicket.
	 * @member {IPeerTicketOld|null|undefined} oldTicket
	 * @memberof PeerTicketUnion
	 * @instance
	 */
	PeerTicketUnion.prototype.oldTicket = null;

	/**
	 * Creates a new PeerTicketUnion instance using the specified properties.
	 * @function create
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {IPeerTicketUnion=} [properties] Properties to set
	 * @returns {PeerTicketUnion} PeerTicketUnion instance
	 */
	PeerTicketUnion.create = function create(properties) {
		return new PeerTicketUnion(properties);
	};

	/**
	 * Encodes the specified PeerTicketUnion message. Does not implicitly {@link PeerTicketUnion.verify|verify} messages.
	 * @function encode
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {IPeerTicketUnion} message PeerTicketUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PeerTicketUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
			$root.PeerTicketPublicKey.encode(message.publicKey, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.oldTicket != null && Object.hasOwnProperty.call(message, "oldTicket"))
			$root.PeerTicketOld.encode(message.oldTicket, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified PeerTicketUnion message, length delimited. Does not implicitly {@link PeerTicketUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {IPeerTicketUnion} message PeerTicketUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PeerTicketUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a PeerTicketUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {PeerTicketUnion} PeerTicketUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PeerTicketUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.PeerTicketUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.publicKey = $root.PeerTicketPublicKey.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.oldTicket = $root.PeerTicketOld.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a PeerTicketUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {PeerTicketUnion} PeerTicketUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PeerTicketUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a PeerTicketUnion message.
	 * @function verify
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	PeerTicketUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
			var error = $root.PeerTicketPublicKey.verify(message.publicKey);
			if (error) return "publicKey." + error;
		}
		if (message.oldTicket != null && message.hasOwnProperty("oldTicket")) {
			var error = $root.PeerTicketOld.verify(message.oldTicket);
			if (error) return "oldTicket." + error;
		}
		return null;
	};

	/**
	 * Creates a PeerTicketUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {PeerTicketUnion} PeerTicketUnion
	 */
	PeerTicketUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.PeerTicketUnion) return object;
		var message = new $root.PeerTicketUnion();
		if (object.publicKey != null) {
			if (typeof object.publicKey !== "object") throw TypeError(".PeerTicketUnion.publicKey: object expected");
			message.publicKey = $root.PeerTicketPublicKey.fromObject(object.publicKey);
		}
		if (object.oldTicket != null) {
			if (typeof object.oldTicket !== "object") throw TypeError(".PeerTicketUnion.oldTicket: object expected");
			message.oldTicket = $root.PeerTicketOld.fromObject(object.oldTicket);
		}
		return message;
	};

	/**
	 * Creates a plain object from a PeerTicketUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {PeerTicketUnion} message PeerTicketUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	PeerTicketUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.publicKey = null;
			object.oldTicket = null;
		}
		if (message.publicKey != null && message.hasOwnProperty("publicKey"))
			object.publicKey = $root.PeerTicketPublicKey.toObject(message.publicKey, options);
		if (message.oldTicket != null && message.hasOwnProperty("oldTicket"))
			object.oldTicket = $root.PeerTicketOld.toObject(message.oldTicket, options);
		return object;
	};

	/**
	 * Converts this PeerTicketUnion to JSON.
	 * @function toJSON
	 * @memberof PeerTicketUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	PeerTicketUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for PeerTicketUnion
	 * @function getTypeUrl
	 * @memberof PeerTicketUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	PeerTicketUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/PeerTicketUnion";
	};

	return PeerTicketUnion;
})();

$root.PeerTicketPublicKey = (function () {
	/**
	 * Properties of a PeerTicketPublicKey.
	 * @exports IPeerTicketPublicKey
	 * @interface IPeerTicketPublicKey
	 * @property {Uint8Array} publicKey PeerTicketPublicKey publicKey
	 */

	/**
	 * Constructs a new PeerTicketPublicKey.
	 * @exports PeerTicketPublicKey
	 * @classdesc Represents a PeerTicketPublicKey.
	 * @implements IPeerTicketPublicKey
	 * @constructor
	 * @param {IPeerTicketPublicKey=} [properties] Properties to set
	 */
	function PeerTicketPublicKey(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * PeerTicketPublicKey publicKey.
	 * @member {Uint8Array} publicKey
	 * @memberof PeerTicketPublicKey
	 * @instance
	 */
	PeerTicketPublicKey.prototype.publicKey = $util.newBuffer([]);

	/**
	 * Creates a new PeerTicketPublicKey instance using the specified properties.
	 * @function create
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {IPeerTicketPublicKey=} [properties] Properties to set
	 * @returns {PeerTicketPublicKey} PeerTicketPublicKey instance
	 */
	PeerTicketPublicKey.create = function create(properties) {
		return new PeerTicketPublicKey(properties);
	};

	/**
	 * Encodes the specified PeerTicketPublicKey message. Does not implicitly {@link PeerTicketPublicKey.verify|verify} messages.
	 * @function encode
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {IPeerTicketPublicKey} message PeerTicketPublicKey message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PeerTicketPublicKey.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.publicKey);
		return writer;
	};

	/**
	 * Encodes the specified PeerTicketPublicKey message, length delimited. Does not implicitly {@link PeerTicketPublicKey.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {IPeerTicketPublicKey} message PeerTicketPublicKey message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PeerTicketPublicKey.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a PeerTicketPublicKey message from the specified reader or buffer.
	 * @function decode
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {PeerTicketPublicKey} PeerTicketPublicKey
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PeerTicketPublicKey.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.PeerTicketPublicKey();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.publicKey = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("publicKey")) throw $util.ProtocolError("missing required 'publicKey'", { instance: message });
		return message;
	};

	/**
	 * Decodes a PeerTicketPublicKey message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {PeerTicketPublicKey} PeerTicketPublicKey
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PeerTicketPublicKey.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a PeerTicketPublicKey message.
	 * @function verify
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	PeerTicketPublicKey.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.publicKey && typeof message.publicKey.length === "number") || $util.isString(message.publicKey)))
			return "publicKey: buffer expected";
		return null;
	};

	/**
	 * Creates a PeerTicketPublicKey message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {PeerTicketPublicKey} PeerTicketPublicKey
	 */
	PeerTicketPublicKey.fromObject = function fromObject(object) {
		if (object instanceof $root.PeerTicketPublicKey) return object;
		var message = new $root.PeerTicketPublicKey();
		if (object.publicKey != null)
			if (typeof object.publicKey === "string")
				$util.base64.decode(object.publicKey, (message.publicKey = $util.newBuffer($util.base64.length(object.publicKey))), 0);
			else if (object.publicKey.length >= 0) message.publicKey = object.publicKey;
		return message;
	};

	/**
	 * Creates a plain object from a PeerTicketPublicKey message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {PeerTicketPublicKey} message PeerTicketPublicKey
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	PeerTicketPublicKey.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.publicKey = "";
			else {
				object.publicKey = [];
				if (options.bytes !== Array) object.publicKey = $util.newBuffer(object.publicKey);
			}
		if (message.publicKey != null && message.hasOwnProperty("publicKey"))
			object.publicKey =
				options.bytes === String
					? $util.base64.encode(message.publicKey, 0, message.publicKey.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.publicKey)
					: message.publicKey;
		return object;
	};

	/**
	 * Converts this PeerTicketPublicKey to JSON.
	 * @function toJSON
	 * @memberof PeerTicketPublicKey
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	PeerTicketPublicKey.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for PeerTicketPublicKey
	 * @function getTypeUrl
	 * @memberof PeerTicketPublicKey
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	PeerTicketPublicKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/PeerTicketPublicKey";
	};

	return PeerTicketPublicKey;
})();

$root.PeerTicketOld = (function () {
	/**
	 * Properties of a PeerTicketOld.
	 * @exports IPeerTicketOld
	 * @interface IPeerTicketOld
	 * @property {Uint8Array} peerTicket PeerTicketOld peerTicket
	 * @property {Uint8Array} peerTicketSignature PeerTicketOld peerTicketSignature
	 */

	/**
	 * Constructs a new PeerTicketOld.
	 * @exports PeerTicketOld
	 * @classdesc Represents a PeerTicketOld.
	 * @implements IPeerTicketOld
	 * @constructor
	 * @param {IPeerTicketOld=} [properties] Properties to set
	 */
	function PeerTicketOld(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * PeerTicketOld peerTicket.
	 * @member {Uint8Array} peerTicket
	 * @memberof PeerTicketOld
	 * @instance
	 */
	PeerTicketOld.prototype.peerTicket = $util.newBuffer([]);

	/**
	 * PeerTicketOld peerTicketSignature.
	 * @member {Uint8Array} peerTicketSignature
	 * @memberof PeerTicketOld
	 * @instance
	 */
	PeerTicketOld.prototype.peerTicketSignature = $util.newBuffer([]);

	/**
	 * Creates a new PeerTicketOld instance using the specified properties.
	 * @function create
	 * @memberof PeerTicketOld
	 * @static
	 * @param {IPeerTicketOld=} [properties] Properties to set
	 * @returns {PeerTicketOld} PeerTicketOld instance
	 */
	PeerTicketOld.create = function create(properties) {
		return new PeerTicketOld(properties);
	};

	/**
	 * Encodes the specified PeerTicketOld message. Does not implicitly {@link PeerTicketOld.verify|verify} messages.
	 * @function encode
	 * @memberof PeerTicketOld
	 * @static
	 * @param {IPeerTicketOld} message PeerTicketOld message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PeerTicketOld.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.peerTicket);
		writer.uint32(/* id 20, wireType 2 =*/ 162).bytes(message.peerTicketSignature);
		return writer;
	};

	/**
	 * Encodes the specified PeerTicketOld message, length delimited. Does not implicitly {@link PeerTicketOld.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof PeerTicketOld
	 * @static
	 * @param {IPeerTicketOld} message PeerTicketOld message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PeerTicketOld.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a PeerTicketOld message from the specified reader or buffer.
	 * @function decode
	 * @memberof PeerTicketOld
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {PeerTicketOld} PeerTicketOld
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PeerTicketOld.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.PeerTicketOld();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.peerTicket = reader.bytes();
					break;
				}
				case 20: {
					message.peerTicketSignature = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("peerTicket")) throw $util.ProtocolError("missing required 'peerTicket'", { instance: message });
		if (!message.hasOwnProperty("peerTicketSignature"))
			throw $util.ProtocolError("missing required 'peerTicketSignature'", { instance: message });
		return message;
	};

	/**
	 * Decodes a PeerTicketOld message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof PeerTicketOld
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {PeerTicketOld} PeerTicketOld
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PeerTicketOld.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a PeerTicketOld message.
	 * @function verify
	 * @memberof PeerTicketOld
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	PeerTicketOld.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.peerTicket && typeof message.peerTicket.length === "number") || $util.isString(message.peerTicket)))
			return "peerTicket: buffer expected";
		if (
			!(
				(message.peerTicketSignature && typeof message.peerTicketSignature.length === "number") ||
				$util.isString(message.peerTicketSignature)
			)
		)
			return "peerTicketSignature: buffer expected";
		return null;
	};

	/**
	 * Creates a PeerTicketOld message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof PeerTicketOld
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {PeerTicketOld} PeerTicketOld
	 */
	PeerTicketOld.fromObject = function fromObject(object) {
		if (object instanceof $root.PeerTicketOld) return object;
		var message = new $root.PeerTicketOld();
		if (object.peerTicket != null)
			if (typeof object.peerTicket === "string")
				$util.base64.decode(object.peerTicket, (message.peerTicket = $util.newBuffer($util.base64.length(object.peerTicket))), 0);
			else if (object.peerTicket.length >= 0) message.peerTicket = object.peerTicket;
		if (object.peerTicketSignature != null)
			if (typeof object.peerTicketSignature === "string")
				$util.base64.decode(
					object.peerTicketSignature,
					(message.peerTicketSignature = $util.newBuffer($util.base64.length(object.peerTicketSignature))),
					0,
				);
			else if (object.peerTicketSignature.length >= 0) message.peerTicketSignature = object.peerTicketSignature;
		return message;
	};

	/**
	 * Creates a plain object from a PeerTicketOld message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof PeerTicketOld
	 * @static
	 * @param {PeerTicketOld} message PeerTicketOld
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	PeerTicketOld.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			if (options.bytes === String) object.peerTicket = "";
			else {
				object.peerTicket = [];
				if (options.bytes !== Array) object.peerTicket = $util.newBuffer(object.peerTicket);
			}
			if (options.bytes === String) object.peerTicketSignature = "";
			else {
				object.peerTicketSignature = [];
				if (options.bytes !== Array) object.peerTicketSignature = $util.newBuffer(object.peerTicketSignature);
			}
		}
		if (message.peerTicket != null && message.hasOwnProperty("peerTicket"))
			object.peerTicket =
				options.bytes === String
					? $util.base64.encode(message.peerTicket, 0, message.peerTicket.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.peerTicket)
					: message.peerTicket;
		if (message.peerTicketSignature != null && message.hasOwnProperty("peerTicketSignature"))
			object.peerTicketSignature =
				options.bytes === String
					? $util.base64.encode(message.peerTicketSignature, 0, message.peerTicketSignature.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.peerTicketSignature)
					: message.peerTicketSignature;
		return object;
	};

	/**
	 * Converts this PeerTicketOld to JSON.
	 * @function toJSON
	 * @memberof PeerTicketOld
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	PeerTicketOld.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for PeerTicketOld
	 * @function getTypeUrl
	 * @memberof PeerTicketOld
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	PeerTicketOld.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/PeerTicketOld";
	};

	return PeerTicketOld;
})();

$root.SystemInfo = (function () {
	/**
	 * Properties of a SystemInfo.
	 * @exports ISystemInfo
	 * @interface ISystemInfo
	 * @property {CpuFamily} cpuFamily SystemInfo cpuFamily
	 * @property {number|null} [cpuSubtype] SystemInfo cpuSubtype
	 * @property {number|null} [cpuExt] SystemInfo cpuExt
	 * @property {Brand|null} [brand] SystemInfo brand
	 * @property {number|null} [brandFlags] SystemInfo brandFlags
	 * @property {Os} os SystemInfo os
	 * @property {number|null} [osVersion] SystemInfo osVersion
	 * @property {number|null} [osExt] SystemInfo osExt
	 * @property {string|null} [systemInformationString] SystemInfo systemInformationString
	 * @property {string|null} [deviceId] SystemInfo deviceId
	 */

	/**
	 * Constructs a new SystemInfo.
	 * @exports SystemInfo
	 * @classdesc Represents a SystemInfo.
	 * @implements ISystemInfo
	 * @constructor
	 * @param {ISystemInfo=} [properties] Properties to set
	 */
	function SystemInfo(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * SystemInfo cpuFamily.
	 * @member {CpuFamily} cpuFamily
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.cpuFamily = 0;

	/**
	 * SystemInfo cpuSubtype.
	 * @member {number} cpuSubtype
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.cpuSubtype = 0;

	/**
	 * SystemInfo cpuExt.
	 * @member {number} cpuExt
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.cpuExt = 0;

	/**
	 * SystemInfo brand.
	 * @member {Brand} brand
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.brand = 0;

	/**
	 * SystemInfo brandFlags.
	 * @member {number} brandFlags
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.brandFlags = 0;

	/**
	 * SystemInfo os.
	 * @member {Os} os
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.os = 0;

	/**
	 * SystemInfo osVersion.
	 * @member {number} osVersion
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.osVersion = 0;

	/**
	 * SystemInfo osExt.
	 * @member {number} osExt
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.osExt = 0;

	/**
	 * SystemInfo systemInformationString.
	 * @member {string} systemInformationString
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.systemInformationString = "";

	/**
	 * SystemInfo deviceId.
	 * @member {string} deviceId
	 * @memberof SystemInfo
	 * @instance
	 */
	SystemInfo.prototype.deviceId = "";

	/**
	 * Creates a new SystemInfo instance using the specified properties.
	 * @function create
	 * @memberof SystemInfo
	 * @static
	 * @param {ISystemInfo=} [properties] Properties to set
	 * @returns {SystemInfo} SystemInfo instance
	 */
	SystemInfo.create = function create(properties) {
		return new SystemInfo(properties);
	};

	/**
	 * Encodes the specified SystemInfo message. Does not implicitly {@link SystemInfo.verify|verify} messages.
	 * @function encode
	 * @memberof SystemInfo
	 * @static
	 * @param {ISystemInfo} message SystemInfo message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	SystemInfo.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.cpuFamily);
		if (message.cpuSubtype != null && Object.hasOwnProperty.call(message, "cpuSubtype"))
			writer.uint32(/* id 20, wireType 0 =*/ 160).uint32(message.cpuSubtype);
		if (message.cpuExt != null && Object.hasOwnProperty.call(message, "cpuExt"))
			writer.uint32(/* id 30, wireType 0 =*/ 240).uint32(message.cpuExt);
		if (message.brand != null && Object.hasOwnProperty.call(message, "brand"))
			writer.uint32(/* id 40, wireType 0 =*/ 320).int32(message.brand);
		if (message.brandFlags != null && Object.hasOwnProperty.call(message, "brandFlags"))
			writer.uint32(/* id 50, wireType 0 =*/ 400).uint32(message.brandFlags);
		writer.uint32(/* id 60, wireType 0 =*/ 480).int32(message.os);
		if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
			writer.uint32(/* id 70, wireType 0 =*/ 560).uint32(message.osVersion);
		if (message.osExt != null && Object.hasOwnProperty.call(message, "osExt"))
			writer.uint32(/* id 80, wireType 0 =*/ 640).uint32(message.osExt);
		if (message.systemInformationString != null && Object.hasOwnProperty.call(message, "systemInformationString"))
			writer.uint32(/* id 90, wireType 2 =*/ 722).string(message.systemInformationString);
		if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
			writer.uint32(/* id 100, wireType 2 =*/ 802).string(message.deviceId);
		return writer;
	};

	/**
	 * Encodes the specified SystemInfo message, length delimited. Does not implicitly {@link SystemInfo.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof SystemInfo
	 * @static
	 * @param {ISystemInfo} message SystemInfo message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	SystemInfo.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a SystemInfo message from the specified reader or buffer.
	 * @function decode
	 * @memberof SystemInfo
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {SystemInfo} SystemInfo
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	SystemInfo.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.SystemInfo();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.cpuFamily = reader.int32();
					break;
				}
				case 20: {
					message.cpuSubtype = reader.uint32();
					break;
				}
				case 30: {
					message.cpuExt = reader.uint32();
					break;
				}
				case 40: {
					message.brand = reader.int32();
					break;
				}
				case 50: {
					message.brandFlags = reader.uint32();
					break;
				}
				case 60: {
					message.os = reader.int32();
					break;
				}
				case 70: {
					message.osVersion = reader.uint32();
					break;
				}
				case 80: {
					message.osExt = reader.uint32();
					break;
				}
				case 90: {
					message.systemInformationString = reader.string();
					break;
				}
				case 100: {
					message.deviceId = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("cpuFamily")) throw $util.ProtocolError("missing required 'cpuFamily'", { instance: message });
		if (!message.hasOwnProperty("os")) throw $util.ProtocolError("missing required 'os'", { instance: message });
		return message;
	};

	/**
	 * Decodes a SystemInfo message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof SystemInfo
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {SystemInfo} SystemInfo
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	SystemInfo.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a SystemInfo message.
	 * @function verify
	 * @memberof SystemInfo
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	SystemInfo.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		switch (message.cpuFamily) {
			default:
				return "cpuFamily: enum value expected";
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
				break;
		}
		if (message.cpuSubtype != null && message.hasOwnProperty("cpuSubtype"))
			if (!$util.isInteger(message.cpuSubtype)) return "cpuSubtype: integer expected";
		if (message.cpuExt != null && message.hasOwnProperty("cpuExt"))
			if (!$util.isInteger(message.cpuExt)) return "cpuExt: integer expected";
		if (message.brand != null && message.hasOwnProperty("brand"))
			switch (message.brand) {
				default:
					return "brand: enum value expected";
				case 0:
				case 1:
				case 2:
				case 3:
					break;
			}
		if (message.brandFlags != null && message.hasOwnProperty("brandFlags"))
			if (!$util.isInteger(message.brandFlags)) return "brandFlags: integer expected";
		switch (message.os) {
			default:
				return "os: enum value expected";
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
				break;
		}
		if (message.osVersion != null && message.hasOwnProperty("osVersion"))
			if (!$util.isInteger(message.osVersion)) return "osVersion: integer expected";
		if (message.osExt != null && message.hasOwnProperty("osExt")) if (!$util.isInteger(message.osExt)) return "osExt: integer expected";
		if (message.systemInformationString != null && message.hasOwnProperty("systemInformationString"))
			if (!$util.isString(message.systemInformationString)) return "systemInformationString: string expected";
		if (message.deviceId != null && message.hasOwnProperty("deviceId"))
			if (!$util.isString(message.deviceId)) return "deviceId: string expected";
		return null;
	};

	/**
	 * Creates a SystemInfo message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof SystemInfo
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {SystemInfo} SystemInfo
	 */
	SystemInfo.fromObject = function fromObject(object) {
		if (object instanceof $root.SystemInfo) return object;
		var message = new $root.SystemInfo();
		switch (object.cpuFamily) {
			default:
				if (typeof object.cpuFamily === "number") {
					message.cpuFamily = object.cpuFamily;
					break;
				}
				break;
			case "CPU_UNKNOWN":
			case 0:
				message.cpuFamily = 0;
				break;
			case "CPU_X86":
			case 1:
				message.cpuFamily = 1;
				break;
			case "CPU_X86_64":
			case 2:
				message.cpuFamily = 2;
				break;
			case "CPU_PPC":
			case 3:
				message.cpuFamily = 3;
				break;
			case "CPU_PPC_64":
			case 4:
				message.cpuFamily = 4;
				break;
			case "CPU_ARM":
			case 5:
				message.cpuFamily = 5;
				break;
			case "CPU_IA64":
			case 6:
				message.cpuFamily = 6;
				break;
			case "CPU_SH":
			case 7:
				message.cpuFamily = 7;
				break;
			case "CPU_MIPS":
			case 8:
				message.cpuFamily = 8;
				break;
			case "CPU_BLACKFIN":
			case 9:
				message.cpuFamily = 9;
				break;
		}
		if (object.cpuSubtype != null) message.cpuSubtype = object.cpuSubtype >>> 0;
		if (object.cpuExt != null) message.cpuExt = object.cpuExt >>> 0;
		switch (object.brand) {
			default:
				if (typeof object.brand === "number") {
					message.brand = object.brand;
					break;
				}
				break;
			case "BRAND_UNBRANDED":
			case 0:
				message.brand = 0;
				break;
			case "BRAND_INQ":
			case 1:
				message.brand = 1;
				break;
			case "BRAND_HTC":
			case 2:
				message.brand = 2;
				break;
			case "BRAND_NOKIA":
			case 3:
				message.brand = 3;
				break;
		}
		if (object.brandFlags != null) message.brandFlags = object.brandFlags >>> 0;
		switch (object.os) {
			default:
				if (typeof object.os === "number") {
					message.os = object.os;
					break;
				}
				break;
			case "OS_UNKNOWN":
			case 0:
				message.os = 0;
				break;
			case "OS_WINDOWS":
			case 1:
				message.os = 1;
				break;
			case "OS_OSX":
			case 2:
				message.os = 2;
				break;
			case "OS_IPHONE":
			case 3:
				message.os = 3;
				break;
			case "OS_S60":
			case 4:
				message.os = 4;
				break;
			case "OS_LINUX":
			case 5:
				message.os = 5;
				break;
			case "OS_WINDOWS_CE":
			case 6:
				message.os = 6;
				break;
			case "OS_ANDROID":
			case 7:
				message.os = 7;
				break;
			case "OS_PALM":
			case 8:
				message.os = 8;
				break;
			case "OS_FREEBSD":
			case 9:
				message.os = 9;
				break;
			case "OS_BLACKBERRY":
			case 10:
				message.os = 10;
				break;
			case "OS_SONOS":
			case 11:
				message.os = 11;
				break;
			case "OS_LOGITECH":
			case 12:
				message.os = 12;
				break;
			case "OS_WP7":
			case 13:
				message.os = 13;
				break;
			case "OS_ONKYO":
			case 14:
				message.os = 14;
				break;
			case "OS_PHILIPS":
			case 15:
				message.os = 15;
				break;
			case "OS_WD":
			case 16:
				message.os = 16;
				break;
			case "OS_VOLVO":
			case 17:
				message.os = 17;
				break;
			case "OS_TIVO":
			case 18:
				message.os = 18;
				break;
			case "OS_AWOX":
			case 19:
				message.os = 19;
				break;
			case "OS_MEEGO":
			case 20:
				message.os = 20;
				break;
			case "OS_QNXNTO":
			case 21:
				message.os = 21;
				break;
			case "OS_BCO":
			case 22:
				message.os = 22;
				break;
		}
		if (object.osVersion != null) message.osVersion = object.osVersion >>> 0;
		if (object.osExt != null) message.osExt = object.osExt >>> 0;
		if (object.systemInformationString != null) message.systemInformationString = String(object.systemInformationString);
		if (object.deviceId != null) message.deviceId = String(object.deviceId);
		return message;
	};

	/**
	 * Creates a plain object from a SystemInfo message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof SystemInfo
	 * @static
	 * @param {SystemInfo} message SystemInfo
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	SystemInfo.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.cpuFamily = options.enums === String ? "CPU_UNKNOWN" : 0;
			object.cpuSubtype = 0;
			object.cpuExt = 0;
			object.brand = options.enums === String ? "BRAND_UNBRANDED" : 0;
			object.brandFlags = 0;
			object.os = options.enums === String ? "OS_UNKNOWN" : 0;
			object.osVersion = 0;
			object.osExt = 0;
			object.systemInformationString = "";
			object.deviceId = "";
		}
		if (message.cpuFamily != null && message.hasOwnProperty("cpuFamily"))
			object.cpuFamily =
				options.enums === String
					? $root.CpuFamily[message.cpuFamily] === undefined
						? message.cpuFamily
						: $root.CpuFamily[message.cpuFamily]
					: message.cpuFamily;
		if (message.cpuSubtype != null && message.hasOwnProperty("cpuSubtype")) object.cpuSubtype = message.cpuSubtype;
		if (message.cpuExt != null && message.hasOwnProperty("cpuExt")) object.cpuExt = message.cpuExt;
		if (message.brand != null && message.hasOwnProperty("brand"))
			object.brand =
				options.enums === String
					? $root.Brand[message.brand] === undefined
						? message.brand
						: $root.Brand[message.brand]
					: message.brand;
		if (message.brandFlags != null && message.hasOwnProperty("brandFlags")) object.brandFlags = message.brandFlags;
		if (message.os != null && message.hasOwnProperty("os"))
			object.os = options.enums === String ? ($root.Os[message.os] === undefined ? message.os : $root.Os[message.os]) : message.os;
		if (message.osVersion != null && message.hasOwnProperty("osVersion")) object.osVersion = message.osVersion;
		if (message.osExt != null && message.hasOwnProperty("osExt")) object.osExt = message.osExt;
		if (message.systemInformationString != null && message.hasOwnProperty("systemInformationString"))
			object.systemInformationString = message.systemInformationString;
		if (message.deviceId != null && message.hasOwnProperty("deviceId")) object.deviceId = message.deviceId;
		return object;
	};

	/**
	 * Converts this SystemInfo to JSON.
	 * @function toJSON
	 * @memberof SystemInfo
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	SystemInfo.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for SystemInfo
	 * @function getTypeUrl
	 * @memberof SystemInfo
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	SystemInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/SystemInfo";
	};

	return SystemInfo;
})();

/**
 * CpuFamily enum.
 * @exports CpuFamily
 * @enum {number}
 * @property {number} CPU_UNKNOWN=0 CPU_UNKNOWN value
 * @property {number} CPU_X86=1 CPU_X86 value
 * @property {number} CPU_X86_64=2 CPU_X86_64 value
 * @property {number} CPU_PPC=3 CPU_PPC value
 * @property {number} CPU_PPC_64=4 CPU_PPC_64 value
 * @property {number} CPU_ARM=5 CPU_ARM value
 * @property {number} CPU_IA64=6 CPU_IA64 value
 * @property {number} CPU_SH=7 CPU_SH value
 * @property {number} CPU_MIPS=8 CPU_MIPS value
 * @property {number} CPU_BLACKFIN=9 CPU_BLACKFIN value
 */
$root.CpuFamily = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "CPU_UNKNOWN")] = 0;
	values[(valuesById[1] = "CPU_X86")] = 1;
	values[(valuesById[2] = "CPU_X86_64")] = 2;
	values[(valuesById[3] = "CPU_PPC")] = 3;
	values[(valuesById[4] = "CPU_PPC_64")] = 4;
	values[(valuesById[5] = "CPU_ARM")] = 5;
	values[(valuesById[6] = "CPU_IA64")] = 6;
	values[(valuesById[7] = "CPU_SH")] = 7;
	values[(valuesById[8] = "CPU_MIPS")] = 8;
	values[(valuesById[9] = "CPU_BLACKFIN")] = 9;
	return values;
})();

/**
 * Brand enum.
 * @exports Brand
 * @enum {number}
 * @property {number} BRAND_UNBRANDED=0 BRAND_UNBRANDED value
 * @property {number} BRAND_INQ=1 BRAND_INQ value
 * @property {number} BRAND_HTC=2 BRAND_HTC value
 * @property {number} BRAND_NOKIA=3 BRAND_NOKIA value
 */
$root.Brand = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "BRAND_UNBRANDED")] = 0;
	values[(valuesById[1] = "BRAND_INQ")] = 1;
	values[(valuesById[2] = "BRAND_HTC")] = 2;
	values[(valuesById[3] = "BRAND_NOKIA")] = 3;
	return values;
})();

/**
 * Os enum.
 * @exports Os
 * @enum {number}
 * @property {number} OS_UNKNOWN=0 OS_UNKNOWN value
 * @property {number} OS_WINDOWS=1 OS_WINDOWS value
 * @property {number} OS_OSX=2 OS_OSX value
 * @property {number} OS_IPHONE=3 OS_IPHONE value
 * @property {number} OS_S60=4 OS_S60 value
 * @property {number} OS_LINUX=5 OS_LINUX value
 * @property {number} OS_WINDOWS_CE=6 OS_WINDOWS_CE value
 * @property {number} OS_ANDROID=7 OS_ANDROID value
 * @property {number} OS_PALM=8 OS_PALM value
 * @property {number} OS_FREEBSD=9 OS_FREEBSD value
 * @property {number} OS_BLACKBERRY=10 OS_BLACKBERRY value
 * @property {number} OS_SONOS=11 OS_SONOS value
 * @property {number} OS_LOGITECH=12 OS_LOGITECH value
 * @property {number} OS_WP7=13 OS_WP7 value
 * @property {number} OS_ONKYO=14 OS_ONKYO value
 * @property {number} OS_PHILIPS=15 OS_PHILIPS value
 * @property {number} OS_WD=16 OS_WD value
 * @property {number} OS_VOLVO=17 OS_VOLVO value
 * @property {number} OS_TIVO=18 OS_TIVO value
 * @property {number} OS_AWOX=19 OS_AWOX value
 * @property {number} OS_MEEGO=20 OS_MEEGO value
 * @property {number} OS_QNXNTO=21 OS_QNXNTO value
 * @property {number} OS_BCO=22 OS_BCO value
 */
$root.Os = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "OS_UNKNOWN")] = 0;
	values[(valuesById[1] = "OS_WINDOWS")] = 1;
	values[(valuesById[2] = "OS_OSX")] = 2;
	values[(valuesById[3] = "OS_IPHONE")] = 3;
	values[(valuesById[4] = "OS_S60")] = 4;
	values[(valuesById[5] = "OS_LINUX")] = 5;
	values[(valuesById[6] = "OS_WINDOWS_CE")] = 6;
	values[(valuesById[7] = "OS_ANDROID")] = 7;
	values[(valuesById[8] = "OS_PALM")] = 8;
	values[(valuesById[9] = "OS_FREEBSD")] = 9;
	values[(valuesById[10] = "OS_BLACKBERRY")] = 10;
	values[(valuesById[11] = "OS_SONOS")] = 11;
	values[(valuesById[12] = "OS_LOGITECH")] = 12;
	values[(valuesById[13] = "OS_WP7")] = 13;
	values[(valuesById[14] = "OS_ONKYO")] = 14;
	values[(valuesById[15] = "OS_PHILIPS")] = 15;
	values[(valuesById[16] = "OS_WD")] = 16;
	values[(valuesById[17] = "OS_VOLVO")] = 17;
	values[(valuesById[18] = "OS_TIVO")] = 18;
	values[(valuesById[19] = "OS_AWOX")] = 19;
	values[(valuesById[20] = "OS_MEEGO")] = 20;
	values[(valuesById[21] = "OS_QNXNTO")] = 21;
	values[(valuesById[22] = "OS_BCO")] = 22;
	return values;
})();

$root.LibspotifyAppKey = (function () {
	/**
	 * Properties of a LibspotifyAppKey.
	 * @exports ILibspotifyAppKey
	 * @interface ILibspotifyAppKey
	 * @property {number} version LibspotifyAppKey version
	 * @property {Uint8Array} devkey LibspotifyAppKey devkey
	 * @property {Uint8Array} signature LibspotifyAppKey signature
	 * @property {string} useragent LibspotifyAppKey useragent
	 * @property {Uint8Array} callbackHash LibspotifyAppKey callbackHash
	 */

	/**
	 * Constructs a new LibspotifyAppKey.
	 * @exports LibspotifyAppKey
	 * @classdesc Represents a LibspotifyAppKey.
	 * @implements ILibspotifyAppKey
	 * @constructor
	 * @param {ILibspotifyAppKey=} [properties] Properties to set
	 */
	function LibspotifyAppKey(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * LibspotifyAppKey version.
	 * @member {number} version
	 * @memberof LibspotifyAppKey
	 * @instance
	 */
	LibspotifyAppKey.prototype.version = 0;

	/**
	 * LibspotifyAppKey devkey.
	 * @member {Uint8Array} devkey
	 * @memberof LibspotifyAppKey
	 * @instance
	 */
	LibspotifyAppKey.prototype.devkey = $util.newBuffer([]);

	/**
	 * LibspotifyAppKey signature.
	 * @member {Uint8Array} signature
	 * @memberof LibspotifyAppKey
	 * @instance
	 */
	LibspotifyAppKey.prototype.signature = $util.newBuffer([]);

	/**
	 * LibspotifyAppKey useragent.
	 * @member {string} useragent
	 * @memberof LibspotifyAppKey
	 * @instance
	 */
	LibspotifyAppKey.prototype.useragent = "";

	/**
	 * LibspotifyAppKey callbackHash.
	 * @member {Uint8Array} callbackHash
	 * @memberof LibspotifyAppKey
	 * @instance
	 */
	LibspotifyAppKey.prototype.callbackHash = $util.newBuffer([]);

	/**
	 * Creates a new LibspotifyAppKey instance using the specified properties.
	 * @function create
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {ILibspotifyAppKey=} [properties] Properties to set
	 * @returns {LibspotifyAppKey} LibspotifyAppKey instance
	 */
	LibspotifyAppKey.create = function create(properties) {
		return new LibspotifyAppKey(properties);
	};

	/**
	 * Encodes the specified LibspotifyAppKey message. Does not implicitly {@link LibspotifyAppKey.verify|verify} messages.
	 * @function encode
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {ILibspotifyAppKey} message LibspotifyAppKey message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LibspotifyAppKey.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.version);
		writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.devkey);
		writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.signature);
		writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.useragent);
		writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.callbackHash);
		return writer;
	};

	/**
	 * Encodes the specified LibspotifyAppKey message, length delimited. Does not implicitly {@link LibspotifyAppKey.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {ILibspotifyAppKey} message LibspotifyAppKey message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LibspotifyAppKey.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a LibspotifyAppKey message from the specified reader or buffer.
	 * @function decode
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {LibspotifyAppKey} LibspotifyAppKey
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LibspotifyAppKey.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.LibspotifyAppKey();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.version = reader.uint32();
					break;
				}
				case 2: {
					message.devkey = reader.bytes();
					break;
				}
				case 3: {
					message.signature = reader.bytes();
					break;
				}
				case 4: {
					message.useragent = reader.string();
					break;
				}
				case 5: {
					message.callbackHash = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("version")) throw $util.ProtocolError("missing required 'version'", { instance: message });
		if (!message.hasOwnProperty("devkey")) throw $util.ProtocolError("missing required 'devkey'", { instance: message });
		if (!message.hasOwnProperty("signature")) throw $util.ProtocolError("missing required 'signature'", { instance: message });
		if (!message.hasOwnProperty("useragent")) throw $util.ProtocolError("missing required 'useragent'", { instance: message });
		if (!message.hasOwnProperty("callbackHash")) throw $util.ProtocolError("missing required 'callbackHash'", { instance: message });
		return message;
	};

	/**
	 * Decodes a LibspotifyAppKey message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {LibspotifyAppKey} LibspotifyAppKey
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LibspotifyAppKey.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a LibspotifyAppKey message.
	 * @function verify
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	LibspotifyAppKey.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!$util.isInteger(message.version)) return "version: integer expected";
		if (!((message.devkey && typeof message.devkey.length === "number") || $util.isString(message.devkey)))
			return "devkey: buffer expected";
		if (!((message.signature && typeof message.signature.length === "number") || $util.isString(message.signature)))
			return "signature: buffer expected";
		if (!$util.isString(message.useragent)) return "useragent: string expected";
		if (!((message.callbackHash && typeof message.callbackHash.length === "number") || $util.isString(message.callbackHash)))
			return "callbackHash: buffer expected";
		return null;
	};

	/**
	 * Creates a LibspotifyAppKey message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {LibspotifyAppKey} LibspotifyAppKey
	 */
	LibspotifyAppKey.fromObject = function fromObject(object) {
		if (object instanceof $root.LibspotifyAppKey) return object;
		var message = new $root.LibspotifyAppKey();
		if (object.version != null) message.version = object.version >>> 0;
		if (object.devkey != null)
			if (typeof object.devkey === "string")
				$util.base64.decode(object.devkey, (message.devkey = $util.newBuffer($util.base64.length(object.devkey))), 0);
			else if (object.devkey.length >= 0) message.devkey = object.devkey;
		if (object.signature != null)
			if (typeof object.signature === "string")
				$util.base64.decode(object.signature, (message.signature = $util.newBuffer($util.base64.length(object.signature))), 0);
			else if (object.signature.length >= 0) message.signature = object.signature;
		if (object.useragent != null) message.useragent = String(object.useragent);
		if (object.callbackHash != null)
			if (typeof object.callbackHash === "string")
				$util.base64.decode(
					object.callbackHash,
					(message.callbackHash = $util.newBuffer($util.base64.length(object.callbackHash))),
					0,
				);
			else if (object.callbackHash.length >= 0) message.callbackHash = object.callbackHash;
		return message;
	};

	/**
	 * Creates a plain object from a LibspotifyAppKey message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {LibspotifyAppKey} message LibspotifyAppKey
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	LibspotifyAppKey.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.version = 0;
			if (options.bytes === String) object.devkey = "";
			else {
				object.devkey = [];
				if (options.bytes !== Array) object.devkey = $util.newBuffer(object.devkey);
			}
			if (options.bytes === String) object.signature = "";
			else {
				object.signature = [];
				if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);
			}
			object.useragent = "";
			if (options.bytes === String) object.callbackHash = "";
			else {
				object.callbackHash = [];
				if (options.bytes !== Array) object.callbackHash = $util.newBuffer(object.callbackHash);
			}
		}
		if (message.version != null && message.hasOwnProperty("version")) object.version = message.version;
		if (message.devkey != null && message.hasOwnProperty("devkey"))
			object.devkey =
				options.bytes === String
					? $util.base64.encode(message.devkey, 0, message.devkey.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.devkey)
					: message.devkey;
		if (message.signature != null && message.hasOwnProperty("signature"))
			object.signature =
				options.bytes === String
					? $util.base64.encode(message.signature, 0, message.signature.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.signature)
					: message.signature;
		if (message.useragent != null && message.hasOwnProperty("useragent")) object.useragent = message.useragent;
		if (message.callbackHash != null && message.hasOwnProperty("callbackHash"))
			object.callbackHash =
				options.bytes === String
					? $util.base64.encode(message.callbackHash, 0, message.callbackHash.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.callbackHash)
					: message.callbackHash;
		return object;
	};

	/**
	 * Converts this LibspotifyAppKey to JSON.
	 * @function toJSON
	 * @memberof LibspotifyAppKey
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	LibspotifyAppKey.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for LibspotifyAppKey
	 * @function getTypeUrl
	 * @memberof LibspotifyAppKey
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	LibspotifyAppKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/LibspotifyAppKey";
	};

	return LibspotifyAppKey;
})();

$root.ClientInfo = (function () {
	/**
	 * Properties of a ClientInfo.
	 * @exports IClientInfo
	 * @interface IClientInfo
	 * @property {boolean|null} [limited] ClientInfo limited
	 * @property {IClientInfoFacebook|null} [fb] ClientInfo fb
	 * @property {string|null} [language] ClientInfo language
	 */

	/**
	 * Constructs a new ClientInfo.
	 * @exports ClientInfo
	 * @classdesc Represents a ClientInfo.
	 * @implements IClientInfo
	 * @constructor
	 * @param {IClientInfo=} [properties] Properties to set
	 */
	function ClientInfo(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientInfo limited.
	 * @member {boolean} limited
	 * @memberof ClientInfo
	 * @instance
	 */
	ClientInfo.prototype.limited = false;

	/**
	 * ClientInfo fb.
	 * @member {IClientInfoFacebook|null|undefined} fb
	 * @memberof ClientInfo
	 * @instance
	 */
	ClientInfo.prototype.fb = null;

	/**
	 * ClientInfo language.
	 * @member {string} language
	 * @memberof ClientInfo
	 * @instance
	 */
	ClientInfo.prototype.language = "";

	/**
	 * Creates a new ClientInfo instance using the specified properties.
	 * @function create
	 * @memberof ClientInfo
	 * @static
	 * @param {IClientInfo=} [properties] Properties to set
	 * @returns {ClientInfo} ClientInfo instance
	 */
	ClientInfo.create = function create(properties) {
		return new ClientInfo(properties);
	};

	/**
	 * Encodes the specified ClientInfo message. Does not implicitly {@link ClientInfo.verify|verify} messages.
	 * @function encode
	 * @memberof ClientInfo
	 * @static
	 * @param {IClientInfo} message ClientInfo message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientInfo.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.limited != null && Object.hasOwnProperty.call(message, "limited"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.limited);
		if (message.fb != null && Object.hasOwnProperty.call(message, "fb"))
			$root.ClientInfoFacebook.encode(message.fb, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		if (message.language != null && Object.hasOwnProperty.call(message, "language"))
			writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.language);
		return writer;
	};

	/**
	 * Encodes the specified ClientInfo message, length delimited. Does not implicitly {@link ClientInfo.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientInfo
	 * @static
	 * @param {IClientInfo} message ClientInfo message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientInfo.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientInfo message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientInfo
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientInfo} ClientInfo
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientInfo.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientInfo();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.limited = reader.bool();
					break;
				}
				case 2: {
					message.fb = $root.ClientInfoFacebook.decode(reader, reader.uint32());
					break;
				}
				case 3: {
					message.language = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ClientInfo message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientInfo
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientInfo} ClientInfo
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientInfo.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientInfo message.
	 * @function verify
	 * @memberof ClientInfo
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientInfo.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.limited != null && message.hasOwnProperty("limited"))
			if (typeof message.limited !== "boolean") return "limited: boolean expected";
		if (message.fb != null && message.hasOwnProperty("fb")) {
			var error = $root.ClientInfoFacebook.verify(message.fb);
			if (error) return "fb." + error;
		}
		if (message.language != null && message.hasOwnProperty("language"))
			if (!$util.isString(message.language)) return "language: string expected";
		return null;
	};

	/**
	 * Creates a ClientInfo message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientInfo
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientInfo} ClientInfo
	 */
	ClientInfo.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientInfo) return object;
		var message = new $root.ClientInfo();
		if (object.limited != null) message.limited = Boolean(object.limited);
		if (object.fb != null) {
			if (typeof object.fb !== "object") throw TypeError(".ClientInfo.fb: object expected");
			message.fb = $root.ClientInfoFacebook.fromObject(object.fb);
		}
		if (object.language != null) message.language = String(object.language);
		return message;
	};

	/**
	 * Creates a plain object from a ClientInfo message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientInfo
	 * @static
	 * @param {ClientInfo} message ClientInfo
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientInfo.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.limited = false;
			object.fb = null;
			object.language = "";
		}
		if (message.limited != null && message.hasOwnProperty("limited")) object.limited = message.limited;
		if (message.fb != null && message.hasOwnProperty("fb")) object.fb = $root.ClientInfoFacebook.toObject(message.fb, options);
		if (message.language != null && message.hasOwnProperty("language")) object.language = message.language;
		return object;
	};

	/**
	 * Converts this ClientInfo to JSON.
	 * @function toJSON
	 * @memberof ClientInfo
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientInfo.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientInfo
	 * @function getTypeUrl
	 * @memberof ClientInfo
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientInfo";
	};

	return ClientInfo;
})();

$root.ClientInfoFacebook = (function () {
	/**
	 * Properties of a ClientInfoFacebook.
	 * @exports IClientInfoFacebook
	 * @interface IClientInfoFacebook
	 * @property {string|null} [machineId] ClientInfoFacebook machineId
	 */

	/**
	 * Constructs a new ClientInfoFacebook.
	 * @exports ClientInfoFacebook
	 * @classdesc Represents a ClientInfoFacebook.
	 * @implements IClientInfoFacebook
	 * @constructor
	 * @param {IClientInfoFacebook=} [properties] Properties to set
	 */
	function ClientInfoFacebook(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientInfoFacebook machineId.
	 * @member {string} machineId
	 * @memberof ClientInfoFacebook
	 * @instance
	 */
	ClientInfoFacebook.prototype.machineId = "";

	/**
	 * Creates a new ClientInfoFacebook instance using the specified properties.
	 * @function create
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {IClientInfoFacebook=} [properties] Properties to set
	 * @returns {ClientInfoFacebook} ClientInfoFacebook instance
	 */
	ClientInfoFacebook.create = function create(properties) {
		return new ClientInfoFacebook(properties);
	};

	/**
	 * Encodes the specified ClientInfoFacebook message. Does not implicitly {@link ClientInfoFacebook.verify|verify} messages.
	 * @function encode
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {IClientInfoFacebook} message ClientInfoFacebook message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientInfoFacebook.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.machineId != null && Object.hasOwnProperty.call(message, "machineId"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.machineId);
		return writer;
	};

	/**
	 * Encodes the specified ClientInfoFacebook message, length delimited. Does not implicitly {@link ClientInfoFacebook.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {IClientInfoFacebook} message ClientInfoFacebook message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientInfoFacebook.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientInfoFacebook message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientInfoFacebook} ClientInfoFacebook
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientInfoFacebook.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientInfoFacebook();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.machineId = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ClientInfoFacebook message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientInfoFacebook} ClientInfoFacebook
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientInfoFacebook.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientInfoFacebook message.
	 * @function verify
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientInfoFacebook.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.machineId != null && message.hasOwnProperty("machineId"))
			if (!$util.isString(message.machineId)) return "machineId: string expected";
		return null;
	};

	/**
	 * Creates a ClientInfoFacebook message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientInfoFacebook} ClientInfoFacebook
	 */
	ClientInfoFacebook.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientInfoFacebook) return object;
		var message = new $root.ClientInfoFacebook();
		if (object.machineId != null) message.machineId = String(object.machineId);
		return message;
	};

	/**
	 * Creates a plain object from a ClientInfoFacebook message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {ClientInfoFacebook} message ClientInfoFacebook
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientInfoFacebook.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.machineId = "";
		if (message.machineId != null && message.hasOwnProperty("machineId")) object.machineId = message.machineId;
		return object;
	};

	/**
	 * Converts this ClientInfoFacebook to JSON.
	 * @function toJSON
	 * @memberof ClientInfoFacebook
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientInfoFacebook.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientInfoFacebook
	 * @function getTypeUrl
	 * @memberof ClientInfoFacebook
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientInfoFacebook.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientInfoFacebook";
	};

	return ClientInfoFacebook;
})();

$root.APWelcome = (function () {
	/**
	 * Properties of a APWelcome.
	 * @exports IAPWelcome
	 * @interface IAPWelcome
	 * @property {string} canonicalUsername APWelcome canonicalUsername
	 * @property {AccountType} accountTypeLoggedIn APWelcome accountTypeLoggedIn
	 * @property {AccountType} credentialsTypeLoggedIn APWelcome credentialsTypeLoggedIn
	 * @property {AuthenticationType} reusableAuthCredentialsType APWelcome reusableAuthCredentialsType
	 * @property {Uint8Array} reusableAuthCredentials APWelcome reusableAuthCredentials
	 * @property {Uint8Array|null} [lfsSecret] APWelcome lfsSecret
	 * @property {IAccountInfo|null} [accountInfo] APWelcome accountInfo
	 * @property {IAccountInfoFacebook|null} [fb] APWelcome fb
	 */

	/**
	 * Constructs a new APWelcome.
	 * @exports APWelcome
	 * @classdesc Represents a APWelcome.
	 * @implements IAPWelcome
	 * @constructor
	 * @param {IAPWelcome=} [properties] Properties to set
	 */
	function APWelcome(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * APWelcome canonicalUsername.
	 * @member {string} canonicalUsername
	 * @memberof APWelcome
	 * @instance
	 */
	APWelcome.prototype.canonicalUsername = "";

	/**
	 * APWelcome accountTypeLoggedIn.
	 * @member {AccountType} accountTypeLoggedIn
	 * @memberof APWelcome
	 * @instance
	 */
	APWelcome.prototype.accountTypeLoggedIn = 0;

	/**
	 * APWelcome credentialsTypeLoggedIn.
	 * @member {AccountType} credentialsTypeLoggedIn
	 * @memberof APWelcome
	 * @instance
	 */
	APWelcome.prototype.credentialsTypeLoggedIn = 0;

	/**
	 * APWelcome reusableAuthCredentialsType.
	 * @member {AuthenticationType} reusableAuthCredentialsType
	 * @memberof APWelcome
	 * @instance
	 */
	APWelcome.prototype.reusableAuthCredentialsType = 0;

	/**
	 * APWelcome reusableAuthCredentials.
	 * @member {Uint8Array} reusableAuthCredentials
	 * @memberof APWelcome
	 * @instance
	 */
	APWelcome.prototype.reusableAuthCredentials = $util.newBuffer([]);

	/**
	 * APWelcome lfsSecret.
	 * @member {Uint8Array} lfsSecret
	 * @memberof APWelcome
	 * @instance
	 */
	APWelcome.prototype.lfsSecret = $util.newBuffer([]);

	/**
	 * APWelcome accountInfo.
	 * @member {IAccountInfo|null|undefined} accountInfo
	 * @memberof APWelcome
	 * @instance
	 */
	APWelcome.prototype.accountInfo = null;

	/**
	 * APWelcome fb.
	 * @member {IAccountInfoFacebook|null|undefined} fb
	 * @memberof APWelcome
	 * @instance
	 */
	APWelcome.prototype.fb = null;

	/**
	 * Creates a new APWelcome instance using the specified properties.
	 * @function create
	 * @memberof APWelcome
	 * @static
	 * @param {IAPWelcome=} [properties] Properties to set
	 * @returns {APWelcome} APWelcome instance
	 */
	APWelcome.create = function create(properties) {
		return new APWelcome(properties);
	};

	/**
	 * Encodes the specified APWelcome message. Does not implicitly {@link APWelcome.verify|verify} messages.
	 * @function encode
	 * @memberof APWelcome
	 * @static
	 * @param {IAPWelcome} message APWelcome message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	APWelcome.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.canonicalUsername);
		writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.accountTypeLoggedIn);
		writer.uint32(/* id 25, wireType 0 =*/ 200).int32(message.credentialsTypeLoggedIn);
		writer.uint32(/* id 30, wireType 0 =*/ 240).int32(message.reusableAuthCredentialsType);
		writer.uint32(/* id 40, wireType 2 =*/ 322).bytes(message.reusableAuthCredentials);
		if (message.lfsSecret != null && Object.hasOwnProperty.call(message, "lfsSecret"))
			writer.uint32(/* id 50, wireType 2 =*/ 402).bytes(message.lfsSecret);
		if (message.accountInfo != null && Object.hasOwnProperty.call(message, "accountInfo"))
			$root.AccountInfo.encode(message.accountInfo, writer.uint32(/* id 60, wireType 2 =*/ 482).fork()).ldelim();
		if (message.fb != null && Object.hasOwnProperty.call(message, "fb"))
			$root.AccountInfoFacebook.encode(message.fb, writer.uint32(/* id 70, wireType 2 =*/ 562).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified APWelcome message, length delimited. Does not implicitly {@link APWelcome.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof APWelcome
	 * @static
	 * @param {IAPWelcome} message APWelcome message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	APWelcome.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a APWelcome message from the specified reader or buffer.
	 * @function decode
	 * @memberof APWelcome
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {APWelcome} APWelcome
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	APWelcome.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.APWelcome();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.canonicalUsername = reader.string();
					break;
				}
				case 20: {
					message.accountTypeLoggedIn = reader.int32();
					break;
				}
				case 25: {
					message.credentialsTypeLoggedIn = reader.int32();
					break;
				}
				case 30: {
					message.reusableAuthCredentialsType = reader.int32();
					break;
				}
				case 40: {
					message.reusableAuthCredentials = reader.bytes();
					break;
				}
				case 50: {
					message.lfsSecret = reader.bytes();
					break;
				}
				case 60: {
					message.accountInfo = $root.AccountInfo.decode(reader, reader.uint32());
					break;
				}
				case 70: {
					message.fb = $root.AccountInfoFacebook.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("canonicalUsername"))
			throw $util.ProtocolError("missing required 'canonicalUsername'", { instance: message });
		if (!message.hasOwnProperty("accountTypeLoggedIn"))
			throw $util.ProtocolError("missing required 'accountTypeLoggedIn'", { instance: message });
		if (!message.hasOwnProperty("credentialsTypeLoggedIn"))
			throw $util.ProtocolError("missing required 'credentialsTypeLoggedIn'", { instance: message });
		if (!message.hasOwnProperty("reusableAuthCredentialsType"))
			throw $util.ProtocolError("missing required 'reusableAuthCredentialsType'", { instance: message });
		if (!message.hasOwnProperty("reusableAuthCredentials"))
			throw $util.ProtocolError("missing required 'reusableAuthCredentials'", { instance: message });
		return message;
	};

	/**
	 * Decodes a APWelcome message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof APWelcome
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {APWelcome} APWelcome
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	APWelcome.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a APWelcome message.
	 * @function verify
	 * @memberof APWelcome
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	APWelcome.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!$util.isString(message.canonicalUsername)) return "canonicalUsername: string expected";
		switch (message.accountTypeLoggedIn) {
			default:
				return "accountTypeLoggedIn: enum value expected";
			case 0:
			case 1:
				break;
		}
		switch (message.credentialsTypeLoggedIn) {
			default:
				return "credentialsTypeLoggedIn: enum value expected";
			case 0:
			case 1:
				break;
		}
		switch (message.reusableAuthCredentialsType) {
			default:
				return "reusableAuthCredentialsType: enum value expected";
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
				break;
		}
		if (
			!(
				(message.reusableAuthCredentials && typeof message.reusableAuthCredentials.length === "number") ||
				$util.isString(message.reusableAuthCredentials)
			)
		)
			return "reusableAuthCredentials: buffer expected";
		if (message.lfsSecret != null && message.hasOwnProperty("lfsSecret"))
			if (!((message.lfsSecret && typeof message.lfsSecret.length === "number") || $util.isString(message.lfsSecret)))
				return "lfsSecret: buffer expected";
		if (message.accountInfo != null && message.hasOwnProperty("accountInfo")) {
			var error = $root.AccountInfo.verify(message.accountInfo);
			if (error) return "accountInfo." + error;
		}
		if (message.fb != null && message.hasOwnProperty("fb")) {
			var error = $root.AccountInfoFacebook.verify(message.fb);
			if (error) return "fb." + error;
		}
		return null;
	};

	/**
	 * Creates a APWelcome message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof APWelcome
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {APWelcome} APWelcome
	 */
	APWelcome.fromObject = function fromObject(object) {
		if (object instanceof $root.APWelcome) return object;
		var message = new $root.APWelcome();
		if (object.canonicalUsername != null) message.canonicalUsername = String(object.canonicalUsername);
		switch (object.accountTypeLoggedIn) {
			default:
				if (typeof object.accountTypeLoggedIn === "number") {
					message.accountTypeLoggedIn = object.accountTypeLoggedIn;
					break;
				}
				break;
			case "Spotify":
			case 0:
				message.accountTypeLoggedIn = 0;
				break;
			case "Facebook":
			case 1:
				message.accountTypeLoggedIn = 1;
				break;
		}
		switch (object.credentialsTypeLoggedIn) {
			default:
				if (typeof object.credentialsTypeLoggedIn === "number") {
					message.credentialsTypeLoggedIn = object.credentialsTypeLoggedIn;
					break;
				}
				break;
			case "Spotify":
			case 0:
				message.credentialsTypeLoggedIn = 0;
				break;
			case "Facebook":
			case 1:
				message.credentialsTypeLoggedIn = 1;
				break;
		}
		switch (object.reusableAuthCredentialsType) {
			default:
				if (typeof object.reusableAuthCredentialsType === "number") {
					message.reusableAuthCredentialsType = object.reusableAuthCredentialsType;
					break;
				}
				break;
			case "AUTHENTICATION_USER_PASS":
			case 0:
				message.reusableAuthCredentialsType = 0;
				break;
			case "AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS":
			case 1:
				message.reusableAuthCredentialsType = 1;
				break;
			case "AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS":
			case 2:
				message.reusableAuthCredentialsType = 2;
				break;
			case "AUTHENTICATION_SPOTIFY_TOKEN":
			case 3:
				message.reusableAuthCredentialsType = 3;
				break;
			case "AUTHENTICATION_FACEBOOK_TOKEN":
			case 4:
				message.reusableAuthCredentialsType = 4;
				break;
		}
		if (object.reusableAuthCredentials != null)
			if (typeof object.reusableAuthCredentials === "string")
				$util.base64.decode(
					object.reusableAuthCredentials,
					(message.reusableAuthCredentials = $util.newBuffer($util.base64.length(object.reusableAuthCredentials))),
					0,
				);
			else if (object.reusableAuthCredentials.length >= 0) message.reusableAuthCredentials = object.reusableAuthCredentials;
		if (object.lfsSecret != null)
			if (typeof object.lfsSecret === "string")
				$util.base64.decode(object.lfsSecret, (message.lfsSecret = $util.newBuffer($util.base64.length(object.lfsSecret))), 0);
			else if (object.lfsSecret.length >= 0) message.lfsSecret = object.lfsSecret;
		if (object.accountInfo != null) {
			if (typeof object.accountInfo !== "object") throw TypeError(".APWelcome.accountInfo: object expected");
			message.accountInfo = $root.AccountInfo.fromObject(object.accountInfo);
		}
		if (object.fb != null) {
			if (typeof object.fb !== "object") throw TypeError(".APWelcome.fb: object expected");
			message.fb = $root.AccountInfoFacebook.fromObject(object.fb);
		}
		return message;
	};

	/**
	 * Creates a plain object from a APWelcome message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof APWelcome
	 * @static
	 * @param {APWelcome} message APWelcome
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	APWelcome.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.canonicalUsername = "";
			object.accountTypeLoggedIn = options.enums === String ? "Spotify" : 0;
			object.credentialsTypeLoggedIn = options.enums === String ? "Spotify" : 0;
			object.reusableAuthCredentialsType = options.enums === String ? "AUTHENTICATION_USER_PASS" : 0;
			if (options.bytes === String) object.reusableAuthCredentials = "";
			else {
				object.reusableAuthCredentials = [];
				if (options.bytes !== Array) object.reusableAuthCredentials = $util.newBuffer(object.reusableAuthCredentials);
			}
			if (options.bytes === String) object.lfsSecret = "";
			else {
				object.lfsSecret = [];
				if (options.bytes !== Array) object.lfsSecret = $util.newBuffer(object.lfsSecret);
			}
			object.accountInfo = null;
			object.fb = null;
		}
		if (message.canonicalUsername != null && message.hasOwnProperty("canonicalUsername"))
			object.canonicalUsername = message.canonicalUsername;
		if (message.accountTypeLoggedIn != null && message.hasOwnProperty("accountTypeLoggedIn"))
			object.accountTypeLoggedIn =
				options.enums === String
					? $root.AccountType[message.accountTypeLoggedIn] === undefined
						? message.accountTypeLoggedIn
						: $root.AccountType[message.accountTypeLoggedIn]
					: message.accountTypeLoggedIn;
		if (message.credentialsTypeLoggedIn != null && message.hasOwnProperty("credentialsTypeLoggedIn"))
			object.credentialsTypeLoggedIn =
				options.enums === String
					? $root.AccountType[message.credentialsTypeLoggedIn] === undefined
						? message.credentialsTypeLoggedIn
						: $root.AccountType[message.credentialsTypeLoggedIn]
					: message.credentialsTypeLoggedIn;
		if (message.reusableAuthCredentialsType != null && message.hasOwnProperty("reusableAuthCredentialsType"))
			object.reusableAuthCredentialsType =
				options.enums === String
					? $root.AuthenticationType[message.reusableAuthCredentialsType] === undefined
						? message.reusableAuthCredentialsType
						: $root.AuthenticationType[message.reusableAuthCredentialsType]
					: message.reusableAuthCredentialsType;
		if (message.reusableAuthCredentials != null && message.hasOwnProperty("reusableAuthCredentials"))
			object.reusableAuthCredentials =
				options.bytes === String
					? $util.base64.encode(message.reusableAuthCredentials, 0, message.reusableAuthCredentials.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.reusableAuthCredentials)
					: message.reusableAuthCredentials;
		if (message.lfsSecret != null && message.hasOwnProperty("lfsSecret"))
			object.lfsSecret =
				options.bytes === String
					? $util.base64.encode(message.lfsSecret, 0, message.lfsSecret.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.lfsSecret)
					: message.lfsSecret;
		if (message.accountInfo != null && message.hasOwnProperty("accountInfo"))
			object.accountInfo = $root.AccountInfo.toObject(message.accountInfo, options);
		if (message.fb != null && message.hasOwnProperty("fb")) object.fb = $root.AccountInfoFacebook.toObject(message.fb, options);
		return object;
	};

	/**
	 * Converts this APWelcome to JSON.
	 * @function toJSON
	 * @memberof APWelcome
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	APWelcome.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for APWelcome
	 * @function getTypeUrl
	 * @memberof APWelcome
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	APWelcome.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/APWelcome";
	};

	return APWelcome;
})();

/**
 * AccountType enum.
 * @exports AccountType
 * @enum {number}
 * @property {number} Spotify=0 Spotify value
 * @property {number} Facebook=1 Facebook value
 */
$root.AccountType = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "Spotify")] = 0;
	values[(valuesById[1] = "Facebook")] = 1;
	return values;
})();

$root.AccountInfo = (function () {
	/**
	 * Properties of an AccountInfo.
	 * @exports IAccountInfo
	 * @interface IAccountInfo
	 * @property {IAccountInfoSpotify|null} [spotify] AccountInfo spotify
	 * @property {IAccountInfoFacebook|null} [facebook] AccountInfo facebook
	 */

	/**
	 * Constructs a new AccountInfo.
	 * @exports AccountInfo
	 * @classdesc Represents an AccountInfo.
	 * @implements IAccountInfo
	 * @constructor
	 * @param {IAccountInfo=} [properties] Properties to set
	 */
	function AccountInfo(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * AccountInfo spotify.
	 * @member {IAccountInfoSpotify|null|undefined} spotify
	 * @memberof AccountInfo
	 * @instance
	 */
	AccountInfo.prototype.spotify = null;

	/**
	 * AccountInfo facebook.
	 * @member {IAccountInfoFacebook|null|undefined} facebook
	 * @memberof AccountInfo
	 * @instance
	 */
	AccountInfo.prototype.facebook = null;

	/**
	 * Creates a new AccountInfo instance using the specified properties.
	 * @function create
	 * @memberof AccountInfo
	 * @static
	 * @param {IAccountInfo=} [properties] Properties to set
	 * @returns {AccountInfo} AccountInfo instance
	 */
	AccountInfo.create = function create(properties) {
		return new AccountInfo(properties);
	};

	/**
	 * Encodes the specified AccountInfo message. Does not implicitly {@link AccountInfo.verify|verify} messages.
	 * @function encode
	 * @memberof AccountInfo
	 * @static
	 * @param {IAccountInfo} message AccountInfo message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AccountInfo.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.spotify != null && Object.hasOwnProperty.call(message, "spotify"))
			$root.AccountInfoSpotify.encode(message.spotify, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
		if (message.facebook != null && Object.hasOwnProperty.call(message, "facebook"))
			$root.AccountInfoFacebook.encode(message.facebook, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified AccountInfo message, length delimited. Does not implicitly {@link AccountInfo.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof AccountInfo
	 * @static
	 * @param {IAccountInfo} message AccountInfo message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AccountInfo.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an AccountInfo message from the specified reader or buffer.
	 * @function decode
	 * @memberof AccountInfo
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {AccountInfo} AccountInfo
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AccountInfo.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.AccountInfo();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.spotify = $root.AccountInfoSpotify.decode(reader, reader.uint32());
					break;
				}
				case 2: {
					message.facebook = $root.AccountInfoFacebook.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an AccountInfo message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof AccountInfo
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {AccountInfo} AccountInfo
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AccountInfo.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an AccountInfo message.
	 * @function verify
	 * @memberof AccountInfo
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	AccountInfo.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.spotify != null && message.hasOwnProperty("spotify")) {
			var error = $root.AccountInfoSpotify.verify(message.spotify);
			if (error) return "spotify." + error;
		}
		if (message.facebook != null && message.hasOwnProperty("facebook")) {
			var error = $root.AccountInfoFacebook.verify(message.facebook);
			if (error) return "facebook." + error;
		}
		return null;
	};

	/**
	 * Creates an AccountInfo message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof AccountInfo
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {AccountInfo} AccountInfo
	 */
	AccountInfo.fromObject = function fromObject(object) {
		if (object instanceof $root.AccountInfo) return object;
		var message = new $root.AccountInfo();
		if (object.spotify != null) {
			if (typeof object.spotify !== "object") throw TypeError(".AccountInfo.spotify: object expected");
			message.spotify = $root.AccountInfoSpotify.fromObject(object.spotify);
		}
		if (object.facebook != null) {
			if (typeof object.facebook !== "object") throw TypeError(".AccountInfo.facebook: object expected");
			message.facebook = $root.AccountInfoFacebook.fromObject(object.facebook);
		}
		return message;
	};

	/**
	 * Creates a plain object from an AccountInfo message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof AccountInfo
	 * @static
	 * @param {AccountInfo} message AccountInfo
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	AccountInfo.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.spotify = null;
			object.facebook = null;
		}
		if (message.spotify != null && message.hasOwnProperty("spotify"))
			object.spotify = $root.AccountInfoSpotify.toObject(message.spotify, options);
		if (message.facebook != null && message.hasOwnProperty("facebook"))
			object.facebook = $root.AccountInfoFacebook.toObject(message.facebook, options);
		return object;
	};

	/**
	 * Converts this AccountInfo to JSON.
	 * @function toJSON
	 * @memberof AccountInfo
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	AccountInfo.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for AccountInfo
	 * @function getTypeUrl
	 * @memberof AccountInfo
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	AccountInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/AccountInfo";
	};

	return AccountInfo;
})();

$root.AccountInfoSpotify = (function () {
	/**
	 * Properties of an AccountInfoSpotify.
	 * @exports IAccountInfoSpotify
	 * @interface IAccountInfoSpotify
	 */

	/**
	 * Constructs a new AccountInfoSpotify.
	 * @exports AccountInfoSpotify
	 * @classdesc Represents an AccountInfoSpotify.
	 * @implements IAccountInfoSpotify
	 * @constructor
	 * @param {IAccountInfoSpotify=} [properties] Properties to set
	 */
	function AccountInfoSpotify(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Creates a new AccountInfoSpotify instance using the specified properties.
	 * @function create
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {IAccountInfoSpotify=} [properties] Properties to set
	 * @returns {AccountInfoSpotify} AccountInfoSpotify instance
	 */
	AccountInfoSpotify.create = function create(properties) {
		return new AccountInfoSpotify(properties);
	};

	/**
	 * Encodes the specified AccountInfoSpotify message. Does not implicitly {@link AccountInfoSpotify.verify|verify} messages.
	 * @function encode
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {IAccountInfoSpotify} message AccountInfoSpotify message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AccountInfoSpotify.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		return writer;
	};

	/**
	 * Encodes the specified AccountInfoSpotify message, length delimited. Does not implicitly {@link AccountInfoSpotify.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {IAccountInfoSpotify} message AccountInfoSpotify message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AccountInfoSpotify.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an AccountInfoSpotify message from the specified reader or buffer.
	 * @function decode
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {AccountInfoSpotify} AccountInfoSpotify
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AccountInfoSpotify.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.AccountInfoSpotify();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an AccountInfoSpotify message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {AccountInfoSpotify} AccountInfoSpotify
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AccountInfoSpotify.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an AccountInfoSpotify message.
	 * @function verify
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	AccountInfoSpotify.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		return null;
	};

	/**
	 * Creates an AccountInfoSpotify message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {AccountInfoSpotify} AccountInfoSpotify
	 */
	AccountInfoSpotify.fromObject = function fromObject(object) {
		if (object instanceof $root.AccountInfoSpotify) return object;
		return new $root.AccountInfoSpotify();
	};

	/**
	 * Creates a plain object from an AccountInfoSpotify message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {AccountInfoSpotify} message AccountInfoSpotify
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	AccountInfoSpotify.toObject = function toObject() {
		return {};
	};

	/**
	 * Converts this AccountInfoSpotify to JSON.
	 * @function toJSON
	 * @memberof AccountInfoSpotify
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	AccountInfoSpotify.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for AccountInfoSpotify
	 * @function getTypeUrl
	 * @memberof AccountInfoSpotify
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	AccountInfoSpotify.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/AccountInfoSpotify";
	};

	return AccountInfoSpotify;
})();

$root.AccountInfoFacebook = (function () {
	/**
	 * Properties of an AccountInfoFacebook.
	 * @exports IAccountInfoFacebook
	 * @interface IAccountInfoFacebook
	 * @property {string|null} [accessToken] AccountInfoFacebook accessToken
	 * @property {string|null} [machineId] AccountInfoFacebook machineId
	 */

	/**
	 * Constructs a new AccountInfoFacebook.
	 * @exports AccountInfoFacebook
	 * @classdesc Represents an AccountInfoFacebook.
	 * @implements IAccountInfoFacebook
	 * @constructor
	 * @param {IAccountInfoFacebook=} [properties] Properties to set
	 */
	function AccountInfoFacebook(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * AccountInfoFacebook accessToken.
	 * @member {string} accessToken
	 * @memberof AccountInfoFacebook
	 * @instance
	 */
	AccountInfoFacebook.prototype.accessToken = "";

	/**
	 * AccountInfoFacebook machineId.
	 * @member {string} machineId
	 * @memberof AccountInfoFacebook
	 * @instance
	 */
	AccountInfoFacebook.prototype.machineId = "";

	/**
	 * Creates a new AccountInfoFacebook instance using the specified properties.
	 * @function create
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {IAccountInfoFacebook=} [properties] Properties to set
	 * @returns {AccountInfoFacebook} AccountInfoFacebook instance
	 */
	AccountInfoFacebook.create = function create(properties) {
		return new AccountInfoFacebook(properties);
	};

	/**
	 * Encodes the specified AccountInfoFacebook message. Does not implicitly {@link AccountInfoFacebook.verify|verify} messages.
	 * @function encode
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {IAccountInfoFacebook} message AccountInfoFacebook message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AccountInfoFacebook.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.accessToken != null && Object.hasOwnProperty.call(message, "accessToken"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.accessToken);
		if (message.machineId != null && Object.hasOwnProperty.call(message, "machineId"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.machineId);
		return writer;
	};

	/**
	 * Encodes the specified AccountInfoFacebook message, length delimited. Does not implicitly {@link AccountInfoFacebook.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {IAccountInfoFacebook} message AccountInfoFacebook message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AccountInfoFacebook.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an AccountInfoFacebook message from the specified reader or buffer.
	 * @function decode
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {AccountInfoFacebook} AccountInfoFacebook
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AccountInfoFacebook.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.AccountInfoFacebook();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.accessToken = reader.string();
					break;
				}
				case 2: {
					message.machineId = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an AccountInfoFacebook message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {AccountInfoFacebook} AccountInfoFacebook
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AccountInfoFacebook.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an AccountInfoFacebook message.
	 * @function verify
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	AccountInfoFacebook.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.accessToken != null && message.hasOwnProperty("accessToken"))
			if (!$util.isString(message.accessToken)) return "accessToken: string expected";
		if (message.machineId != null && message.hasOwnProperty("machineId"))
			if (!$util.isString(message.machineId)) return "machineId: string expected";
		return null;
	};

	/**
	 * Creates an AccountInfoFacebook message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {AccountInfoFacebook} AccountInfoFacebook
	 */
	AccountInfoFacebook.fromObject = function fromObject(object) {
		if (object instanceof $root.AccountInfoFacebook) return object;
		var message = new $root.AccountInfoFacebook();
		if (object.accessToken != null) message.accessToken = String(object.accessToken);
		if (object.machineId != null) message.machineId = String(object.machineId);
		return message;
	};

	/**
	 * Creates a plain object from an AccountInfoFacebook message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {AccountInfoFacebook} message AccountInfoFacebook
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	AccountInfoFacebook.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.accessToken = "";
			object.machineId = "";
		}
		if (message.accessToken != null && message.hasOwnProperty("accessToken")) object.accessToken = message.accessToken;
		if (message.machineId != null && message.hasOwnProperty("machineId")) object.machineId = message.machineId;
		return object;
	};

	/**
	 * Converts this AccountInfoFacebook to JSON.
	 * @function toJSON
	 * @memberof AccountInfoFacebook
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	AccountInfoFacebook.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for AccountInfoFacebook
	 * @function getTypeUrl
	 * @memberof AccountInfoFacebook
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	AccountInfoFacebook.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/AccountInfoFacebook";
	};

	return AccountInfoFacebook;
})();

$root.ClientTokenRequest = (function () {
	/**
	 * Properties of a ClientTokenRequest.
	 * @exports IClientTokenRequest
	 * @interface IClientTokenRequest
	 * @property {ClientTokenRequestType|null} [requestType] ClientTokenRequest requestType
	 * @property {IClientDataRequest|null} [clientData] ClientTokenRequest clientData
	 * @property {IChallengeAnswersRequest|null} [challengeAnswers] ClientTokenRequest challengeAnswers
	 */

	/**
	 * Constructs a new ClientTokenRequest.
	 * @exports ClientTokenRequest
	 * @classdesc Represents a ClientTokenRequest.
	 * @implements IClientTokenRequest
	 * @constructor
	 * @param {IClientTokenRequest=} [properties] Properties to set
	 */
	function ClientTokenRequest(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientTokenRequest requestType.
	 * @member {ClientTokenRequestType} requestType
	 * @memberof ClientTokenRequest
	 * @instance
	 */
	ClientTokenRequest.prototype.requestType = 0;

	/**
	 * ClientTokenRequest clientData.
	 * @member {IClientDataRequest|null|undefined} clientData
	 * @memberof ClientTokenRequest
	 * @instance
	 */
	ClientTokenRequest.prototype.clientData = null;

	/**
	 * ClientTokenRequest challengeAnswers.
	 * @member {IChallengeAnswersRequest|null|undefined} challengeAnswers
	 * @memberof ClientTokenRequest
	 * @instance
	 */
	ClientTokenRequest.prototype.challengeAnswers = null;

	// OneOf field names bound to virtual getters and setters
	var $oneOfFields;

	/**
	 * ClientTokenRequest request.
	 * @member {"clientData"|"challengeAnswers"|undefined} request
	 * @memberof ClientTokenRequest
	 * @instance
	 */
	Object.defineProperty(ClientTokenRequest.prototype, "request", {
		get: $util.oneOfGetter(($oneOfFields = ["clientData", "challengeAnswers"])),
		set: $util.oneOfSetter($oneOfFields),
	});

	/**
	 * Creates a new ClientTokenRequest instance using the specified properties.
	 * @function create
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {IClientTokenRequest=} [properties] Properties to set
	 * @returns {ClientTokenRequest} ClientTokenRequest instance
	 */
	ClientTokenRequest.create = function create(properties) {
		return new ClientTokenRequest(properties);
	};

	/**
	 * Encodes the specified ClientTokenRequest message. Does not implicitly {@link ClientTokenRequest.verify|verify} messages.
	 * @function encode
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {IClientTokenRequest} message ClientTokenRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientTokenRequest.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.requestType != null && Object.hasOwnProperty.call(message, "requestType"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.requestType);
		if (message.clientData != null && Object.hasOwnProperty.call(message, "clientData"))
			$root.ClientDataRequest.encode(message.clientData, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		if (message.challengeAnswers != null && Object.hasOwnProperty.call(message, "challengeAnswers"))
			$root.ChallengeAnswersRequest.encode(message.challengeAnswers, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ClientTokenRequest message, length delimited. Does not implicitly {@link ClientTokenRequest.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {IClientTokenRequest} message ClientTokenRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientTokenRequest message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientTokenRequest} ClientTokenRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientTokenRequest.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientTokenRequest();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.requestType = reader.int32();
					break;
				}
				case 2: {
					message.clientData = $root.ClientDataRequest.decode(reader, reader.uint32());
					break;
				}
				case 3: {
					message.challengeAnswers = $root.ChallengeAnswersRequest.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ClientTokenRequest message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientTokenRequest} ClientTokenRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientTokenRequest.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientTokenRequest message.
	 * @function verify
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientTokenRequest.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		var properties = {};
		if (message.requestType != null && message.hasOwnProperty("requestType"))
			switch (message.requestType) {
				default:
					return "requestType: enum value expected";
				case 0:
				case 1:
				case 2:
					break;
			}
		if (message.clientData != null && message.hasOwnProperty("clientData")) {
			properties.request = 1;
			{
				var error = $root.ClientDataRequest.verify(message.clientData);
				if (error) return "clientData." + error;
			}
		}
		if (message.challengeAnswers != null && message.hasOwnProperty("challengeAnswers")) {
			if (properties.request === 1) return "request: multiple values";
			properties.request = 1;
			{
				var error = $root.ChallengeAnswersRequest.verify(message.challengeAnswers);
				if (error) return "challengeAnswers." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a ClientTokenRequest message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientTokenRequest} ClientTokenRequest
	 */
	ClientTokenRequest.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientTokenRequest) return object;
		var message = new $root.ClientTokenRequest();
		switch (object.requestType) {
			default:
				if (typeof object.requestType === "number") {
					message.requestType = object.requestType;
					break;
				}
				break;
			case "REQUEST_UNKNOWN":
			case 0:
				message.requestType = 0;
				break;
			case "REQUEST_CLIENT_DATA_REQUEST":
			case 1:
				message.requestType = 1;
				break;
			case "REQUEST_CHALLENGE_ANSWERS_REQUEST":
			case 2:
				message.requestType = 2;
				break;
		}
		if (object.clientData != null) {
			if (typeof object.clientData !== "object") throw TypeError(".ClientTokenRequest.clientData: object expected");
			message.clientData = $root.ClientDataRequest.fromObject(object.clientData);
		}
		if (object.challengeAnswers != null) {
			if (typeof object.challengeAnswers !== "object") throw TypeError(".ClientTokenRequest.challengeAnswers: object expected");
			message.challengeAnswers = $root.ChallengeAnswersRequest.fromObject(object.challengeAnswers);
		}
		return message;
	};

	/**
	 * Creates a plain object from a ClientTokenRequest message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {ClientTokenRequest} message ClientTokenRequest
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientTokenRequest.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.requestType = options.enums === String ? "REQUEST_UNKNOWN" : 0;
		if (message.requestType != null && message.hasOwnProperty("requestType"))
			object.requestType =
				options.enums === String
					? $root.ClientTokenRequestType[message.requestType] === undefined
						? message.requestType
						: $root.ClientTokenRequestType[message.requestType]
					: message.requestType;
		if (message.clientData != null && message.hasOwnProperty("clientData")) {
			object.clientData = $root.ClientDataRequest.toObject(message.clientData, options);
			if (options.oneofs) object.request = "clientData";
		}
		if (message.challengeAnswers != null && message.hasOwnProperty("challengeAnswers")) {
			object.challengeAnswers = $root.ChallengeAnswersRequest.toObject(message.challengeAnswers, options);
			if (options.oneofs) object.request = "challengeAnswers";
		}
		return object;
	};

	/**
	 * Converts this ClientTokenRequest to JSON.
	 * @function toJSON
	 * @memberof ClientTokenRequest
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientTokenRequest.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientTokenRequest
	 * @function getTypeUrl
	 * @memberof ClientTokenRequest
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientTokenRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientTokenRequest";
	};

	return ClientTokenRequest;
})();

$root.ClientDataRequest = (function () {
	/**
	 * Properties of a ClientDataRequest.
	 * @exports IClientDataRequest
	 * @interface IClientDataRequest
	 * @property {string|null} [clientVersion] ClientDataRequest clientVersion
	 * @property {string|null} [clientId] ClientDataRequest clientId
	 * @property {spotify.clienttoken.data.v0.IConnectivitySdkData|null} [connectivitySdkData] ClientDataRequest connectivitySdkData
	 */

	/**
	 * Constructs a new ClientDataRequest.
	 * @exports ClientDataRequest
	 * @classdesc Represents a ClientDataRequest.
	 * @implements IClientDataRequest
	 * @constructor
	 * @param {IClientDataRequest=} [properties] Properties to set
	 */
	function ClientDataRequest(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientDataRequest clientVersion.
	 * @member {string} clientVersion
	 * @memberof ClientDataRequest
	 * @instance
	 */
	ClientDataRequest.prototype.clientVersion = "";

	/**
	 * ClientDataRequest clientId.
	 * @member {string} clientId
	 * @memberof ClientDataRequest
	 * @instance
	 */
	ClientDataRequest.prototype.clientId = "";

	/**
	 * ClientDataRequest connectivitySdkData.
	 * @member {spotify.clienttoken.data.v0.IConnectivitySdkData|null|undefined} connectivitySdkData
	 * @memberof ClientDataRequest
	 * @instance
	 */
	ClientDataRequest.prototype.connectivitySdkData = null;

	// OneOf field names bound to virtual getters and setters
	var $oneOfFields;

	/**
	 * ClientDataRequest data.
	 * @member {"connectivitySdkData"|undefined} data
	 * @memberof ClientDataRequest
	 * @instance
	 */
	Object.defineProperty(ClientDataRequest.prototype, "data", {
		get: $util.oneOfGetter(($oneOfFields = ["connectivitySdkData"])),
		set: $util.oneOfSetter($oneOfFields),
	});

	/**
	 * Creates a new ClientDataRequest instance using the specified properties.
	 * @function create
	 * @memberof ClientDataRequest
	 * @static
	 * @param {IClientDataRequest=} [properties] Properties to set
	 * @returns {ClientDataRequest} ClientDataRequest instance
	 */
	ClientDataRequest.create = function create(properties) {
		return new ClientDataRequest(properties);
	};

	/**
	 * Encodes the specified ClientDataRequest message. Does not implicitly {@link ClientDataRequest.verify|verify} messages.
	 * @function encode
	 * @memberof ClientDataRequest
	 * @static
	 * @param {IClientDataRequest} message ClientDataRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientDataRequest.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.clientVersion);
		if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.clientId);
		if (message.connectivitySdkData != null && Object.hasOwnProperty.call(message, "connectivitySdkData"))
			$root.spotify.clienttoken.data.v0.ConnectivitySdkData.encode(
				message.connectivitySdkData,
				writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
			).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ClientDataRequest message, length delimited. Does not implicitly {@link ClientDataRequest.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientDataRequest
	 * @static
	 * @param {IClientDataRequest} message ClientDataRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientDataRequest message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientDataRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientDataRequest} ClientDataRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientDataRequest.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientDataRequest();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.clientVersion = reader.string();
					break;
				}
				case 2: {
					message.clientId = reader.string();
					break;
				}
				case 3: {
					message.connectivitySdkData = $root.spotify.clienttoken.data.v0.ConnectivitySdkData.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ClientDataRequest message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientDataRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientDataRequest} ClientDataRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientDataRequest.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientDataRequest message.
	 * @function verify
	 * @memberof ClientDataRequest
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientDataRequest.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		var properties = {};
		if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
			if (!$util.isString(message.clientVersion)) return "clientVersion: string expected";
		if (message.clientId != null && message.hasOwnProperty("clientId"))
			if (!$util.isString(message.clientId)) return "clientId: string expected";
		if (message.connectivitySdkData != null && message.hasOwnProperty("connectivitySdkData")) {
			properties.data = 1;
			{
				var error = $root.spotify.clienttoken.data.v0.ConnectivitySdkData.verify(message.connectivitySdkData);
				if (error) return "connectivitySdkData." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a ClientDataRequest message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientDataRequest
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientDataRequest} ClientDataRequest
	 */
	ClientDataRequest.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientDataRequest) return object;
		var message = new $root.ClientDataRequest();
		if (object.clientVersion != null) message.clientVersion = String(object.clientVersion);
		if (object.clientId != null) message.clientId = String(object.clientId);
		if (object.connectivitySdkData != null) {
			if (typeof object.connectivitySdkData !== "object") throw TypeError(".ClientDataRequest.connectivitySdkData: object expected");
			message.connectivitySdkData = $root.spotify.clienttoken.data.v0.ConnectivitySdkData.fromObject(object.connectivitySdkData);
		}
		return message;
	};

	/**
	 * Creates a plain object from a ClientDataRequest message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientDataRequest
	 * @static
	 * @param {ClientDataRequest} message ClientDataRequest
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientDataRequest.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.clientVersion = "";
			object.clientId = "";
		}
		if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) object.clientVersion = message.clientVersion;
		if (message.clientId != null && message.hasOwnProperty("clientId")) object.clientId = message.clientId;
		if (message.connectivitySdkData != null && message.hasOwnProperty("connectivitySdkData")) {
			object.connectivitySdkData = $root.spotify.clienttoken.data.v0.ConnectivitySdkData.toObject(
				message.connectivitySdkData,
				options,
			);
			if (options.oneofs) object.data = "connectivitySdkData";
		}
		return object;
	};

	/**
	 * Converts this ClientDataRequest to JSON.
	 * @function toJSON
	 * @memberof ClientDataRequest
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientDataRequest.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientDataRequest
	 * @function getTypeUrl
	 * @memberof ClientDataRequest
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientDataRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientDataRequest";
	};

	return ClientDataRequest;
})();

$root.ChallengeAnswersRequest = (function () {
	/**
	 * Properties of a ChallengeAnswersRequest.
	 * @exports IChallengeAnswersRequest
	 * @interface IChallengeAnswersRequest
	 * @property {string|null} [state] ChallengeAnswersRequest state
	 * @property {Array.<IChallengeAnswer>|null} [answers] ChallengeAnswersRequest answers
	 */

	/**
	 * Constructs a new ChallengeAnswersRequest.
	 * @exports ChallengeAnswersRequest
	 * @classdesc Represents a ChallengeAnswersRequest.
	 * @implements IChallengeAnswersRequest
	 * @constructor
	 * @param {IChallengeAnswersRequest=} [properties] Properties to set
	 */
	function ChallengeAnswersRequest(properties) {
		this.answers = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ChallengeAnswersRequest state.
	 * @member {string} state
	 * @memberof ChallengeAnswersRequest
	 * @instance
	 */
	ChallengeAnswersRequest.prototype.state = "";

	/**
	 * ChallengeAnswersRequest answers.
	 * @member {Array.<IChallengeAnswer>} answers
	 * @memberof ChallengeAnswersRequest
	 * @instance
	 */
	ChallengeAnswersRequest.prototype.answers = $util.emptyArray;

	/**
	 * Creates a new ChallengeAnswersRequest instance using the specified properties.
	 * @function create
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {IChallengeAnswersRequest=} [properties] Properties to set
	 * @returns {ChallengeAnswersRequest} ChallengeAnswersRequest instance
	 */
	ChallengeAnswersRequest.create = function create(properties) {
		return new ChallengeAnswersRequest(properties);
	};

	/**
	 * Encodes the specified ChallengeAnswersRequest message. Does not implicitly {@link ChallengeAnswersRequest.verify|verify} messages.
	 * @function encode
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {IChallengeAnswersRequest} message ChallengeAnswersRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ChallengeAnswersRequest.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.state != null && Object.hasOwnProperty.call(message, "state"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.state);
		if (message.answers != null && message.answers.length)
			for (var i = 0; i < message.answers.length; ++i)
				$root.ChallengeAnswer.encode(message.answers[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ChallengeAnswersRequest message, length delimited. Does not implicitly {@link ChallengeAnswersRequest.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {IChallengeAnswersRequest} message ChallengeAnswersRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ChallengeAnswersRequest.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ChallengeAnswersRequest message from the specified reader or buffer.
	 * @function decode
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ChallengeAnswersRequest} ChallengeAnswersRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ChallengeAnswersRequest.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ChallengeAnswersRequest();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.state = reader.string();
					break;
				}
				case 2: {
					if (!(message.answers && message.answers.length)) message.answers = [];
					message.answers.push($root.ChallengeAnswer.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ChallengeAnswersRequest message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ChallengeAnswersRequest} ChallengeAnswersRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ChallengeAnswersRequest.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ChallengeAnswersRequest message.
	 * @function verify
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ChallengeAnswersRequest.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.state != null && message.hasOwnProperty("state")) if (!$util.isString(message.state)) return "state: string expected";
		if (message.answers != null && message.hasOwnProperty("answers")) {
			if (!Array.isArray(message.answers)) return "answers: array expected";
			for (var i = 0; i < message.answers.length; ++i) {
				var error = $root.ChallengeAnswer.verify(message.answers[i]);
				if (error) return "answers." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a ChallengeAnswersRequest message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ChallengeAnswersRequest} ChallengeAnswersRequest
	 */
	ChallengeAnswersRequest.fromObject = function fromObject(object) {
		if (object instanceof $root.ChallengeAnswersRequest) return object;
		var message = new $root.ChallengeAnswersRequest();
		if (object.state != null) message.state = String(object.state);
		if (object.answers) {
			if (!Array.isArray(object.answers)) throw TypeError(".ChallengeAnswersRequest.answers: array expected");
			message.answers = [];
			for (var i = 0; i < object.answers.length; ++i) {
				if (typeof object.answers[i] !== "object") throw TypeError(".ChallengeAnswersRequest.answers: object expected");
				message.answers[i] = $root.ChallengeAnswer.fromObject(object.answers[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a ChallengeAnswersRequest message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {ChallengeAnswersRequest} message ChallengeAnswersRequest
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ChallengeAnswersRequest.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.answers = [];
		if (options.defaults) object.state = "";
		if (message.state != null && message.hasOwnProperty("state")) object.state = message.state;
		if (message.answers && message.answers.length) {
			object.answers = [];
			for (var j = 0; j < message.answers.length; ++j)
				object.answers[j] = $root.ChallengeAnswer.toObject(message.answers[j], options);
		}
		return object;
	};

	/**
	 * Converts this ChallengeAnswersRequest to JSON.
	 * @function toJSON
	 * @memberof ChallengeAnswersRequest
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ChallengeAnswersRequest.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ChallengeAnswersRequest
	 * @function getTypeUrl
	 * @memberof ChallengeAnswersRequest
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ChallengeAnswersRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ChallengeAnswersRequest";
	};

	return ChallengeAnswersRequest;
})();

$root.ClientTokenResponse = (function () {
	/**
	 * Properties of a ClientTokenResponse.
	 * @exports IClientTokenResponse
	 * @interface IClientTokenResponse
	 * @property {ClientTokenResponseType|null} [responseType] ClientTokenResponse responseType
	 * @property {IGrantedTokenResponse|null} [grantedToken] ClientTokenResponse grantedToken
	 * @property {IChallengesResponse|null} [challenges] ClientTokenResponse challenges
	 */

	/**
	 * Constructs a new ClientTokenResponse.
	 * @exports ClientTokenResponse
	 * @classdesc Represents a ClientTokenResponse.
	 * @implements IClientTokenResponse
	 * @constructor
	 * @param {IClientTokenResponse=} [properties] Properties to set
	 */
	function ClientTokenResponse(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientTokenResponse responseType.
	 * @member {ClientTokenResponseType} responseType
	 * @memberof ClientTokenResponse
	 * @instance
	 */
	ClientTokenResponse.prototype.responseType = 0;

	/**
	 * ClientTokenResponse grantedToken.
	 * @member {IGrantedTokenResponse|null|undefined} grantedToken
	 * @memberof ClientTokenResponse
	 * @instance
	 */
	ClientTokenResponse.prototype.grantedToken = null;

	/**
	 * ClientTokenResponse challenges.
	 * @member {IChallengesResponse|null|undefined} challenges
	 * @memberof ClientTokenResponse
	 * @instance
	 */
	ClientTokenResponse.prototype.challenges = null;

	// OneOf field names bound to virtual getters and setters
	var $oneOfFields;

	/**
	 * ClientTokenResponse response.
	 * @member {"grantedToken"|"challenges"|undefined} response
	 * @memberof ClientTokenResponse
	 * @instance
	 */
	Object.defineProperty(ClientTokenResponse.prototype, "response", {
		get: $util.oneOfGetter(($oneOfFields = ["grantedToken", "challenges"])),
		set: $util.oneOfSetter($oneOfFields),
	});

	/**
	 * Creates a new ClientTokenResponse instance using the specified properties.
	 * @function create
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {IClientTokenResponse=} [properties] Properties to set
	 * @returns {ClientTokenResponse} ClientTokenResponse instance
	 */
	ClientTokenResponse.create = function create(properties) {
		return new ClientTokenResponse(properties);
	};

	/**
	 * Encodes the specified ClientTokenResponse message. Does not implicitly {@link ClientTokenResponse.verify|verify} messages.
	 * @function encode
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {IClientTokenResponse} message ClientTokenResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientTokenResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.responseType != null && Object.hasOwnProperty.call(message, "responseType"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.responseType);
		if (message.grantedToken != null && Object.hasOwnProperty.call(message, "grantedToken"))
			$root.GrantedTokenResponse.encode(message.grantedToken, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		if (message.challenges != null && Object.hasOwnProperty.call(message, "challenges"))
			$root.ChallengesResponse.encode(message.challenges, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ClientTokenResponse message, length delimited. Does not implicitly {@link ClientTokenResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {IClientTokenResponse} message ClientTokenResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientTokenResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientTokenResponse} ClientTokenResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientTokenResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientTokenResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.responseType = reader.int32();
					break;
				}
				case 2: {
					message.grantedToken = $root.GrantedTokenResponse.decode(reader, reader.uint32());
					break;
				}
				case 3: {
					message.challenges = $root.ChallengesResponse.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ClientTokenResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientTokenResponse} ClientTokenResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientTokenResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientTokenResponse message.
	 * @function verify
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientTokenResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		var properties = {};
		if (message.responseType != null && message.hasOwnProperty("responseType"))
			switch (message.responseType) {
				default:
					return "responseType: enum value expected";
				case 0:
				case 1:
				case 2:
					break;
			}
		if (message.grantedToken != null && message.hasOwnProperty("grantedToken")) {
			properties.response = 1;
			{
				var error = $root.GrantedTokenResponse.verify(message.grantedToken);
				if (error) return "grantedToken." + error;
			}
		}
		if (message.challenges != null && message.hasOwnProperty("challenges")) {
			if (properties.response === 1) return "response: multiple values";
			properties.response = 1;
			{
				var error = $root.ChallengesResponse.verify(message.challenges);
				if (error) return "challenges." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a ClientTokenResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientTokenResponse} ClientTokenResponse
	 */
	ClientTokenResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientTokenResponse) return object;
		var message = new $root.ClientTokenResponse();
		switch (object.responseType) {
			default:
				if (typeof object.responseType === "number") {
					message.responseType = object.responseType;
					break;
				}
				break;
			case "RESPONSE_UNKNOWN":
			case 0:
				message.responseType = 0;
				break;
			case "RESPONSE_GRANTED_TOKEN_RESPONSE":
			case 1:
				message.responseType = 1;
				break;
			case "RESPONSE_CHALLENGES_RESPONSE":
			case 2:
				message.responseType = 2;
				break;
		}
		if (object.grantedToken != null) {
			if (typeof object.grantedToken !== "object") throw TypeError(".ClientTokenResponse.grantedToken: object expected");
			message.grantedToken = $root.GrantedTokenResponse.fromObject(object.grantedToken);
		}
		if (object.challenges != null) {
			if (typeof object.challenges !== "object") throw TypeError(".ClientTokenResponse.challenges: object expected");
			message.challenges = $root.ChallengesResponse.fromObject(object.challenges);
		}
		return message;
	};

	/**
	 * Creates a plain object from a ClientTokenResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {ClientTokenResponse} message ClientTokenResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientTokenResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.responseType = options.enums === String ? "RESPONSE_UNKNOWN" : 0;
		if (message.responseType != null && message.hasOwnProperty("responseType"))
			object.responseType =
				options.enums === String
					? $root.ClientTokenResponseType[message.responseType] === undefined
						? message.responseType
						: $root.ClientTokenResponseType[message.responseType]
					: message.responseType;
		if (message.grantedToken != null && message.hasOwnProperty("grantedToken")) {
			object.grantedToken = $root.GrantedTokenResponse.toObject(message.grantedToken, options);
			if (options.oneofs) object.response = "grantedToken";
		}
		if (message.challenges != null && message.hasOwnProperty("challenges")) {
			object.challenges = $root.ChallengesResponse.toObject(message.challenges, options);
			if (options.oneofs) object.response = "challenges";
		}
		return object;
	};

	/**
	 * Converts this ClientTokenResponse to JSON.
	 * @function toJSON
	 * @memberof ClientTokenResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientTokenResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientTokenResponse
	 * @function getTypeUrl
	 * @memberof ClientTokenResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientTokenResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientTokenResponse";
	};

	return ClientTokenResponse;
})();

$root.TokenDomain = (function () {
	/**
	 * Properties of a TokenDomain.
	 * @exports ITokenDomain
	 * @interface ITokenDomain
	 * @property {string|null} [domain] TokenDomain domain
	 */

	/**
	 * Constructs a new TokenDomain.
	 * @exports TokenDomain
	 * @classdesc Represents a TokenDomain.
	 * @implements ITokenDomain
	 * @constructor
	 * @param {ITokenDomain=} [properties] Properties to set
	 */
	function TokenDomain(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * TokenDomain domain.
	 * @member {string} domain
	 * @memberof TokenDomain
	 * @instance
	 */
	TokenDomain.prototype.domain = "";

	/**
	 * Creates a new TokenDomain instance using the specified properties.
	 * @function create
	 * @memberof TokenDomain
	 * @static
	 * @param {ITokenDomain=} [properties] Properties to set
	 * @returns {TokenDomain} TokenDomain instance
	 */
	TokenDomain.create = function create(properties) {
		return new TokenDomain(properties);
	};

	/**
	 * Encodes the specified TokenDomain message. Does not implicitly {@link TokenDomain.verify|verify} messages.
	 * @function encode
	 * @memberof TokenDomain
	 * @static
	 * @param {ITokenDomain} message TokenDomain message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	TokenDomain.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.domain);
		return writer;
	};

	/**
	 * Encodes the specified TokenDomain message, length delimited. Does not implicitly {@link TokenDomain.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof TokenDomain
	 * @static
	 * @param {ITokenDomain} message TokenDomain message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	TokenDomain.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a TokenDomain message from the specified reader or buffer.
	 * @function decode
	 * @memberof TokenDomain
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {TokenDomain} TokenDomain
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	TokenDomain.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.TokenDomain();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.domain = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a TokenDomain message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof TokenDomain
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {TokenDomain} TokenDomain
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	TokenDomain.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a TokenDomain message.
	 * @function verify
	 * @memberof TokenDomain
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	TokenDomain.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.domain != null && message.hasOwnProperty("domain"))
			if (!$util.isString(message.domain)) return "domain: string expected";
		return null;
	};

	/**
	 * Creates a TokenDomain message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof TokenDomain
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {TokenDomain} TokenDomain
	 */
	TokenDomain.fromObject = function fromObject(object) {
		if (object instanceof $root.TokenDomain) return object;
		var message = new $root.TokenDomain();
		if (object.domain != null) message.domain = String(object.domain);
		return message;
	};

	/**
	 * Creates a plain object from a TokenDomain message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof TokenDomain
	 * @static
	 * @param {TokenDomain} message TokenDomain
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	TokenDomain.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.domain = "";
		if (message.domain != null && message.hasOwnProperty("domain")) object.domain = message.domain;
		return object;
	};

	/**
	 * Converts this TokenDomain to JSON.
	 * @function toJSON
	 * @memberof TokenDomain
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	TokenDomain.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for TokenDomain
	 * @function getTypeUrl
	 * @memberof TokenDomain
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	TokenDomain.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/TokenDomain";
	};

	return TokenDomain;
})();

$root.GrantedTokenResponse = (function () {
	/**
	 * Properties of a GrantedTokenResponse.
	 * @exports IGrantedTokenResponse
	 * @interface IGrantedTokenResponse
	 * @property {string|null} [token] GrantedTokenResponse token
	 * @property {number|null} [expiresAfterSeconds] GrantedTokenResponse expiresAfterSeconds
	 * @property {number|null} [refreshAfterSeconds] GrantedTokenResponse refreshAfterSeconds
	 * @property {Array.<ITokenDomain>|null} [domains] GrantedTokenResponse domains
	 */

	/**
	 * Constructs a new GrantedTokenResponse.
	 * @exports GrantedTokenResponse
	 * @classdesc Represents a GrantedTokenResponse.
	 * @implements IGrantedTokenResponse
	 * @constructor
	 * @param {IGrantedTokenResponse=} [properties] Properties to set
	 */
	function GrantedTokenResponse(properties) {
		this.domains = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * GrantedTokenResponse token.
	 * @member {string} token
	 * @memberof GrantedTokenResponse
	 * @instance
	 */
	GrantedTokenResponse.prototype.token = "";

	/**
	 * GrantedTokenResponse expiresAfterSeconds.
	 * @member {number} expiresAfterSeconds
	 * @memberof GrantedTokenResponse
	 * @instance
	 */
	GrantedTokenResponse.prototype.expiresAfterSeconds = 0;

	/**
	 * GrantedTokenResponse refreshAfterSeconds.
	 * @member {number} refreshAfterSeconds
	 * @memberof GrantedTokenResponse
	 * @instance
	 */
	GrantedTokenResponse.prototype.refreshAfterSeconds = 0;

	/**
	 * GrantedTokenResponse domains.
	 * @member {Array.<ITokenDomain>} domains
	 * @memberof GrantedTokenResponse
	 * @instance
	 */
	GrantedTokenResponse.prototype.domains = $util.emptyArray;

	/**
	 * Creates a new GrantedTokenResponse instance using the specified properties.
	 * @function create
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {IGrantedTokenResponse=} [properties] Properties to set
	 * @returns {GrantedTokenResponse} GrantedTokenResponse instance
	 */
	GrantedTokenResponse.create = function create(properties) {
		return new GrantedTokenResponse(properties);
	};

	/**
	 * Encodes the specified GrantedTokenResponse message. Does not implicitly {@link GrantedTokenResponse.verify|verify} messages.
	 * @function encode
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {IGrantedTokenResponse} message GrantedTokenResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	GrantedTokenResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.token != null && Object.hasOwnProperty.call(message, "token"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.token);
		if (message.expiresAfterSeconds != null && Object.hasOwnProperty.call(message, "expiresAfterSeconds"))
			writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.expiresAfterSeconds);
		if (message.refreshAfterSeconds != null && Object.hasOwnProperty.call(message, "refreshAfterSeconds"))
			writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.refreshAfterSeconds);
		if (message.domains != null && message.domains.length)
			for (var i = 0; i < message.domains.length; ++i)
				$root.TokenDomain.encode(message.domains[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified GrantedTokenResponse message, length delimited. Does not implicitly {@link GrantedTokenResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {IGrantedTokenResponse} message GrantedTokenResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	GrantedTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a GrantedTokenResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {GrantedTokenResponse} GrantedTokenResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	GrantedTokenResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.GrantedTokenResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.token = reader.string();
					break;
				}
				case 2: {
					message.expiresAfterSeconds = reader.int32();
					break;
				}
				case 3: {
					message.refreshAfterSeconds = reader.int32();
					break;
				}
				case 4: {
					if (!(message.domains && message.domains.length)) message.domains = [];
					message.domains.push($root.TokenDomain.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a GrantedTokenResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {GrantedTokenResponse} GrantedTokenResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	GrantedTokenResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a GrantedTokenResponse message.
	 * @function verify
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	GrantedTokenResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
		if (message.expiresAfterSeconds != null && message.hasOwnProperty("expiresAfterSeconds"))
			if (!$util.isInteger(message.expiresAfterSeconds)) return "expiresAfterSeconds: integer expected";
		if (message.refreshAfterSeconds != null && message.hasOwnProperty("refreshAfterSeconds"))
			if (!$util.isInteger(message.refreshAfterSeconds)) return "refreshAfterSeconds: integer expected";
		if (message.domains != null && message.hasOwnProperty("domains")) {
			if (!Array.isArray(message.domains)) return "domains: array expected";
			for (var i = 0; i < message.domains.length; ++i) {
				var error = $root.TokenDomain.verify(message.domains[i]);
				if (error) return "domains." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a GrantedTokenResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {GrantedTokenResponse} GrantedTokenResponse
	 */
	GrantedTokenResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.GrantedTokenResponse) return object;
		var message = new $root.GrantedTokenResponse();
		if (object.token != null) message.token = String(object.token);
		if (object.expiresAfterSeconds != null) message.expiresAfterSeconds = object.expiresAfterSeconds | 0;
		if (object.refreshAfterSeconds != null) message.refreshAfterSeconds = object.refreshAfterSeconds | 0;
		if (object.domains) {
			if (!Array.isArray(object.domains)) throw TypeError(".GrantedTokenResponse.domains: array expected");
			message.domains = [];
			for (var i = 0; i < object.domains.length; ++i) {
				if (typeof object.domains[i] !== "object") throw TypeError(".GrantedTokenResponse.domains: object expected");
				message.domains[i] = $root.TokenDomain.fromObject(object.domains[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a GrantedTokenResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {GrantedTokenResponse} message GrantedTokenResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	GrantedTokenResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.domains = [];
		if (options.defaults) {
			object.token = "";
			object.expiresAfterSeconds = 0;
			object.refreshAfterSeconds = 0;
		}
		if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
		if (message.expiresAfterSeconds != null && message.hasOwnProperty("expiresAfterSeconds"))
			object.expiresAfterSeconds = message.expiresAfterSeconds;
		if (message.refreshAfterSeconds != null && message.hasOwnProperty("refreshAfterSeconds"))
			object.refreshAfterSeconds = message.refreshAfterSeconds;
		if (message.domains && message.domains.length) {
			object.domains = [];
			for (var j = 0; j < message.domains.length; ++j) object.domains[j] = $root.TokenDomain.toObject(message.domains[j], options);
		}
		return object;
	};

	/**
	 * Converts this GrantedTokenResponse to JSON.
	 * @function toJSON
	 * @memberof GrantedTokenResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	GrantedTokenResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for GrantedTokenResponse
	 * @function getTypeUrl
	 * @memberof GrantedTokenResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	GrantedTokenResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/GrantedTokenResponse";
	};

	return GrantedTokenResponse;
})();

$root.ChallengesResponse = (function () {
	/**
	 * Properties of a ChallengesResponse.
	 * @exports IChallengesResponse
	 * @interface IChallengesResponse
	 * @property {string|null} [state] ChallengesResponse state
	 * @property {Array.<IChallenge>|null} [challenges] ChallengesResponse challenges
	 */

	/**
	 * Constructs a new ChallengesResponse.
	 * @exports ChallengesResponse
	 * @classdesc Represents a ChallengesResponse.
	 * @implements IChallengesResponse
	 * @constructor
	 * @param {IChallengesResponse=} [properties] Properties to set
	 */
	function ChallengesResponse(properties) {
		this.challenges = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ChallengesResponse state.
	 * @member {string} state
	 * @memberof ChallengesResponse
	 * @instance
	 */
	ChallengesResponse.prototype.state = "";

	/**
	 * ChallengesResponse challenges.
	 * @member {Array.<IChallenge>} challenges
	 * @memberof ChallengesResponse
	 * @instance
	 */
	ChallengesResponse.prototype.challenges = $util.emptyArray;

	/**
	 * Creates a new ChallengesResponse instance using the specified properties.
	 * @function create
	 * @memberof ChallengesResponse
	 * @static
	 * @param {IChallengesResponse=} [properties] Properties to set
	 * @returns {ChallengesResponse} ChallengesResponse instance
	 */
	ChallengesResponse.create = function create(properties) {
		return new ChallengesResponse(properties);
	};

	/**
	 * Encodes the specified ChallengesResponse message. Does not implicitly {@link ChallengesResponse.verify|verify} messages.
	 * @function encode
	 * @memberof ChallengesResponse
	 * @static
	 * @param {IChallengesResponse} message ChallengesResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ChallengesResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.state != null && Object.hasOwnProperty.call(message, "state"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.state);
		if (message.challenges != null && message.challenges.length)
			for (var i = 0; i < message.challenges.length; ++i)
				$root.Challenge.encode(message.challenges[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ChallengesResponse message, length delimited. Does not implicitly {@link ChallengesResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ChallengesResponse
	 * @static
	 * @param {IChallengesResponse} message ChallengesResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ChallengesResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ChallengesResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof ChallengesResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ChallengesResponse} ChallengesResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ChallengesResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ChallengesResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.state = reader.string();
					break;
				}
				case 2: {
					if (!(message.challenges && message.challenges.length)) message.challenges = [];
					message.challenges.push($root.Challenge.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ChallengesResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ChallengesResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ChallengesResponse} ChallengesResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ChallengesResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ChallengesResponse message.
	 * @function verify
	 * @memberof ChallengesResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ChallengesResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.state != null && message.hasOwnProperty("state")) if (!$util.isString(message.state)) return "state: string expected";
		if (message.challenges != null && message.hasOwnProperty("challenges")) {
			if (!Array.isArray(message.challenges)) return "challenges: array expected";
			for (var i = 0; i < message.challenges.length; ++i) {
				var error = $root.Challenge.verify(message.challenges[i]);
				if (error) return "challenges." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a ChallengesResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ChallengesResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ChallengesResponse} ChallengesResponse
	 */
	ChallengesResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.ChallengesResponse) return object;
		var message = new $root.ChallengesResponse();
		if (object.state != null) message.state = String(object.state);
		if (object.challenges) {
			if (!Array.isArray(object.challenges)) throw TypeError(".ChallengesResponse.challenges: array expected");
			message.challenges = [];
			for (var i = 0; i < object.challenges.length; ++i) {
				if (typeof object.challenges[i] !== "object") throw TypeError(".ChallengesResponse.challenges: object expected");
				message.challenges[i] = $root.Challenge.fromObject(object.challenges[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a ChallengesResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ChallengesResponse
	 * @static
	 * @param {ChallengesResponse} message ChallengesResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ChallengesResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.challenges = [];
		if (options.defaults) object.state = "";
		if (message.state != null && message.hasOwnProperty("state")) object.state = message.state;
		if (message.challenges && message.challenges.length) {
			object.challenges = [];
			for (var j = 0; j < message.challenges.length; ++j)
				object.challenges[j] = $root.Challenge.toObject(message.challenges[j], options);
		}
		return object;
	};

	/**
	 * Converts this ChallengesResponse to JSON.
	 * @function toJSON
	 * @memberof ChallengesResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ChallengesResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ChallengesResponse
	 * @function getTypeUrl
	 * @memberof ChallengesResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ChallengesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ChallengesResponse";
	};

	return ChallengesResponse;
})();

$root.ClientSecretParameters = (function () {
	/**
	 * Properties of a ClientSecretParameters.
	 * @exports IClientSecretParameters
	 * @interface IClientSecretParameters
	 * @property {string|null} [salt] ClientSecretParameters salt
	 */

	/**
	 * Constructs a new ClientSecretParameters.
	 * @exports ClientSecretParameters
	 * @classdesc Represents a ClientSecretParameters.
	 * @implements IClientSecretParameters
	 * @constructor
	 * @param {IClientSecretParameters=} [properties] Properties to set
	 */
	function ClientSecretParameters(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientSecretParameters salt.
	 * @member {string} salt
	 * @memberof ClientSecretParameters
	 * @instance
	 */
	ClientSecretParameters.prototype.salt = "";

	/**
	 * Creates a new ClientSecretParameters instance using the specified properties.
	 * @function create
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {IClientSecretParameters=} [properties] Properties to set
	 * @returns {ClientSecretParameters} ClientSecretParameters instance
	 */
	ClientSecretParameters.create = function create(properties) {
		return new ClientSecretParameters(properties);
	};

	/**
	 * Encodes the specified ClientSecretParameters message. Does not implicitly {@link ClientSecretParameters.verify|verify} messages.
	 * @function encode
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {IClientSecretParameters} message ClientSecretParameters message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientSecretParameters.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.salt);
		return writer;
	};

	/**
	 * Encodes the specified ClientSecretParameters message, length delimited. Does not implicitly {@link ClientSecretParameters.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {IClientSecretParameters} message ClientSecretParameters message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientSecretParameters.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientSecretParameters message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientSecretParameters} ClientSecretParameters
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientSecretParameters.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientSecretParameters();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.salt = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ClientSecretParameters message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientSecretParameters} ClientSecretParameters
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientSecretParameters.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientSecretParameters message.
	 * @function verify
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientSecretParameters.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.salt != null && message.hasOwnProperty("salt")) if (!$util.isString(message.salt)) return "salt: string expected";
		return null;
	};

	/**
	 * Creates a ClientSecretParameters message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientSecretParameters} ClientSecretParameters
	 */
	ClientSecretParameters.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientSecretParameters) return object;
		var message = new $root.ClientSecretParameters();
		if (object.salt != null) message.salt = String(object.salt);
		return message;
	};

	/**
	 * Creates a plain object from a ClientSecretParameters message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {ClientSecretParameters} message ClientSecretParameters
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientSecretParameters.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.salt = "";
		if (message.salt != null && message.hasOwnProperty("salt")) object.salt = message.salt;
		return object;
	};

	/**
	 * Converts this ClientSecretParameters to JSON.
	 * @function toJSON
	 * @memberof ClientSecretParameters
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientSecretParameters.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientSecretParameters
	 * @function getTypeUrl
	 * @memberof ClientSecretParameters
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientSecretParameters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientSecretParameters";
	};

	return ClientSecretParameters;
})();

$root.EvaluateJSParameters = (function () {
	/**
	 * Properties of an EvaluateJSParameters.
	 * @exports IEvaluateJSParameters
	 * @interface IEvaluateJSParameters
	 * @property {string|null} [code] EvaluateJSParameters code
	 * @property {Array.<string>|null} [libraries] EvaluateJSParameters libraries
	 */

	/**
	 * Constructs a new EvaluateJSParameters.
	 * @exports EvaluateJSParameters
	 * @classdesc Represents an EvaluateJSParameters.
	 * @implements IEvaluateJSParameters
	 * @constructor
	 * @param {IEvaluateJSParameters=} [properties] Properties to set
	 */
	function EvaluateJSParameters(properties) {
		this.libraries = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * EvaluateJSParameters code.
	 * @member {string} code
	 * @memberof EvaluateJSParameters
	 * @instance
	 */
	EvaluateJSParameters.prototype.code = "";

	/**
	 * EvaluateJSParameters libraries.
	 * @member {Array.<string>} libraries
	 * @memberof EvaluateJSParameters
	 * @instance
	 */
	EvaluateJSParameters.prototype.libraries = $util.emptyArray;

	/**
	 * Creates a new EvaluateJSParameters instance using the specified properties.
	 * @function create
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {IEvaluateJSParameters=} [properties] Properties to set
	 * @returns {EvaluateJSParameters} EvaluateJSParameters instance
	 */
	EvaluateJSParameters.create = function create(properties) {
		return new EvaluateJSParameters(properties);
	};

	/**
	 * Encodes the specified EvaluateJSParameters message. Does not implicitly {@link EvaluateJSParameters.verify|verify} messages.
	 * @function encode
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {IEvaluateJSParameters} message EvaluateJSParameters message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	EvaluateJSParameters.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.code != null && Object.hasOwnProperty.call(message, "code"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.code);
		if (message.libraries != null && message.libraries.length)
			for (var i = 0; i < message.libraries.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.libraries[i]);
		return writer;
	};

	/**
	 * Encodes the specified EvaluateJSParameters message, length delimited. Does not implicitly {@link EvaluateJSParameters.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {IEvaluateJSParameters} message EvaluateJSParameters message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	EvaluateJSParameters.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an EvaluateJSParameters message from the specified reader or buffer.
	 * @function decode
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {EvaluateJSParameters} EvaluateJSParameters
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	EvaluateJSParameters.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.EvaluateJSParameters();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.code = reader.string();
					break;
				}
				case 2: {
					if (!(message.libraries && message.libraries.length)) message.libraries = [];
					message.libraries.push(reader.string());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an EvaluateJSParameters message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {EvaluateJSParameters} EvaluateJSParameters
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	EvaluateJSParameters.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an EvaluateJSParameters message.
	 * @function verify
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	EvaluateJSParameters.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.code != null && message.hasOwnProperty("code")) if (!$util.isString(message.code)) return "code: string expected";
		if (message.libraries != null && message.hasOwnProperty("libraries")) {
			if (!Array.isArray(message.libraries)) return "libraries: array expected";
			for (var i = 0; i < message.libraries.length; ++i)
				if (!$util.isString(message.libraries[i])) return "libraries: string[] expected";
		}
		return null;
	};

	/**
	 * Creates an EvaluateJSParameters message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {EvaluateJSParameters} EvaluateJSParameters
	 */
	EvaluateJSParameters.fromObject = function fromObject(object) {
		if (object instanceof $root.EvaluateJSParameters) return object;
		var message = new $root.EvaluateJSParameters();
		if (object.code != null) message.code = String(object.code);
		if (object.libraries) {
			if (!Array.isArray(object.libraries)) throw TypeError(".EvaluateJSParameters.libraries: array expected");
			message.libraries = [];
			for (var i = 0; i < object.libraries.length; ++i) message.libraries[i] = String(object.libraries[i]);
		}
		return message;
	};

	/**
	 * Creates a plain object from an EvaluateJSParameters message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {EvaluateJSParameters} message EvaluateJSParameters
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	EvaluateJSParameters.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.libraries = [];
		if (options.defaults) object.code = "";
		if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
		if (message.libraries && message.libraries.length) {
			object.libraries = [];
			for (var j = 0; j < message.libraries.length; ++j) object.libraries[j] = message.libraries[j];
		}
		return object;
	};

	/**
	 * Converts this EvaluateJSParameters to JSON.
	 * @function toJSON
	 * @memberof EvaluateJSParameters
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	EvaluateJSParameters.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for EvaluateJSParameters
	 * @function getTypeUrl
	 * @memberof EvaluateJSParameters
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	EvaluateJSParameters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/EvaluateJSParameters";
	};

	return EvaluateJSParameters;
})();

$root.HashCashParameters = (function () {
	/**
	 * Properties of a HashCashParameters.
	 * @exports IHashCashParameters
	 * @interface IHashCashParameters
	 * @property {number|null} [length] HashCashParameters length
	 * @property {string|null} [prefix] HashCashParameters prefix
	 */

	/**
	 * Constructs a new HashCashParameters.
	 * @exports HashCashParameters
	 * @classdesc Represents a HashCashParameters.
	 * @implements IHashCashParameters
	 * @constructor
	 * @param {IHashCashParameters=} [properties] Properties to set
	 */
	function HashCashParameters(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * HashCashParameters length.
	 * @member {number} length
	 * @memberof HashCashParameters
	 * @instance
	 */
	HashCashParameters.prototype.length = 0;

	/**
	 * HashCashParameters prefix.
	 * @member {string} prefix
	 * @memberof HashCashParameters
	 * @instance
	 */
	HashCashParameters.prototype.prefix = "";

	/**
	 * Creates a new HashCashParameters instance using the specified properties.
	 * @function create
	 * @memberof HashCashParameters
	 * @static
	 * @param {IHashCashParameters=} [properties] Properties to set
	 * @returns {HashCashParameters} HashCashParameters instance
	 */
	HashCashParameters.create = function create(properties) {
		return new HashCashParameters(properties);
	};

	/**
	 * Encodes the specified HashCashParameters message. Does not implicitly {@link HashCashParameters.verify|verify} messages.
	 * @function encode
	 * @memberof HashCashParameters
	 * @static
	 * @param {IHashCashParameters} message HashCashParameters message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	HashCashParameters.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.length != null && Object.hasOwnProperty.call(message, "length"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.length);
		if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.prefix);
		return writer;
	};

	/**
	 * Encodes the specified HashCashParameters message, length delimited. Does not implicitly {@link HashCashParameters.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof HashCashParameters
	 * @static
	 * @param {IHashCashParameters} message HashCashParameters message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	HashCashParameters.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a HashCashParameters message from the specified reader or buffer.
	 * @function decode
	 * @memberof HashCashParameters
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {HashCashParameters} HashCashParameters
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	HashCashParameters.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.HashCashParameters();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.length = reader.int32();
					break;
				}
				case 2: {
					message.prefix = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a HashCashParameters message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof HashCashParameters
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {HashCashParameters} HashCashParameters
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	HashCashParameters.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a HashCashParameters message.
	 * @function verify
	 * @memberof HashCashParameters
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	HashCashParameters.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.length != null && message.hasOwnProperty("length"))
			if (!$util.isInteger(message.length)) return "length: integer expected";
		if (message.prefix != null && message.hasOwnProperty("prefix"))
			if (!$util.isString(message.prefix)) return "prefix: string expected";
		return null;
	};

	/**
	 * Creates a HashCashParameters message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof HashCashParameters
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {HashCashParameters} HashCashParameters
	 */
	HashCashParameters.fromObject = function fromObject(object) {
		if (object instanceof $root.HashCashParameters) return object;
		var message = new $root.HashCashParameters();
		if (object.length != null) message.length = object.length | 0;
		if (object.prefix != null) message.prefix = String(object.prefix);
		return message;
	};

	/**
	 * Creates a plain object from a HashCashParameters message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof HashCashParameters
	 * @static
	 * @param {HashCashParameters} message HashCashParameters
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	HashCashParameters.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.length = 0;
			object.prefix = "";
		}
		if (message.length != null && message.hasOwnProperty("length")) object.length = message.length;
		if (message.prefix != null && message.hasOwnProperty("prefix")) object.prefix = message.prefix;
		return object;
	};

	/**
	 * Converts this HashCashParameters to JSON.
	 * @function toJSON
	 * @memberof HashCashParameters
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	HashCashParameters.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for HashCashParameters
	 * @function getTypeUrl
	 * @memberof HashCashParameters
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	HashCashParameters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/HashCashParameters";
	};

	return HashCashParameters;
})();

$root.Challenge = (function () {
	/**
	 * Properties of a Challenge.
	 * @exports IChallenge
	 * @interface IChallenge
	 * @property {ChallengeType|null} [type] Challenge type
	 * @property {IClientSecretParameters|null} [clientSecretParameters] Challenge clientSecretParameters
	 * @property {IEvaluateJSParameters|null} [evaluateJsParameters] Challenge evaluateJsParameters
	 * @property {IHashCashParameters|null} [evaluateHashcashParameters] Challenge evaluateHashcashParameters
	 */

	/**
	 * Constructs a new Challenge.
	 * @exports Challenge
	 * @classdesc Represents a Challenge.
	 * @implements IChallenge
	 * @constructor
	 * @param {IChallenge=} [properties] Properties to set
	 */
	function Challenge(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Challenge type.
	 * @member {ChallengeType} type
	 * @memberof Challenge
	 * @instance
	 */
	Challenge.prototype.type = 0;

	/**
	 * Challenge clientSecretParameters.
	 * @member {IClientSecretParameters|null|undefined} clientSecretParameters
	 * @memberof Challenge
	 * @instance
	 */
	Challenge.prototype.clientSecretParameters = null;

	/**
	 * Challenge evaluateJsParameters.
	 * @member {IEvaluateJSParameters|null|undefined} evaluateJsParameters
	 * @memberof Challenge
	 * @instance
	 */
	Challenge.prototype.evaluateJsParameters = null;

	/**
	 * Challenge evaluateHashcashParameters.
	 * @member {IHashCashParameters|null|undefined} evaluateHashcashParameters
	 * @memberof Challenge
	 * @instance
	 */
	Challenge.prototype.evaluateHashcashParameters = null;

	// OneOf field names bound to virtual getters and setters
	var $oneOfFields;

	/**
	 * Challenge parameters.
	 * @member {"clientSecretParameters"|"evaluateJsParameters"|"evaluateHashcashParameters"|undefined} parameters
	 * @memberof Challenge
	 * @instance
	 */
	Object.defineProperty(Challenge.prototype, "parameters", {
		get: $util.oneOfGetter(($oneOfFields = ["clientSecretParameters", "evaluateJsParameters", "evaluateHashcashParameters"])),
		set: $util.oneOfSetter($oneOfFields),
	});

	/**
	 * Creates a new Challenge instance using the specified properties.
	 * @function create
	 * @memberof Challenge
	 * @static
	 * @param {IChallenge=} [properties] Properties to set
	 * @returns {Challenge} Challenge instance
	 */
	Challenge.create = function create(properties) {
		return new Challenge(properties);
	};

	/**
	 * Encodes the specified Challenge message. Does not implicitly {@link Challenge.verify|verify} messages.
	 * @function encode
	 * @memberof Challenge
	 * @static
	 * @param {IChallenge} message Challenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Challenge.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.type != null && Object.hasOwnProperty.call(message, "type"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
		if (message.clientSecretParameters != null && Object.hasOwnProperty.call(message, "clientSecretParameters"))
			$root.ClientSecretParameters.encode(message.clientSecretParameters, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		if (message.evaluateJsParameters != null && Object.hasOwnProperty.call(message, "evaluateJsParameters"))
			$root.EvaluateJSParameters.encode(message.evaluateJsParameters, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		if (message.evaluateHashcashParameters != null && Object.hasOwnProperty.call(message, "evaluateHashcashParameters"))
			$root.HashCashParameters.encode(message.evaluateHashcashParameters, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified Challenge message, length delimited. Does not implicitly {@link Challenge.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Challenge
	 * @static
	 * @param {IChallenge} message Challenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Challenge.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Challenge message from the specified reader or buffer.
	 * @function decode
	 * @memberof Challenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Challenge} Challenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Challenge.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Challenge();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.type = reader.int32();
					break;
				}
				case 2: {
					message.clientSecretParameters = $root.ClientSecretParameters.decode(reader, reader.uint32());
					break;
				}
				case 3: {
					message.evaluateJsParameters = $root.EvaluateJSParameters.decode(reader, reader.uint32());
					break;
				}
				case 4: {
					message.evaluateHashcashParameters = $root.HashCashParameters.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Challenge message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Challenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Challenge} Challenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Challenge.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Challenge message.
	 * @function verify
	 * @memberof Challenge
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Challenge.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		var properties = {};
		if (message.type != null && message.hasOwnProperty("type"))
			switch (message.type) {
				default:
					return "type: enum value expected";
				case 0:
				case 1:
				case 2:
				case 3:
					break;
			}
		if (message.clientSecretParameters != null && message.hasOwnProperty("clientSecretParameters")) {
			properties.parameters = 1;
			{
				var error = $root.ClientSecretParameters.verify(message.clientSecretParameters);
				if (error) return "clientSecretParameters." + error;
			}
		}
		if (message.evaluateJsParameters != null && message.hasOwnProperty("evaluateJsParameters")) {
			if (properties.parameters === 1) return "parameters: multiple values";
			properties.parameters = 1;
			{
				var error = $root.EvaluateJSParameters.verify(message.evaluateJsParameters);
				if (error) return "evaluateJsParameters." + error;
			}
		}
		if (message.evaluateHashcashParameters != null && message.hasOwnProperty("evaluateHashcashParameters")) {
			if (properties.parameters === 1) return "parameters: multiple values";
			properties.parameters = 1;
			{
				var error = $root.HashCashParameters.verify(message.evaluateHashcashParameters);
				if (error) return "evaluateHashcashParameters." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a Challenge message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Challenge
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Challenge} Challenge
	 */
	Challenge.fromObject = function fromObject(object) {
		if (object instanceof $root.Challenge) return object;
		var message = new $root.Challenge();
		switch (object.type) {
			default:
				if (typeof object.type === "number") {
					message.type = object.type;
					break;
				}
				break;
			case "CHALLENGE_UNKNOWN":
			case 0:
				message.type = 0;
				break;
			case "CHALLENGE_CLIENT_SECRET_HMAC":
			case 1:
				message.type = 1;
				break;
			case "CHALLENGE_EVALUATE_JS":
			case 2:
				message.type = 2;
				break;
			case "CHALLENGE_HASH_CASH":
			case 3:
				message.type = 3;
				break;
		}
		if (object.clientSecretParameters != null) {
			if (typeof object.clientSecretParameters !== "object") throw TypeError(".Challenge.clientSecretParameters: object expected");
			message.clientSecretParameters = $root.ClientSecretParameters.fromObject(object.clientSecretParameters);
		}
		if (object.evaluateJsParameters != null) {
			if (typeof object.evaluateJsParameters !== "object") throw TypeError(".Challenge.evaluateJsParameters: object expected");
			message.evaluateJsParameters = $root.EvaluateJSParameters.fromObject(object.evaluateJsParameters);
		}
		if (object.evaluateHashcashParameters != null) {
			if (typeof object.evaluateHashcashParameters !== "object")
				throw TypeError(".Challenge.evaluateHashcashParameters: object expected");
			message.evaluateHashcashParameters = $root.HashCashParameters.fromObject(object.evaluateHashcashParameters);
		}
		return message;
	};

	/**
	 * Creates a plain object from a Challenge message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Challenge
	 * @static
	 * @param {Challenge} message Challenge
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Challenge.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.type = options.enums === String ? "CHALLENGE_UNKNOWN" : 0;
		if (message.type != null && message.hasOwnProperty("type"))
			object.type =
				options.enums === String
					? $root.ChallengeType[message.type] === undefined
						? message.type
						: $root.ChallengeType[message.type]
					: message.type;
		if (message.clientSecretParameters != null && message.hasOwnProperty("clientSecretParameters")) {
			object.clientSecretParameters = $root.ClientSecretParameters.toObject(message.clientSecretParameters, options);
			if (options.oneofs) object.parameters = "clientSecretParameters";
		}
		if (message.evaluateJsParameters != null && message.hasOwnProperty("evaluateJsParameters")) {
			object.evaluateJsParameters = $root.EvaluateJSParameters.toObject(message.evaluateJsParameters, options);
			if (options.oneofs) object.parameters = "evaluateJsParameters";
		}
		if (message.evaluateHashcashParameters != null && message.hasOwnProperty("evaluateHashcashParameters")) {
			object.evaluateHashcashParameters = $root.HashCashParameters.toObject(message.evaluateHashcashParameters, options);
			if (options.oneofs) object.parameters = "evaluateHashcashParameters";
		}
		return object;
	};

	/**
	 * Converts this Challenge to JSON.
	 * @function toJSON
	 * @memberof Challenge
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Challenge.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Challenge
	 * @function getTypeUrl
	 * @memberof Challenge
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Challenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Challenge";
	};

	return Challenge;
})();

$root.ClientSecretHMACAnswer = (function () {
	/**
	 * Properties of a ClientSecretHMACAnswer.
	 * @exports IClientSecretHMACAnswer
	 * @interface IClientSecretHMACAnswer
	 * @property {string|null} [hmac] ClientSecretHMACAnswer hmac
	 */

	/**
	 * Constructs a new ClientSecretHMACAnswer.
	 * @exports ClientSecretHMACAnswer
	 * @classdesc Represents a ClientSecretHMACAnswer.
	 * @implements IClientSecretHMACAnswer
	 * @constructor
	 * @param {IClientSecretHMACAnswer=} [properties] Properties to set
	 */
	function ClientSecretHMACAnswer(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientSecretHMACAnswer hmac.
	 * @member {string} hmac
	 * @memberof ClientSecretHMACAnswer
	 * @instance
	 */
	ClientSecretHMACAnswer.prototype.hmac = "";

	/**
	 * Creates a new ClientSecretHMACAnswer instance using the specified properties.
	 * @function create
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {IClientSecretHMACAnswer=} [properties] Properties to set
	 * @returns {ClientSecretHMACAnswer} ClientSecretHMACAnswer instance
	 */
	ClientSecretHMACAnswer.create = function create(properties) {
		return new ClientSecretHMACAnswer(properties);
	};

	/**
	 * Encodes the specified ClientSecretHMACAnswer message. Does not implicitly {@link ClientSecretHMACAnswer.verify|verify} messages.
	 * @function encode
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {IClientSecretHMACAnswer} message ClientSecretHMACAnswer message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientSecretHMACAnswer.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.hmac != null && Object.hasOwnProperty.call(message, "hmac"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.hmac);
		return writer;
	};

	/**
	 * Encodes the specified ClientSecretHMACAnswer message, length delimited. Does not implicitly {@link ClientSecretHMACAnswer.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {IClientSecretHMACAnswer} message ClientSecretHMACAnswer message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientSecretHMACAnswer.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientSecretHMACAnswer message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientSecretHMACAnswer} ClientSecretHMACAnswer
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientSecretHMACAnswer.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientSecretHMACAnswer();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.hmac = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ClientSecretHMACAnswer message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientSecretHMACAnswer} ClientSecretHMACAnswer
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientSecretHMACAnswer.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientSecretHMACAnswer message.
	 * @function verify
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientSecretHMACAnswer.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.hmac != null && message.hasOwnProperty("hmac")) if (!$util.isString(message.hmac)) return "hmac: string expected";
		return null;
	};

	/**
	 * Creates a ClientSecretHMACAnswer message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientSecretHMACAnswer} ClientSecretHMACAnswer
	 */
	ClientSecretHMACAnswer.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientSecretHMACAnswer) return object;
		var message = new $root.ClientSecretHMACAnswer();
		if (object.hmac != null) message.hmac = String(object.hmac);
		return message;
	};

	/**
	 * Creates a plain object from a ClientSecretHMACAnswer message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {ClientSecretHMACAnswer} message ClientSecretHMACAnswer
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientSecretHMACAnswer.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.hmac = "";
		if (message.hmac != null && message.hasOwnProperty("hmac")) object.hmac = message.hmac;
		return object;
	};

	/**
	 * Converts this ClientSecretHMACAnswer to JSON.
	 * @function toJSON
	 * @memberof ClientSecretHMACAnswer
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientSecretHMACAnswer.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientSecretHMACAnswer
	 * @function getTypeUrl
	 * @memberof ClientSecretHMACAnswer
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientSecretHMACAnswer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientSecretHMACAnswer";
	};

	return ClientSecretHMACAnswer;
})();

$root.EvaluateJSAnswer = (function () {
	/**
	 * Properties of an EvaluateJSAnswer.
	 * @exports IEvaluateJSAnswer
	 * @interface IEvaluateJSAnswer
	 * @property {string|null} [result] EvaluateJSAnswer result
	 */

	/**
	 * Constructs a new EvaluateJSAnswer.
	 * @exports EvaluateJSAnswer
	 * @classdesc Represents an EvaluateJSAnswer.
	 * @implements IEvaluateJSAnswer
	 * @constructor
	 * @param {IEvaluateJSAnswer=} [properties] Properties to set
	 */
	function EvaluateJSAnswer(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * EvaluateJSAnswer result.
	 * @member {string} result
	 * @memberof EvaluateJSAnswer
	 * @instance
	 */
	EvaluateJSAnswer.prototype.result = "";

	/**
	 * Creates a new EvaluateJSAnswer instance using the specified properties.
	 * @function create
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {IEvaluateJSAnswer=} [properties] Properties to set
	 * @returns {EvaluateJSAnswer} EvaluateJSAnswer instance
	 */
	EvaluateJSAnswer.create = function create(properties) {
		return new EvaluateJSAnswer(properties);
	};

	/**
	 * Encodes the specified EvaluateJSAnswer message. Does not implicitly {@link EvaluateJSAnswer.verify|verify} messages.
	 * @function encode
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {IEvaluateJSAnswer} message EvaluateJSAnswer message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	EvaluateJSAnswer.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.result != null && Object.hasOwnProperty.call(message, "result"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.result);
		return writer;
	};

	/**
	 * Encodes the specified EvaluateJSAnswer message, length delimited. Does not implicitly {@link EvaluateJSAnswer.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {IEvaluateJSAnswer} message EvaluateJSAnswer message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	EvaluateJSAnswer.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an EvaluateJSAnswer message from the specified reader or buffer.
	 * @function decode
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {EvaluateJSAnswer} EvaluateJSAnswer
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	EvaluateJSAnswer.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.EvaluateJSAnswer();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.result = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an EvaluateJSAnswer message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {EvaluateJSAnswer} EvaluateJSAnswer
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	EvaluateJSAnswer.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an EvaluateJSAnswer message.
	 * @function verify
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	EvaluateJSAnswer.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.result != null && message.hasOwnProperty("result"))
			if (!$util.isString(message.result)) return "result: string expected";
		return null;
	};

	/**
	 * Creates an EvaluateJSAnswer message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {EvaluateJSAnswer} EvaluateJSAnswer
	 */
	EvaluateJSAnswer.fromObject = function fromObject(object) {
		if (object instanceof $root.EvaluateJSAnswer) return object;
		var message = new $root.EvaluateJSAnswer();
		if (object.result != null) message.result = String(object.result);
		return message;
	};

	/**
	 * Creates a plain object from an EvaluateJSAnswer message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {EvaluateJSAnswer} message EvaluateJSAnswer
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	EvaluateJSAnswer.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.result = "";
		if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
		return object;
	};

	/**
	 * Converts this EvaluateJSAnswer to JSON.
	 * @function toJSON
	 * @memberof EvaluateJSAnswer
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	EvaluateJSAnswer.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for EvaluateJSAnswer
	 * @function getTypeUrl
	 * @memberof EvaluateJSAnswer
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	EvaluateJSAnswer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/EvaluateJSAnswer";
	};

	return EvaluateJSAnswer;
})();

$root.HashCashAnswer = (function () {
	/**
	 * Properties of a HashCashAnswer.
	 * @exports IHashCashAnswer
	 * @interface IHashCashAnswer
	 * @property {string|null} [suffix] HashCashAnswer suffix
	 */

	/**
	 * Constructs a new HashCashAnswer.
	 * @exports HashCashAnswer
	 * @classdesc Represents a HashCashAnswer.
	 * @implements IHashCashAnswer
	 * @constructor
	 * @param {IHashCashAnswer=} [properties] Properties to set
	 */
	function HashCashAnswer(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * HashCashAnswer suffix.
	 * @member {string} suffix
	 * @memberof HashCashAnswer
	 * @instance
	 */
	HashCashAnswer.prototype.suffix = "";

	/**
	 * Creates a new HashCashAnswer instance using the specified properties.
	 * @function create
	 * @memberof HashCashAnswer
	 * @static
	 * @param {IHashCashAnswer=} [properties] Properties to set
	 * @returns {HashCashAnswer} HashCashAnswer instance
	 */
	HashCashAnswer.create = function create(properties) {
		return new HashCashAnswer(properties);
	};

	/**
	 * Encodes the specified HashCashAnswer message. Does not implicitly {@link HashCashAnswer.verify|verify} messages.
	 * @function encode
	 * @memberof HashCashAnswer
	 * @static
	 * @param {IHashCashAnswer} message HashCashAnswer message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	HashCashAnswer.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.suffix);
		return writer;
	};

	/**
	 * Encodes the specified HashCashAnswer message, length delimited. Does not implicitly {@link HashCashAnswer.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof HashCashAnswer
	 * @static
	 * @param {IHashCashAnswer} message HashCashAnswer message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	HashCashAnswer.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a HashCashAnswer message from the specified reader or buffer.
	 * @function decode
	 * @memberof HashCashAnswer
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {HashCashAnswer} HashCashAnswer
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	HashCashAnswer.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.HashCashAnswer();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.suffix = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a HashCashAnswer message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof HashCashAnswer
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {HashCashAnswer} HashCashAnswer
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	HashCashAnswer.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a HashCashAnswer message.
	 * @function verify
	 * @memberof HashCashAnswer
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	HashCashAnswer.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.suffix != null && message.hasOwnProperty("suffix"))
			if (!$util.isString(message.suffix)) return "suffix: string expected";
		return null;
	};

	/**
	 * Creates a HashCashAnswer message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof HashCashAnswer
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {HashCashAnswer} HashCashAnswer
	 */
	HashCashAnswer.fromObject = function fromObject(object) {
		if (object instanceof $root.HashCashAnswer) return object;
		var message = new $root.HashCashAnswer();
		if (object.suffix != null) message.suffix = String(object.suffix);
		return message;
	};

	/**
	 * Creates a plain object from a HashCashAnswer message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof HashCashAnswer
	 * @static
	 * @param {HashCashAnswer} message HashCashAnswer
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	HashCashAnswer.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.suffix = "";
		if (message.suffix != null && message.hasOwnProperty("suffix")) object.suffix = message.suffix;
		return object;
	};

	/**
	 * Converts this HashCashAnswer to JSON.
	 * @function toJSON
	 * @memberof HashCashAnswer
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	HashCashAnswer.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for HashCashAnswer
	 * @function getTypeUrl
	 * @memberof HashCashAnswer
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	HashCashAnswer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/HashCashAnswer";
	};

	return HashCashAnswer;
})();

$root.ChallengeAnswer = (function () {
	/**
	 * Properties of a ChallengeAnswer.
	 * @exports IChallengeAnswer
	 * @interface IChallengeAnswer
	 * @property {ChallengeType|null} [ChallengeType] ChallengeAnswer ChallengeType
	 * @property {IClientSecretHMACAnswer|null} [clientSecret] ChallengeAnswer clientSecret
	 * @property {IEvaluateJSAnswer|null} [evaluateJs] ChallengeAnswer evaluateJs
	 * @property {IHashCashAnswer|null} [hashCash] ChallengeAnswer hashCash
	 */

	/**
	 * Constructs a new ChallengeAnswer.
	 * @exports ChallengeAnswer
	 * @classdesc Represents a ChallengeAnswer.
	 * @implements IChallengeAnswer
	 * @constructor
	 * @param {IChallengeAnswer=} [properties] Properties to set
	 */
	function ChallengeAnswer(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ChallengeAnswer ChallengeType.
	 * @member {ChallengeType} ChallengeType
	 * @memberof ChallengeAnswer
	 * @instance
	 */
	ChallengeAnswer.prototype.ChallengeType = 0;

	/**
	 * ChallengeAnswer clientSecret.
	 * @member {IClientSecretHMACAnswer|null|undefined} clientSecret
	 * @memberof ChallengeAnswer
	 * @instance
	 */
	ChallengeAnswer.prototype.clientSecret = null;

	/**
	 * ChallengeAnswer evaluateJs.
	 * @member {IEvaluateJSAnswer|null|undefined} evaluateJs
	 * @memberof ChallengeAnswer
	 * @instance
	 */
	ChallengeAnswer.prototype.evaluateJs = null;

	/**
	 * ChallengeAnswer hashCash.
	 * @member {IHashCashAnswer|null|undefined} hashCash
	 * @memberof ChallengeAnswer
	 * @instance
	 */
	ChallengeAnswer.prototype.hashCash = null;

	// OneOf field names bound to virtual getters and setters
	var $oneOfFields;

	/**
	 * ChallengeAnswer answer.
	 * @member {"clientSecret"|"evaluateJs"|"hashCash"|undefined} answer
	 * @memberof ChallengeAnswer
	 * @instance
	 */
	Object.defineProperty(ChallengeAnswer.prototype, "answer", {
		get: $util.oneOfGetter(($oneOfFields = ["clientSecret", "evaluateJs", "hashCash"])),
		set: $util.oneOfSetter($oneOfFields),
	});

	/**
	 * Creates a new ChallengeAnswer instance using the specified properties.
	 * @function create
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {IChallengeAnswer=} [properties] Properties to set
	 * @returns {ChallengeAnswer} ChallengeAnswer instance
	 */
	ChallengeAnswer.create = function create(properties) {
		return new ChallengeAnswer(properties);
	};

	/**
	 * Encodes the specified ChallengeAnswer message. Does not implicitly {@link ChallengeAnswer.verify|verify} messages.
	 * @function encode
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {IChallengeAnswer} message ChallengeAnswer message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ChallengeAnswer.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.ChallengeType != null && Object.hasOwnProperty.call(message, "ChallengeType"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.ChallengeType);
		if (message.clientSecret != null && Object.hasOwnProperty.call(message, "clientSecret"))
			$root.ClientSecretHMACAnswer.encode(message.clientSecret, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		if (message.evaluateJs != null && Object.hasOwnProperty.call(message, "evaluateJs"))
			$root.EvaluateJSAnswer.encode(message.evaluateJs, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		if (message.hashCash != null && Object.hasOwnProperty.call(message, "hashCash"))
			$root.HashCashAnswer.encode(message.hashCash, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ChallengeAnswer message, length delimited. Does not implicitly {@link ChallengeAnswer.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {IChallengeAnswer} message ChallengeAnswer message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ChallengeAnswer.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ChallengeAnswer message from the specified reader or buffer.
	 * @function decode
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ChallengeAnswer} ChallengeAnswer
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ChallengeAnswer.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ChallengeAnswer();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.ChallengeType = reader.int32();
					break;
				}
				case 2: {
					message.clientSecret = $root.ClientSecretHMACAnswer.decode(reader, reader.uint32());
					break;
				}
				case 3: {
					message.evaluateJs = $root.EvaluateJSAnswer.decode(reader, reader.uint32());
					break;
				}
				case 4: {
					message.hashCash = $root.HashCashAnswer.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ChallengeAnswer message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ChallengeAnswer} ChallengeAnswer
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ChallengeAnswer.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ChallengeAnswer message.
	 * @function verify
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ChallengeAnswer.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		var properties = {};
		if (message.ChallengeType != null && message.hasOwnProperty("ChallengeType"))
			switch (message.ChallengeType) {
				default:
					return "ChallengeType: enum value expected";
				case 0:
				case 1:
				case 2:
				case 3:
					break;
			}
		if (message.clientSecret != null && message.hasOwnProperty("clientSecret")) {
			properties.answer = 1;
			{
				var error = $root.ClientSecretHMACAnswer.verify(message.clientSecret);
				if (error) return "clientSecret." + error;
			}
		}
		if (message.evaluateJs != null && message.hasOwnProperty("evaluateJs")) {
			if (properties.answer === 1) return "answer: multiple values";
			properties.answer = 1;
			{
				var error = $root.EvaluateJSAnswer.verify(message.evaluateJs);
				if (error) return "evaluateJs." + error;
			}
		}
		if (message.hashCash != null && message.hasOwnProperty("hashCash")) {
			if (properties.answer === 1) return "answer: multiple values";
			properties.answer = 1;
			{
				var error = $root.HashCashAnswer.verify(message.hashCash);
				if (error) return "hashCash." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a ChallengeAnswer message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ChallengeAnswer} ChallengeAnswer
	 */
	ChallengeAnswer.fromObject = function fromObject(object) {
		if (object instanceof $root.ChallengeAnswer) return object;
		var message = new $root.ChallengeAnswer();
		switch (object.ChallengeType) {
			default:
				if (typeof object.ChallengeType === "number") {
					message.ChallengeType = object.ChallengeType;
					break;
				}
				break;
			case "CHALLENGE_UNKNOWN":
			case 0:
				message.ChallengeType = 0;
				break;
			case "CHALLENGE_CLIENT_SECRET_HMAC":
			case 1:
				message.ChallengeType = 1;
				break;
			case "CHALLENGE_EVALUATE_JS":
			case 2:
				message.ChallengeType = 2;
				break;
			case "CHALLENGE_HASH_CASH":
			case 3:
				message.ChallengeType = 3;
				break;
		}
		if (object.clientSecret != null) {
			if (typeof object.clientSecret !== "object") throw TypeError(".ChallengeAnswer.clientSecret: object expected");
			message.clientSecret = $root.ClientSecretHMACAnswer.fromObject(object.clientSecret);
		}
		if (object.evaluateJs != null) {
			if (typeof object.evaluateJs !== "object") throw TypeError(".ChallengeAnswer.evaluateJs: object expected");
			message.evaluateJs = $root.EvaluateJSAnswer.fromObject(object.evaluateJs);
		}
		if (object.hashCash != null) {
			if (typeof object.hashCash !== "object") throw TypeError(".ChallengeAnswer.hashCash: object expected");
			message.hashCash = $root.HashCashAnswer.fromObject(object.hashCash);
		}
		return message;
	};

	/**
	 * Creates a plain object from a ChallengeAnswer message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {ChallengeAnswer} message ChallengeAnswer
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ChallengeAnswer.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.ChallengeType = options.enums === String ? "CHALLENGE_UNKNOWN" : 0;
		if (message.ChallengeType != null && message.hasOwnProperty("ChallengeType"))
			object.ChallengeType =
				options.enums === String
					? $root.ChallengeType[message.ChallengeType] === undefined
						? message.ChallengeType
						: $root.ChallengeType[message.ChallengeType]
					: message.ChallengeType;
		if (message.clientSecret != null && message.hasOwnProperty("clientSecret")) {
			object.clientSecret = $root.ClientSecretHMACAnswer.toObject(message.clientSecret, options);
			if (options.oneofs) object.answer = "clientSecret";
		}
		if (message.evaluateJs != null && message.hasOwnProperty("evaluateJs")) {
			object.evaluateJs = $root.EvaluateJSAnswer.toObject(message.evaluateJs, options);
			if (options.oneofs) object.answer = "evaluateJs";
		}
		if (message.hashCash != null && message.hasOwnProperty("hashCash")) {
			object.hashCash = $root.HashCashAnswer.toObject(message.hashCash, options);
			if (options.oneofs) object.answer = "hashCash";
		}
		return object;
	};

	/**
	 * Converts this ChallengeAnswer to JSON.
	 * @function toJSON
	 * @memberof ChallengeAnswer
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ChallengeAnswer.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ChallengeAnswer
	 * @function getTypeUrl
	 * @memberof ChallengeAnswer
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ChallengeAnswer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ChallengeAnswer";
	};

	return ChallengeAnswer;
})();

$root.ClientTokenBadRequest = (function () {
	/**
	 * Properties of a ClientTokenBadRequest.
	 * @exports IClientTokenBadRequest
	 * @interface IClientTokenBadRequest
	 * @property {string|null} [message] ClientTokenBadRequest message
	 */

	/**
	 * Constructs a new ClientTokenBadRequest.
	 * @exports ClientTokenBadRequest
	 * @classdesc Represents a ClientTokenBadRequest.
	 * @implements IClientTokenBadRequest
	 * @constructor
	 * @param {IClientTokenBadRequest=} [properties] Properties to set
	 */
	function ClientTokenBadRequest(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientTokenBadRequest message.
	 * @member {string} message
	 * @memberof ClientTokenBadRequest
	 * @instance
	 */
	ClientTokenBadRequest.prototype.message = "";

	/**
	 * Creates a new ClientTokenBadRequest instance using the specified properties.
	 * @function create
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {IClientTokenBadRequest=} [properties] Properties to set
	 * @returns {ClientTokenBadRequest} ClientTokenBadRequest instance
	 */
	ClientTokenBadRequest.create = function create(properties) {
		return new ClientTokenBadRequest(properties);
	};

	/**
	 * Encodes the specified ClientTokenBadRequest message. Does not implicitly {@link ClientTokenBadRequest.verify|verify} messages.
	 * @function encode
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {IClientTokenBadRequest} message ClientTokenBadRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientTokenBadRequest.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.message != null && Object.hasOwnProperty.call(message, "message"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.message);
		return writer;
	};

	/**
	 * Encodes the specified ClientTokenBadRequest message, length delimited. Does not implicitly {@link ClientTokenBadRequest.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {IClientTokenBadRequest} message ClientTokenBadRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientTokenBadRequest.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientTokenBadRequest message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientTokenBadRequest} ClientTokenBadRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientTokenBadRequest.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientTokenBadRequest();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.message = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ClientTokenBadRequest message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientTokenBadRequest} ClientTokenBadRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientTokenBadRequest.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientTokenBadRequest message.
	 * @function verify
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientTokenBadRequest.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.message != null && message.hasOwnProperty("message"))
			if (!$util.isString(message.message)) return "message: string expected";
		return null;
	};

	/**
	 * Creates a ClientTokenBadRequest message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientTokenBadRequest} ClientTokenBadRequest
	 */
	ClientTokenBadRequest.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientTokenBadRequest) return object;
		var message = new $root.ClientTokenBadRequest();
		if (object.message != null) message.message = String(object.message);
		return message;
	};

	/**
	 * Creates a plain object from a ClientTokenBadRequest message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {ClientTokenBadRequest} message ClientTokenBadRequest
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientTokenBadRequest.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.message = "";
		if (message.message != null && message.hasOwnProperty("message")) object.message = message.message;
		return object;
	};

	/**
	 * Converts this ClientTokenBadRequest to JSON.
	 * @function toJSON
	 * @memberof ClientTokenBadRequest
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientTokenBadRequest.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientTokenBadRequest
	 * @function getTypeUrl
	 * @memberof ClientTokenBadRequest
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientTokenBadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientTokenBadRequest";
	};

	return ClientTokenBadRequest;
})();

/**
 * ClientTokenRequestType enum.
 * @exports ClientTokenRequestType
 * @enum {number}
 * @property {number} REQUEST_UNKNOWN=0 REQUEST_UNKNOWN value
 * @property {number} REQUEST_CLIENT_DATA_REQUEST=1 REQUEST_CLIENT_DATA_REQUEST value
 * @property {number} REQUEST_CHALLENGE_ANSWERS_REQUEST=2 REQUEST_CHALLENGE_ANSWERS_REQUEST value
 */
$root.ClientTokenRequestType = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "REQUEST_UNKNOWN")] = 0;
	values[(valuesById[1] = "REQUEST_CLIENT_DATA_REQUEST")] = 1;
	values[(valuesById[2] = "REQUEST_CHALLENGE_ANSWERS_REQUEST")] = 2;
	return values;
})();

/**
 * ClientTokenResponseType enum.
 * @exports ClientTokenResponseType
 * @enum {number}
 * @property {number} RESPONSE_UNKNOWN=0 RESPONSE_UNKNOWN value
 * @property {number} RESPONSE_GRANTED_TOKEN_RESPONSE=1 RESPONSE_GRANTED_TOKEN_RESPONSE value
 * @property {number} RESPONSE_CHALLENGES_RESPONSE=2 RESPONSE_CHALLENGES_RESPONSE value
 */
$root.ClientTokenResponseType = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "RESPONSE_UNKNOWN")] = 0;
	values[(valuesById[1] = "RESPONSE_GRANTED_TOKEN_RESPONSE")] = 1;
	values[(valuesById[2] = "RESPONSE_CHALLENGES_RESPONSE")] = 2;
	return values;
})();

/**
 * ChallengeType enum.
 * @exports ChallengeType
 * @enum {number}
 * @property {number} CHALLENGE_UNKNOWN=0 CHALLENGE_UNKNOWN value
 * @property {number} CHALLENGE_CLIENT_SECRET_HMAC=1 CHALLENGE_CLIENT_SECRET_HMAC value
 * @property {number} CHALLENGE_EVALUATE_JS=2 CHALLENGE_EVALUATE_JS value
 * @property {number} CHALLENGE_HASH_CASH=3 CHALLENGE_HASH_CASH value
 */
$root.ChallengeType = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "CHALLENGE_UNKNOWN")] = 0;
	values[(valuesById[1] = "CHALLENGE_CLIENT_SECRET_HMAC")] = 1;
	values[(valuesById[2] = "CHALLENGE_EVALUATE_JS")] = 2;
	values[(valuesById[3] = "CHALLENGE_HASH_CASH")] = 3;
	return values;
})();

$root.spotify = (function () {
	/**
	 * Namespace spotify.
	 * @exports spotify
	 * @namespace
	 */
	var spotify = {};

	spotify.clienttoken = (function () {
		/**
		 * Namespace clienttoken.
		 * @memberof spotify
		 * @namespace
		 */
		var clienttoken = {};

		clienttoken.data = (function () {
			/**
			 * Namespace data.
			 * @memberof spotify.clienttoken
			 * @namespace
			 */
			var data = {};

			data.v0 = (function () {
				/**
				 * Namespace v0.
				 * @memberof spotify.clienttoken.data
				 * @namespace
				 */
				var v0 = {};

				v0.ConnectivitySdkData = (function () {
					/**
					 * Properties of a ConnectivitySdkData.
					 * @memberof spotify.clienttoken.data.v0
					 * @interface IConnectivitySdkData
					 * @property {spotify.clienttoken.data.v0.IPlatformSpecificData|null} [platformSpecificData] ConnectivitySdkData platformSpecificData
					 * @property {string|null} [deviceId] ConnectivitySdkData deviceId
					 */

					/**
					 * Constructs a new ConnectivitySdkData.
					 * @memberof spotify.clienttoken.data.v0
					 * @classdesc Represents a ConnectivitySdkData.
					 * @implements IConnectivitySdkData
					 * @constructor
					 * @param {spotify.clienttoken.data.v0.IConnectivitySdkData=} [properties] Properties to set
					 */
					function ConnectivitySdkData(properties) {
						if (properties)
							for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
								if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
					}

					/**
					 * ConnectivitySdkData platformSpecificData.
					 * @member {spotify.clienttoken.data.v0.IPlatformSpecificData|null|undefined} platformSpecificData
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @instance
					 */
					ConnectivitySdkData.prototype.platformSpecificData = null;

					/**
					 * ConnectivitySdkData deviceId.
					 * @member {string} deviceId
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @instance
					 */
					ConnectivitySdkData.prototype.deviceId = "";

					/**
					 * Creates a new ConnectivitySdkData instance using the specified properties.
					 * @function create
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {spotify.clienttoken.data.v0.IConnectivitySdkData=} [properties] Properties to set
					 * @returns {spotify.clienttoken.data.v0.ConnectivitySdkData} ConnectivitySdkData instance
					 */
					ConnectivitySdkData.create = function create(properties) {
						return new ConnectivitySdkData(properties);
					};

					/**
					 * Encodes the specified ConnectivitySdkData message. Does not implicitly {@link spotify.clienttoken.data.v0.ConnectivitySdkData.verify|verify} messages.
					 * @function encode
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {spotify.clienttoken.data.v0.IConnectivitySdkData} message ConnectivitySdkData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					ConnectivitySdkData.encode = function encode(message, writer) {
						if (!writer) writer = $Writer.create();
						if (message.platformSpecificData != null && Object.hasOwnProperty.call(message, "platformSpecificData"))
							$root.spotify.clienttoken.data.v0.PlatformSpecificData.encode(
								message.platformSpecificData,
								writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
							).ldelim();
						if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
							writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.deviceId);
						return writer;
					};

					/**
					 * Encodes the specified ConnectivitySdkData message, length delimited. Does not implicitly {@link spotify.clienttoken.data.v0.ConnectivitySdkData.verify|verify} messages.
					 * @function encodeDelimited
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {spotify.clienttoken.data.v0.IConnectivitySdkData} message ConnectivitySdkData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					ConnectivitySdkData.encodeDelimited = function encodeDelimited(message, writer) {
						return this.encode(message, writer).ldelim();
					};

					/**
					 * Decodes a ConnectivitySdkData message from the specified reader or buffer.
					 * @function decode
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @param {number} [length] Message length if known beforehand
					 * @returns {spotify.clienttoken.data.v0.ConnectivitySdkData} ConnectivitySdkData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					ConnectivitySdkData.decode = function decode(reader, length) {
						if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
						var end = length === undefined ? reader.len : reader.pos + length,
							message = new $root.spotify.clienttoken.data.v0.ConnectivitySdkData();
						while (reader.pos < end) {
							var tag = reader.uint32();
							switch (tag >>> 3) {
								case 1: {
									message.platformSpecificData = $root.spotify.clienttoken.data.v0.PlatformSpecificData.decode(
										reader,
										reader.uint32(),
									);
									break;
								}
								case 2: {
									message.deviceId = reader.string();
									break;
								}
								default:
									reader.skipType(tag & 7);
									break;
							}
						}
						return message;
					};

					/**
					 * Decodes a ConnectivitySdkData message from the specified reader or buffer, length delimited.
					 * @function decodeDelimited
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @returns {spotify.clienttoken.data.v0.ConnectivitySdkData} ConnectivitySdkData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					ConnectivitySdkData.decodeDelimited = function decodeDelimited(reader) {
						if (!(reader instanceof $Reader)) reader = new $Reader(reader);
						return this.decode(reader, reader.uint32());
					};

					/**
					 * Verifies a ConnectivitySdkData message.
					 * @function verify
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {Object.<string,*>} message Plain object to verify
					 * @returns {string|null} `null` if valid, otherwise the reason why it is not
					 */
					ConnectivitySdkData.verify = function verify(message) {
						if (typeof message !== "object" || message === null) return "object expected";
						if (message.platformSpecificData != null && message.hasOwnProperty("platformSpecificData")) {
							var error = $root.spotify.clienttoken.data.v0.PlatformSpecificData.verify(message.platformSpecificData);
							if (error) return "platformSpecificData." + error;
						}
						if (message.deviceId != null && message.hasOwnProperty("deviceId"))
							if (!$util.isString(message.deviceId)) return "deviceId: string expected";
						return null;
					};

					/**
					 * Creates a ConnectivitySdkData message from a plain object. Also converts values to their respective internal types.
					 * @function fromObject
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {Object.<string,*>} object Plain object
					 * @returns {spotify.clienttoken.data.v0.ConnectivitySdkData} ConnectivitySdkData
					 */
					ConnectivitySdkData.fromObject = function fromObject(object) {
						if (object instanceof $root.spotify.clienttoken.data.v0.ConnectivitySdkData) return object;
						var message = new $root.spotify.clienttoken.data.v0.ConnectivitySdkData();
						if (object.platformSpecificData != null) {
							if (typeof object.platformSpecificData !== "object")
								throw TypeError(".spotify.clienttoken.data.v0.ConnectivitySdkData.platformSpecificData: object expected");
							message.platformSpecificData = $root.spotify.clienttoken.data.v0.PlatformSpecificData.fromObject(
								object.platformSpecificData,
							);
						}
						if (object.deviceId != null) message.deviceId = String(object.deviceId);
						return message;
					};

					/**
					 * Creates a plain object from a ConnectivitySdkData message. Also converts values to other types if specified.
					 * @function toObject
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {spotify.clienttoken.data.v0.ConnectivitySdkData} message ConnectivitySdkData
					 * @param {$protobuf.IConversionOptions} [options] Conversion options
					 * @returns {Object.<string,*>} Plain object
					 */
					ConnectivitySdkData.toObject = function toObject(message, options) {
						if (!options) options = {};
						var object = {};
						if (options.defaults) {
							object.platformSpecificData = null;
							object.deviceId = "";
						}
						if (message.platformSpecificData != null && message.hasOwnProperty("platformSpecificData"))
							object.platformSpecificData = $root.spotify.clienttoken.data.v0.PlatformSpecificData.toObject(
								message.platformSpecificData,
								options,
							);
						if (message.deviceId != null && message.hasOwnProperty("deviceId")) object.deviceId = message.deviceId;
						return object;
					};

					/**
					 * Converts this ConnectivitySdkData to JSON.
					 * @function toJSON
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @instance
					 * @returns {Object.<string,*>} JSON object
					 */
					ConnectivitySdkData.prototype.toJSON = function toJSON() {
						return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
					};

					/**
					 * Gets the default type url for ConnectivitySdkData
					 * @function getTypeUrl
					 * @memberof spotify.clienttoken.data.v0.ConnectivitySdkData
					 * @static
					 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
					 * @returns {string} The default type url
					 */
					ConnectivitySdkData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
						if (typeUrlPrefix === undefined) {
							typeUrlPrefix = "type.googleapis.com";
						}
						return typeUrlPrefix + "/spotify.clienttoken.data.v0.ConnectivitySdkData";
					};

					return ConnectivitySdkData;
				})();

				v0.PlatformSpecificData = (function () {
					/**
					 * Properties of a PlatformSpecificData.
					 * @memberof spotify.clienttoken.data.v0
					 * @interface IPlatformSpecificData
					 * @property {spotify.clienttoken.data.v0.INativeAndroidData|null} [android] PlatformSpecificData android
					 * @property {spotify.clienttoken.data.v0.INativeIOSData|null} [ios] PlatformSpecificData ios
					 * @property {spotify.clienttoken.data.v0.INativeDesktopMacOSData|null} [desktopMacos] PlatformSpecificData desktopMacos
					 * @property {spotify.clienttoken.data.v0.INativeDesktopWindowsData|null} [desktopWindows] PlatformSpecificData desktopWindows
					 * @property {spotify.clienttoken.data.v0.INativeDesktopLinuxData|null} [desktopLinux] PlatformSpecificData desktopLinux
					 */

					/**
					 * Constructs a new PlatformSpecificData.
					 * @memberof spotify.clienttoken.data.v0
					 * @classdesc Represents a PlatformSpecificData.
					 * @implements IPlatformSpecificData
					 * @constructor
					 * @param {spotify.clienttoken.data.v0.IPlatformSpecificData=} [properties] Properties to set
					 */
					function PlatformSpecificData(properties) {
						if (properties)
							for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
								if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
					}

					/**
					 * PlatformSpecificData android.
					 * @member {spotify.clienttoken.data.v0.INativeAndroidData|null|undefined} android
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @instance
					 */
					PlatformSpecificData.prototype.android = null;

					/**
					 * PlatformSpecificData ios.
					 * @member {spotify.clienttoken.data.v0.INativeIOSData|null|undefined} ios
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @instance
					 */
					PlatformSpecificData.prototype.ios = null;

					/**
					 * PlatformSpecificData desktopMacos.
					 * @member {spotify.clienttoken.data.v0.INativeDesktopMacOSData|null|undefined} desktopMacos
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @instance
					 */
					PlatformSpecificData.prototype.desktopMacos = null;

					/**
					 * PlatformSpecificData desktopWindows.
					 * @member {spotify.clienttoken.data.v0.INativeDesktopWindowsData|null|undefined} desktopWindows
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @instance
					 */
					PlatformSpecificData.prototype.desktopWindows = null;

					/**
					 * PlatformSpecificData desktopLinux.
					 * @member {spotify.clienttoken.data.v0.INativeDesktopLinuxData|null|undefined} desktopLinux
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @instance
					 */
					PlatformSpecificData.prototype.desktopLinux = null;

					// OneOf field names bound to virtual getters and setters
					var $oneOfFields;

					/**
					 * PlatformSpecificData data.
					 * @member {"android"|"ios"|"desktopMacos"|"desktopWindows"|"desktopLinux"|undefined} data
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @instance
					 */
					Object.defineProperty(PlatformSpecificData.prototype, "data", {
						get: $util.oneOfGetter(($oneOfFields = ["android", "ios", "desktopMacos", "desktopWindows", "desktopLinux"])),
						set: $util.oneOfSetter($oneOfFields),
					});

					/**
					 * Creates a new PlatformSpecificData instance using the specified properties.
					 * @function create
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {spotify.clienttoken.data.v0.IPlatformSpecificData=} [properties] Properties to set
					 * @returns {spotify.clienttoken.data.v0.PlatformSpecificData} PlatformSpecificData instance
					 */
					PlatformSpecificData.create = function create(properties) {
						return new PlatformSpecificData(properties);
					};

					/**
					 * Encodes the specified PlatformSpecificData message. Does not implicitly {@link spotify.clienttoken.data.v0.PlatformSpecificData.verify|verify} messages.
					 * @function encode
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {spotify.clienttoken.data.v0.IPlatformSpecificData} message PlatformSpecificData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					PlatformSpecificData.encode = function encode(message, writer) {
						if (!writer) writer = $Writer.create();
						if (message.android != null && Object.hasOwnProperty.call(message, "android"))
							$root.spotify.clienttoken.data.v0.NativeAndroidData.encode(
								message.android,
								writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
							).ldelim();
						if (message.ios != null && Object.hasOwnProperty.call(message, "ios"))
							$root.spotify.clienttoken.data.v0.NativeIOSData.encode(
								message.ios,
								writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
							).ldelim();
						if (message.desktopMacos != null && Object.hasOwnProperty.call(message, "desktopMacos"))
							$root.spotify.clienttoken.data.v0.NativeDesktopMacOSData.encode(
								message.desktopMacos,
								writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
							).ldelim();
						if (message.desktopWindows != null && Object.hasOwnProperty.call(message, "desktopWindows"))
							$root.spotify.clienttoken.data.v0.NativeDesktopWindowsData.encode(
								message.desktopWindows,
								writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
							).ldelim();
						if (message.desktopLinux != null && Object.hasOwnProperty.call(message, "desktopLinux"))
							$root.spotify.clienttoken.data.v0.NativeDesktopLinuxData.encode(
								message.desktopLinux,
								writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
							).ldelim();
						return writer;
					};

					/**
					 * Encodes the specified PlatformSpecificData message, length delimited. Does not implicitly {@link spotify.clienttoken.data.v0.PlatformSpecificData.verify|verify} messages.
					 * @function encodeDelimited
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {spotify.clienttoken.data.v0.IPlatformSpecificData} message PlatformSpecificData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					PlatformSpecificData.encodeDelimited = function encodeDelimited(message, writer) {
						return this.encode(message, writer).ldelim();
					};

					/**
					 * Decodes a PlatformSpecificData message from the specified reader or buffer.
					 * @function decode
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @param {number} [length] Message length if known beforehand
					 * @returns {spotify.clienttoken.data.v0.PlatformSpecificData} PlatformSpecificData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					PlatformSpecificData.decode = function decode(reader, length) {
						if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
						var end = length === undefined ? reader.len : reader.pos + length,
							message = new $root.spotify.clienttoken.data.v0.PlatformSpecificData();
						while (reader.pos < end) {
							var tag = reader.uint32();
							switch (tag >>> 3) {
								case 1: {
									message.android = $root.spotify.clienttoken.data.v0.NativeAndroidData.decode(reader, reader.uint32());
									break;
								}
								case 2: {
									message.ios = $root.spotify.clienttoken.data.v0.NativeIOSData.decode(reader, reader.uint32());
									break;
								}
								case 3: {
									message.desktopMacos = $root.spotify.clienttoken.data.v0.NativeDesktopMacOSData.decode(
										reader,
										reader.uint32(),
									);
									break;
								}
								case 4: {
									message.desktopWindows = $root.spotify.clienttoken.data.v0.NativeDesktopWindowsData.decode(
										reader,
										reader.uint32(),
									);
									break;
								}
								case 5: {
									message.desktopLinux = $root.spotify.clienttoken.data.v0.NativeDesktopLinuxData.decode(
										reader,
										reader.uint32(),
									);
									break;
								}
								default:
									reader.skipType(tag & 7);
									break;
							}
						}
						return message;
					};

					/**
					 * Decodes a PlatformSpecificData message from the specified reader or buffer, length delimited.
					 * @function decodeDelimited
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @returns {spotify.clienttoken.data.v0.PlatformSpecificData} PlatformSpecificData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					PlatformSpecificData.decodeDelimited = function decodeDelimited(reader) {
						if (!(reader instanceof $Reader)) reader = new $Reader(reader);
						return this.decode(reader, reader.uint32());
					};

					/**
					 * Verifies a PlatformSpecificData message.
					 * @function verify
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {Object.<string,*>} message Plain object to verify
					 * @returns {string|null} `null` if valid, otherwise the reason why it is not
					 */
					PlatformSpecificData.verify = function verify(message) {
						if (typeof message !== "object" || message === null) return "object expected";
						var properties = {};
						if (message.android != null && message.hasOwnProperty("android")) {
							properties.data = 1;
							{
								var error = $root.spotify.clienttoken.data.v0.NativeAndroidData.verify(message.android);
								if (error) return "android." + error;
							}
						}
						if (message.ios != null && message.hasOwnProperty("ios")) {
							if (properties.data === 1) return "data: multiple values";
							properties.data = 1;
							{
								var error = $root.spotify.clienttoken.data.v0.NativeIOSData.verify(message.ios);
								if (error) return "ios." + error;
							}
						}
						if (message.desktopMacos != null && message.hasOwnProperty("desktopMacos")) {
							if (properties.data === 1) return "data: multiple values";
							properties.data = 1;
							{
								var error = $root.spotify.clienttoken.data.v0.NativeDesktopMacOSData.verify(message.desktopMacos);
								if (error) return "desktopMacos." + error;
							}
						}
						if (message.desktopWindows != null && message.hasOwnProperty("desktopWindows")) {
							if (properties.data === 1) return "data: multiple values";
							properties.data = 1;
							{
								var error = $root.spotify.clienttoken.data.v0.NativeDesktopWindowsData.verify(message.desktopWindows);
								if (error) return "desktopWindows." + error;
							}
						}
						if (message.desktopLinux != null && message.hasOwnProperty("desktopLinux")) {
							if (properties.data === 1) return "data: multiple values";
							properties.data = 1;
							{
								var error = $root.spotify.clienttoken.data.v0.NativeDesktopLinuxData.verify(message.desktopLinux);
								if (error) return "desktopLinux." + error;
							}
						}
						return null;
					};

					/**
					 * Creates a PlatformSpecificData message from a plain object. Also converts values to their respective internal types.
					 * @function fromObject
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {Object.<string,*>} object Plain object
					 * @returns {spotify.clienttoken.data.v0.PlatformSpecificData} PlatformSpecificData
					 */
					PlatformSpecificData.fromObject = function fromObject(object) {
						if (object instanceof $root.spotify.clienttoken.data.v0.PlatformSpecificData) return object;
						var message = new $root.spotify.clienttoken.data.v0.PlatformSpecificData();
						if (object.android != null) {
							if (typeof object.android !== "object")
								throw TypeError(".spotify.clienttoken.data.v0.PlatformSpecificData.android: object expected");
							message.android = $root.spotify.clienttoken.data.v0.NativeAndroidData.fromObject(object.android);
						}
						if (object.ios != null) {
							if (typeof object.ios !== "object")
								throw TypeError(".spotify.clienttoken.data.v0.PlatformSpecificData.ios: object expected");
							message.ios = $root.spotify.clienttoken.data.v0.NativeIOSData.fromObject(object.ios);
						}
						if (object.desktopMacos != null) {
							if (typeof object.desktopMacos !== "object")
								throw TypeError(".spotify.clienttoken.data.v0.PlatformSpecificData.desktopMacos: object expected");
							message.desktopMacos = $root.spotify.clienttoken.data.v0.NativeDesktopMacOSData.fromObject(object.desktopMacos);
						}
						if (object.desktopWindows != null) {
							if (typeof object.desktopWindows !== "object")
								throw TypeError(".spotify.clienttoken.data.v0.PlatformSpecificData.desktopWindows: object expected");
							message.desktopWindows = $root.spotify.clienttoken.data.v0.NativeDesktopWindowsData.fromObject(
								object.desktopWindows,
							);
						}
						if (object.desktopLinux != null) {
							if (typeof object.desktopLinux !== "object")
								throw TypeError(".spotify.clienttoken.data.v0.PlatformSpecificData.desktopLinux: object expected");
							message.desktopLinux = $root.spotify.clienttoken.data.v0.NativeDesktopLinuxData.fromObject(object.desktopLinux);
						}
						return message;
					};

					/**
					 * Creates a plain object from a PlatformSpecificData message. Also converts values to other types if specified.
					 * @function toObject
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {spotify.clienttoken.data.v0.PlatformSpecificData} message PlatformSpecificData
					 * @param {$protobuf.IConversionOptions} [options] Conversion options
					 * @returns {Object.<string,*>} Plain object
					 */
					PlatformSpecificData.toObject = function toObject(message, options) {
						if (!options) options = {};
						var object = {};
						if (message.android != null && message.hasOwnProperty("android")) {
							object.android = $root.spotify.clienttoken.data.v0.NativeAndroidData.toObject(message.android, options);
							if (options.oneofs) object.data = "android";
						}
						if (message.ios != null && message.hasOwnProperty("ios")) {
							object.ios = $root.spotify.clienttoken.data.v0.NativeIOSData.toObject(message.ios, options);
							if (options.oneofs) object.data = "ios";
						}
						if (message.desktopMacos != null && message.hasOwnProperty("desktopMacos")) {
							object.desktopMacos = $root.spotify.clienttoken.data.v0.NativeDesktopMacOSData.toObject(
								message.desktopMacos,
								options,
							);
							if (options.oneofs) object.data = "desktopMacos";
						}
						if (message.desktopWindows != null && message.hasOwnProperty("desktopWindows")) {
							object.desktopWindows = $root.spotify.clienttoken.data.v0.NativeDesktopWindowsData.toObject(
								message.desktopWindows,
								options,
							);
							if (options.oneofs) object.data = "desktopWindows";
						}
						if (message.desktopLinux != null && message.hasOwnProperty("desktopLinux")) {
							object.desktopLinux = $root.spotify.clienttoken.data.v0.NativeDesktopLinuxData.toObject(
								message.desktopLinux,
								options,
							);
							if (options.oneofs) object.data = "desktopLinux";
						}
						return object;
					};

					/**
					 * Converts this PlatformSpecificData to JSON.
					 * @function toJSON
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @instance
					 * @returns {Object.<string,*>} JSON object
					 */
					PlatformSpecificData.prototype.toJSON = function toJSON() {
						return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
					};

					/**
					 * Gets the default type url for PlatformSpecificData
					 * @function getTypeUrl
					 * @memberof spotify.clienttoken.data.v0.PlatformSpecificData
					 * @static
					 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
					 * @returns {string} The default type url
					 */
					PlatformSpecificData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
						if (typeUrlPrefix === undefined) {
							typeUrlPrefix = "type.googleapis.com";
						}
						return typeUrlPrefix + "/spotify.clienttoken.data.v0.PlatformSpecificData";
					};

					return PlatformSpecificData;
				})();

				v0.NativeAndroidData = (function () {
					/**
					 * Properties of a NativeAndroidData.
					 * @memberof spotify.clienttoken.data.v0
					 * @interface INativeAndroidData
					 * @property {spotify.clienttoken.data.v0.IScreen|null} [screenDimensions] NativeAndroidData screenDimensions
					 * @property {string|null} [androidVersion] NativeAndroidData androidVersion
					 * @property {number|null} [apiVersion] NativeAndroidData apiVersion
					 * @property {string|null} [deviceName] NativeAndroidData deviceName
					 * @property {string|null} [modelStr] NativeAndroidData modelStr
					 * @property {string|null} [vendor] NativeAndroidData vendor
					 * @property {string|null} [vendor_2] NativeAndroidData vendor_2
					 * @property {number|null} [unknownValue_8] NativeAndroidData unknownValue_8
					 */

					/**
					 * Constructs a new NativeAndroidData.
					 * @memberof spotify.clienttoken.data.v0
					 * @classdesc Represents a NativeAndroidData.
					 * @implements INativeAndroidData
					 * @constructor
					 * @param {spotify.clienttoken.data.v0.INativeAndroidData=} [properties] Properties to set
					 */
					function NativeAndroidData(properties) {
						if (properties)
							for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
								if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
					}

					/**
					 * NativeAndroidData screenDimensions.
					 * @member {spotify.clienttoken.data.v0.IScreen|null|undefined} screenDimensions
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 */
					NativeAndroidData.prototype.screenDimensions = null;

					/**
					 * NativeAndroidData androidVersion.
					 * @member {string} androidVersion
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 */
					NativeAndroidData.prototype.androidVersion = "";

					/**
					 * NativeAndroidData apiVersion.
					 * @member {number} apiVersion
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 */
					NativeAndroidData.prototype.apiVersion = 0;

					/**
					 * NativeAndroidData deviceName.
					 * @member {string} deviceName
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 */
					NativeAndroidData.prototype.deviceName = "";

					/**
					 * NativeAndroidData modelStr.
					 * @member {string} modelStr
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 */
					NativeAndroidData.prototype.modelStr = "";

					/**
					 * NativeAndroidData vendor.
					 * @member {string} vendor
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 */
					NativeAndroidData.prototype.vendor = "";

					/**
					 * NativeAndroidData vendor_2.
					 * @member {string} vendor_2
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 */
					NativeAndroidData.prototype.vendor_2 = "";

					/**
					 * NativeAndroidData unknownValue_8.
					 * @member {number} unknownValue_8
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 */
					NativeAndroidData.prototype.unknownValue_8 = 0;

					/**
					 * Creates a new NativeAndroidData instance using the specified properties.
					 * @function create
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeAndroidData=} [properties] Properties to set
					 * @returns {spotify.clienttoken.data.v0.NativeAndroidData} NativeAndroidData instance
					 */
					NativeAndroidData.create = function create(properties) {
						return new NativeAndroidData(properties);
					};

					/**
					 * Encodes the specified NativeAndroidData message. Does not implicitly {@link spotify.clienttoken.data.v0.NativeAndroidData.verify|verify} messages.
					 * @function encode
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeAndroidData} message NativeAndroidData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeAndroidData.encode = function encode(message, writer) {
						if (!writer) writer = $Writer.create();
						if (message.screenDimensions != null && Object.hasOwnProperty.call(message, "screenDimensions"))
							$root.spotify.clienttoken.data.v0.Screen.encode(
								message.screenDimensions,
								writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
							).ldelim();
						if (message.androidVersion != null && Object.hasOwnProperty.call(message, "androidVersion"))
							writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.androidVersion);
						if (message.apiVersion != null && Object.hasOwnProperty.call(message, "apiVersion"))
							writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.apiVersion);
						if (message.deviceName != null && Object.hasOwnProperty.call(message, "deviceName"))
							writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.deviceName);
						if (message.modelStr != null && Object.hasOwnProperty.call(message, "modelStr"))
							writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.modelStr);
						if (message.vendor != null && Object.hasOwnProperty.call(message, "vendor"))
							writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.vendor);
						if (message.vendor_2 != null && Object.hasOwnProperty.call(message, "vendor_2"))
							writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.vendor_2);
						if (message.unknownValue_8 != null && Object.hasOwnProperty.call(message, "unknownValue_8"))
							writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.unknownValue_8);
						return writer;
					};

					/**
					 * Encodes the specified NativeAndroidData message, length delimited. Does not implicitly {@link spotify.clienttoken.data.v0.NativeAndroidData.verify|verify} messages.
					 * @function encodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeAndroidData} message NativeAndroidData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeAndroidData.encodeDelimited = function encodeDelimited(message, writer) {
						return this.encode(message, writer).ldelim();
					};

					/**
					 * Decodes a NativeAndroidData message from the specified reader or buffer.
					 * @function decode
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @param {number} [length] Message length if known beforehand
					 * @returns {spotify.clienttoken.data.v0.NativeAndroidData} NativeAndroidData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeAndroidData.decode = function decode(reader, length) {
						if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
						var end = length === undefined ? reader.len : reader.pos + length,
							message = new $root.spotify.clienttoken.data.v0.NativeAndroidData();
						while (reader.pos < end) {
							var tag = reader.uint32();
							switch (tag >>> 3) {
								case 1: {
									message.screenDimensions = $root.spotify.clienttoken.data.v0.Screen.decode(reader, reader.uint32());
									break;
								}
								case 2: {
									message.androidVersion = reader.string();
									break;
								}
								case 3: {
									message.apiVersion = reader.int32();
									break;
								}
								case 4: {
									message.deviceName = reader.string();
									break;
								}
								case 5: {
									message.modelStr = reader.string();
									break;
								}
								case 6: {
									message.vendor = reader.string();
									break;
								}
								case 7: {
									message.vendor_2 = reader.string();
									break;
								}
								case 8: {
									message.unknownValue_8 = reader.int32();
									break;
								}
								default:
									reader.skipType(tag & 7);
									break;
							}
						}
						return message;
					};

					/**
					 * Decodes a NativeAndroidData message from the specified reader or buffer, length delimited.
					 * @function decodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @returns {spotify.clienttoken.data.v0.NativeAndroidData} NativeAndroidData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeAndroidData.decodeDelimited = function decodeDelimited(reader) {
						if (!(reader instanceof $Reader)) reader = new $Reader(reader);
						return this.decode(reader, reader.uint32());
					};

					/**
					 * Verifies a NativeAndroidData message.
					 * @function verify
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {Object.<string,*>} message Plain object to verify
					 * @returns {string|null} `null` if valid, otherwise the reason why it is not
					 */
					NativeAndroidData.verify = function verify(message) {
						if (typeof message !== "object" || message === null) return "object expected";
						if (message.screenDimensions != null && message.hasOwnProperty("screenDimensions")) {
							var error = $root.spotify.clienttoken.data.v0.Screen.verify(message.screenDimensions);
							if (error) return "screenDimensions." + error;
						}
						if (message.androidVersion != null && message.hasOwnProperty("androidVersion"))
							if (!$util.isString(message.androidVersion)) return "androidVersion: string expected";
						if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
							if (!$util.isInteger(message.apiVersion)) return "apiVersion: integer expected";
						if (message.deviceName != null && message.hasOwnProperty("deviceName"))
							if (!$util.isString(message.deviceName)) return "deviceName: string expected";
						if (message.modelStr != null && message.hasOwnProperty("modelStr"))
							if (!$util.isString(message.modelStr)) return "modelStr: string expected";
						if (message.vendor != null && message.hasOwnProperty("vendor"))
							if (!$util.isString(message.vendor)) return "vendor: string expected";
						if (message.vendor_2 != null && message.hasOwnProperty("vendor_2"))
							if (!$util.isString(message.vendor_2)) return "vendor_2: string expected";
						if (message.unknownValue_8 != null && message.hasOwnProperty("unknownValue_8"))
							if (!$util.isInteger(message.unknownValue_8)) return "unknownValue_8: integer expected";
						return null;
					};

					/**
					 * Creates a NativeAndroidData message from a plain object. Also converts values to their respective internal types.
					 * @function fromObject
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {Object.<string,*>} object Plain object
					 * @returns {spotify.clienttoken.data.v0.NativeAndroidData} NativeAndroidData
					 */
					NativeAndroidData.fromObject = function fromObject(object) {
						if (object instanceof $root.spotify.clienttoken.data.v0.NativeAndroidData) return object;
						var message = new $root.spotify.clienttoken.data.v0.NativeAndroidData();
						if (object.screenDimensions != null) {
							if (typeof object.screenDimensions !== "object")
								throw TypeError(".spotify.clienttoken.data.v0.NativeAndroidData.screenDimensions: object expected");
							message.screenDimensions = $root.spotify.clienttoken.data.v0.Screen.fromObject(object.screenDimensions);
						}
						if (object.androidVersion != null) message.androidVersion = String(object.androidVersion);
						if (object.apiVersion != null) message.apiVersion = object.apiVersion | 0;
						if (object.deviceName != null) message.deviceName = String(object.deviceName);
						if (object.modelStr != null) message.modelStr = String(object.modelStr);
						if (object.vendor != null) message.vendor = String(object.vendor);
						if (object.vendor_2 != null) message.vendor_2 = String(object.vendor_2);
						if (object.unknownValue_8 != null) message.unknownValue_8 = object.unknownValue_8 | 0;
						return message;
					};

					/**
					 * Creates a plain object from a NativeAndroidData message. Also converts values to other types if specified.
					 * @function toObject
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {spotify.clienttoken.data.v0.NativeAndroidData} message NativeAndroidData
					 * @param {$protobuf.IConversionOptions} [options] Conversion options
					 * @returns {Object.<string,*>} Plain object
					 */
					NativeAndroidData.toObject = function toObject(message, options) {
						if (!options) options = {};
						var object = {};
						if (options.defaults) {
							object.screenDimensions = null;
							object.androidVersion = "";
							object.apiVersion = 0;
							object.deviceName = "";
							object.modelStr = "";
							object.vendor = "";
							object.vendor_2 = "";
							object.unknownValue_8 = 0;
						}
						if (message.screenDimensions != null && message.hasOwnProperty("screenDimensions"))
							object.screenDimensions = $root.spotify.clienttoken.data.v0.Screen.toObject(message.screenDimensions, options);
						if (message.androidVersion != null && message.hasOwnProperty("androidVersion"))
							object.androidVersion = message.androidVersion;
						if (message.apiVersion != null && message.hasOwnProperty("apiVersion")) object.apiVersion = message.apiVersion;
						if (message.deviceName != null && message.hasOwnProperty("deviceName")) object.deviceName = message.deviceName;
						if (message.modelStr != null && message.hasOwnProperty("modelStr")) object.modelStr = message.modelStr;
						if (message.vendor != null && message.hasOwnProperty("vendor")) object.vendor = message.vendor;
						if (message.vendor_2 != null && message.hasOwnProperty("vendor_2")) object.vendor_2 = message.vendor_2;
						if (message.unknownValue_8 != null && message.hasOwnProperty("unknownValue_8"))
							object.unknownValue_8 = message.unknownValue_8;
						return object;
					};

					/**
					 * Converts this NativeAndroidData to JSON.
					 * @function toJSON
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @instance
					 * @returns {Object.<string,*>} JSON object
					 */
					NativeAndroidData.prototype.toJSON = function toJSON() {
						return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
					};

					/**
					 * Gets the default type url for NativeAndroidData
					 * @function getTypeUrl
					 * @memberof spotify.clienttoken.data.v0.NativeAndroidData
					 * @static
					 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
					 * @returns {string} The default type url
					 */
					NativeAndroidData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
						if (typeUrlPrefix === undefined) {
							typeUrlPrefix = "type.googleapis.com";
						}
						return typeUrlPrefix + "/spotify.clienttoken.data.v0.NativeAndroidData";
					};

					return NativeAndroidData;
				})();

				v0.NativeIOSData = (function () {
					/**
					 * Properties of a NativeIOSData.
					 * @memberof spotify.clienttoken.data.v0
					 * @interface INativeIOSData
					 * @property {number|null} [userInterfaceIdiom] NativeIOSData userInterfaceIdiom
					 * @property {boolean|null} [targetIphoneSimulator] NativeIOSData targetIphoneSimulator
					 * @property {string|null} [hwMachine] NativeIOSData hwMachine
					 * @property {string|null} [systemVersion] NativeIOSData systemVersion
					 * @property {string|null} [simulatorModelIdentifier] NativeIOSData simulatorModelIdentifier
					 */

					/**
					 * Constructs a new NativeIOSData.
					 * @memberof spotify.clienttoken.data.v0
					 * @classdesc Represents a NativeIOSData.
					 * @implements INativeIOSData
					 * @constructor
					 * @param {spotify.clienttoken.data.v0.INativeIOSData=} [properties] Properties to set
					 */
					function NativeIOSData(properties) {
						if (properties)
							for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
								if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
					}

					/**
					 * NativeIOSData userInterfaceIdiom.
					 * @member {number} userInterfaceIdiom
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @instance
					 */
					NativeIOSData.prototype.userInterfaceIdiom = 0;

					/**
					 * NativeIOSData targetIphoneSimulator.
					 * @member {boolean} targetIphoneSimulator
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @instance
					 */
					NativeIOSData.prototype.targetIphoneSimulator = false;

					/**
					 * NativeIOSData hwMachine.
					 * @member {string} hwMachine
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @instance
					 */
					NativeIOSData.prototype.hwMachine = "";

					/**
					 * NativeIOSData systemVersion.
					 * @member {string} systemVersion
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @instance
					 */
					NativeIOSData.prototype.systemVersion = "";

					/**
					 * NativeIOSData simulatorModelIdentifier.
					 * @member {string} simulatorModelIdentifier
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @instance
					 */
					NativeIOSData.prototype.simulatorModelIdentifier = "";

					/**
					 * Creates a new NativeIOSData instance using the specified properties.
					 * @function create
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeIOSData=} [properties] Properties to set
					 * @returns {spotify.clienttoken.data.v0.NativeIOSData} NativeIOSData instance
					 */
					NativeIOSData.create = function create(properties) {
						return new NativeIOSData(properties);
					};

					/**
					 * Encodes the specified NativeIOSData message. Does not implicitly {@link spotify.clienttoken.data.v0.NativeIOSData.verify|verify} messages.
					 * @function encode
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeIOSData} message NativeIOSData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeIOSData.encode = function encode(message, writer) {
						if (!writer) writer = $Writer.create();
						if (message.userInterfaceIdiom != null && Object.hasOwnProperty.call(message, "userInterfaceIdiom"))
							writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.userInterfaceIdiom);
						if (message.targetIphoneSimulator != null && Object.hasOwnProperty.call(message, "targetIphoneSimulator"))
							writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.targetIphoneSimulator);
						if (message.hwMachine != null && Object.hasOwnProperty.call(message, "hwMachine"))
							writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.hwMachine);
						if (message.systemVersion != null && Object.hasOwnProperty.call(message, "systemVersion"))
							writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.systemVersion);
						if (message.simulatorModelIdentifier != null && Object.hasOwnProperty.call(message, "simulatorModelIdentifier"))
							writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.simulatorModelIdentifier);
						return writer;
					};

					/**
					 * Encodes the specified NativeIOSData message, length delimited. Does not implicitly {@link spotify.clienttoken.data.v0.NativeIOSData.verify|verify} messages.
					 * @function encodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeIOSData} message NativeIOSData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeIOSData.encodeDelimited = function encodeDelimited(message, writer) {
						return this.encode(message, writer).ldelim();
					};

					/**
					 * Decodes a NativeIOSData message from the specified reader or buffer.
					 * @function decode
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @param {number} [length] Message length if known beforehand
					 * @returns {spotify.clienttoken.data.v0.NativeIOSData} NativeIOSData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeIOSData.decode = function decode(reader, length) {
						if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
						var end = length === undefined ? reader.len : reader.pos + length,
							message = new $root.spotify.clienttoken.data.v0.NativeIOSData();
						while (reader.pos < end) {
							var tag = reader.uint32();
							switch (tag >>> 3) {
								case 1: {
									message.userInterfaceIdiom = reader.int32();
									break;
								}
								case 2: {
									message.targetIphoneSimulator = reader.bool();
									break;
								}
								case 3: {
									message.hwMachine = reader.string();
									break;
								}
								case 4: {
									message.systemVersion = reader.string();
									break;
								}
								case 5: {
									message.simulatorModelIdentifier = reader.string();
									break;
								}
								default:
									reader.skipType(tag & 7);
									break;
							}
						}
						return message;
					};

					/**
					 * Decodes a NativeIOSData message from the specified reader or buffer, length delimited.
					 * @function decodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @returns {spotify.clienttoken.data.v0.NativeIOSData} NativeIOSData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeIOSData.decodeDelimited = function decodeDelimited(reader) {
						if (!(reader instanceof $Reader)) reader = new $Reader(reader);
						return this.decode(reader, reader.uint32());
					};

					/**
					 * Verifies a NativeIOSData message.
					 * @function verify
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {Object.<string,*>} message Plain object to verify
					 * @returns {string|null} `null` if valid, otherwise the reason why it is not
					 */
					NativeIOSData.verify = function verify(message) {
						if (typeof message !== "object" || message === null) return "object expected";
						if (message.userInterfaceIdiom != null && message.hasOwnProperty("userInterfaceIdiom"))
							if (!$util.isInteger(message.userInterfaceIdiom)) return "userInterfaceIdiom: integer expected";
						if (message.targetIphoneSimulator != null && message.hasOwnProperty("targetIphoneSimulator"))
							if (typeof message.targetIphoneSimulator !== "boolean") return "targetIphoneSimulator: boolean expected";
						if (message.hwMachine != null && message.hasOwnProperty("hwMachine"))
							if (!$util.isString(message.hwMachine)) return "hwMachine: string expected";
						if (message.systemVersion != null && message.hasOwnProperty("systemVersion"))
							if (!$util.isString(message.systemVersion)) return "systemVersion: string expected";
						if (message.simulatorModelIdentifier != null && message.hasOwnProperty("simulatorModelIdentifier"))
							if (!$util.isString(message.simulatorModelIdentifier)) return "simulatorModelIdentifier: string expected";
						return null;
					};

					/**
					 * Creates a NativeIOSData message from a plain object. Also converts values to their respective internal types.
					 * @function fromObject
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {Object.<string,*>} object Plain object
					 * @returns {spotify.clienttoken.data.v0.NativeIOSData} NativeIOSData
					 */
					NativeIOSData.fromObject = function fromObject(object) {
						if (object instanceof $root.spotify.clienttoken.data.v0.NativeIOSData) return object;
						var message = new $root.spotify.clienttoken.data.v0.NativeIOSData();
						if (object.userInterfaceIdiom != null) message.userInterfaceIdiom = object.userInterfaceIdiom | 0;
						if (object.targetIphoneSimulator != null) message.targetIphoneSimulator = Boolean(object.targetIphoneSimulator);
						if (object.hwMachine != null) message.hwMachine = String(object.hwMachine);
						if (object.systemVersion != null) message.systemVersion = String(object.systemVersion);
						if (object.simulatorModelIdentifier != null)
							message.simulatorModelIdentifier = String(object.simulatorModelIdentifier);
						return message;
					};

					/**
					 * Creates a plain object from a NativeIOSData message. Also converts values to other types if specified.
					 * @function toObject
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {spotify.clienttoken.data.v0.NativeIOSData} message NativeIOSData
					 * @param {$protobuf.IConversionOptions} [options] Conversion options
					 * @returns {Object.<string,*>} Plain object
					 */
					NativeIOSData.toObject = function toObject(message, options) {
						if (!options) options = {};
						var object = {};
						if (options.defaults) {
							object.userInterfaceIdiom = 0;
							object.targetIphoneSimulator = false;
							object.hwMachine = "";
							object.systemVersion = "";
							object.simulatorModelIdentifier = "";
						}
						if (message.userInterfaceIdiom != null && message.hasOwnProperty("userInterfaceIdiom"))
							object.userInterfaceIdiom = message.userInterfaceIdiom;
						if (message.targetIphoneSimulator != null && message.hasOwnProperty("targetIphoneSimulator"))
							object.targetIphoneSimulator = message.targetIphoneSimulator;
						if (message.hwMachine != null && message.hasOwnProperty("hwMachine")) object.hwMachine = message.hwMachine;
						if (message.systemVersion != null && message.hasOwnProperty("systemVersion"))
							object.systemVersion = message.systemVersion;
						if (message.simulatorModelIdentifier != null && message.hasOwnProperty("simulatorModelIdentifier"))
							object.simulatorModelIdentifier = message.simulatorModelIdentifier;
						return object;
					};

					/**
					 * Converts this NativeIOSData to JSON.
					 * @function toJSON
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @instance
					 * @returns {Object.<string,*>} JSON object
					 */
					NativeIOSData.prototype.toJSON = function toJSON() {
						return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
					};

					/**
					 * Gets the default type url for NativeIOSData
					 * @function getTypeUrl
					 * @memberof spotify.clienttoken.data.v0.NativeIOSData
					 * @static
					 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
					 * @returns {string} The default type url
					 */
					NativeIOSData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
						if (typeUrlPrefix === undefined) {
							typeUrlPrefix = "type.googleapis.com";
						}
						return typeUrlPrefix + "/spotify.clienttoken.data.v0.NativeIOSData";
					};

					return NativeIOSData;
				})();

				v0.NativeDesktopWindowsData = (function () {
					/**
					 * Properties of a NativeDesktopWindowsData.
					 * @memberof spotify.clienttoken.data.v0
					 * @interface INativeDesktopWindowsData
					 * @property {number|null} [osVersion] NativeDesktopWindowsData osVersion
					 * @property {number|null} [osBuild] NativeDesktopWindowsData osBuild
					 * @property {number|null} [platformId] NativeDesktopWindowsData platformId
					 * @property {number|null} [unknownValue_5] NativeDesktopWindowsData unknownValue_5
					 * @property {number|null} [unknownValue_6] NativeDesktopWindowsData unknownValue_6
					 * @property {number|null} [imageFileMachine] NativeDesktopWindowsData imageFileMachine
					 * @property {number|null} [peMachine] NativeDesktopWindowsData peMachine
					 * @property {boolean|null} [unknownValue_10] NativeDesktopWindowsData unknownValue_10
					 */

					/**
					 * Constructs a new NativeDesktopWindowsData.
					 * @memberof spotify.clienttoken.data.v0
					 * @classdesc Represents a NativeDesktopWindowsData.
					 * @implements INativeDesktopWindowsData
					 * @constructor
					 * @param {spotify.clienttoken.data.v0.INativeDesktopWindowsData=} [properties] Properties to set
					 */
					function NativeDesktopWindowsData(properties) {
						if (properties)
							for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
								if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
					}

					/**
					 * NativeDesktopWindowsData osVersion.
					 * @member {number} osVersion
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 */
					NativeDesktopWindowsData.prototype.osVersion = 0;

					/**
					 * NativeDesktopWindowsData osBuild.
					 * @member {number} osBuild
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 */
					NativeDesktopWindowsData.prototype.osBuild = 0;

					/**
					 * NativeDesktopWindowsData platformId.
					 * @member {number} platformId
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 */
					NativeDesktopWindowsData.prototype.platformId = 0;

					/**
					 * NativeDesktopWindowsData unknownValue_5.
					 * @member {number} unknownValue_5
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 */
					NativeDesktopWindowsData.prototype.unknownValue_5 = 0;

					/**
					 * NativeDesktopWindowsData unknownValue_6.
					 * @member {number} unknownValue_6
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 */
					NativeDesktopWindowsData.prototype.unknownValue_6 = 0;

					/**
					 * NativeDesktopWindowsData imageFileMachine.
					 * @member {number} imageFileMachine
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 */
					NativeDesktopWindowsData.prototype.imageFileMachine = 0;

					/**
					 * NativeDesktopWindowsData peMachine.
					 * @member {number} peMachine
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 */
					NativeDesktopWindowsData.prototype.peMachine = 0;

					/**
					 * NativeDesktopWindowsData unknownValue_10.
					 * @member {boolean} unknownValue_10
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 */
					NativeDesktopWindowsData.prototype.unknownValue_10 = false;

					/**
					 * Creates a new NativeDesktopWindowsData instance using the specified properties.
					 * @function create
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopWindowsData=} [properties] Properties to set
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopWindowsData} NativeDesktopWindowsData instance
					 */
					NativeDesktopWindowsData.create = function create(properties) {
						return new NativeDesktopWindowsData(properties);
					};

					/**
					 * Encodes the specified NativeDesktopWindowsData message. Does not implicitly {@link spotify.clienttoken.data.v0.NativeDesktopWindowsData.verify|verify} messages.
					 * @function encode
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopWindowsData} message NativeDesktopWindowsData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeDesktopWindowsData.encode = function encode(message, writer) {
						if (!writer) writer = $Writer.create();
						if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
							writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.osVersion);
						if (message.osBuild != null && Object.hasOwnProperty.call(message, "osBuild"))
							writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.osBuild);
						if (message.platformId != null && Object.hasOwnProperty.call(message, "platformId"))
							writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.platformId);
						if (message.unknownValue_5 != null && Object.hasOwnProperty.call(message, "unknownValue_5"))
							writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.unknownValue_5);
						if (message.unknownValue_6 != null && Object.hasOwnProperty.call(message, "unknownValue_6"))
							writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.unknownValue_6);
						if (message.imageFileMachine != null && Object.hasOwnProperty.call(message, "imageFileMachine"))
							writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.imageFileMachine);
						if (message.peMachine != null && Object.hasOwnProperty.call(message, "peMachine"))
							writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.peMachine);
						if (message.unknownValue_10 != null && Object.hasOwnProperty.call(message, "unknownValue_10"))
							writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.unknownValue_10);
						return writer;
					};

					/**
					 * Encodes the specified NativeDesktopWindowsData message, length delimited. Does not implicitly {@link spotify.clienttoken.data.v0.NativeDesktopWindowsData.verify|verify} messages.
					 * @function encodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopWindowsData} message NativeDesktopWindowsData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeDesktopWindowsData.encodeDelimited = function encodeDelimited(message, writer) {
						return this.encode(message, writer).ldelim();
					};

					/**
					 * Decodes a NativeDesktopWindowsData message from the specified reader or buffer.
					 * @function decode
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @param {number} [length] Message length if known beforehand
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopWindowsData} NativeDesktopWindowsData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeDesktopWindowsData.decode = function decode(reader, length) {
						if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
						var end = length === undefined ? reader.len : reader.pos + length,
							message = new $root.spotify.clienttoken.data.v0.NativeDesktopWindowsData();
						while (reader.pos < end) {
							var tag = reader.uint32();
							switch (tag >>> 3) {
								case 1: {
									message.osVersion = reader.int32();
									break;
								}
								case 3: {
									message.osBuild = reader.int32();
									break;
								}
								case 4: {
									message.platformId = reader.int32();
									break;
								}
								case 5: {
									message.unknownValue_5 = reader.int32();
									break;
								}
								case 6: {
									message.unknownValue_6 = reader.int32();
									break;
								}
								case 7: {
									message.imageFileMachine = reader.int32();
									break;
								}
								case 8: {
									message.peMachine = reader.int32();
									break;
								}
								case 10: {
									message.unknownValue_10 = reader.bool();
									break;
								}
								default:
									reader.skipType(tag & 7);
									break;
							}
						}
						return message;
					};

					/**
					 * Decodes a NativeDesktopWindowsData message from the specified reader or buffer, length delimited.
					 * @function decodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopWindowsData} NativeDesktopWindowsData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeDesktopWindowsData.decodeDelimited = function decodeDelimited(reader) {
						if (!(reader instanceof $Reader)) reader = new $Reader(reader);
						return this.decode(reader, reader.uint32());
					};

					/**
					 * Verifies a NativeDesktopWindowsData message.
					 * @function verify
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {Object.<string,*>} message Plain object to verify
					 * @returns {string|null} `null` if valid, otherwise the reason why it is not
					 */
					NativeDesktopWindowsData.verify = function verify(message) {
						if (typeof message !== "object" || message === null) return "object expected";
						if (message.osVersion != null && message.hasOwnProperty("osVersion"))
							if (!$util.isInteger(message.osVersion)) return "osVersion: integer expected";
						if (message.osBuild != null && message.hasOwnProperty("osBuild"))
							if (!$util.isInteger(message.osBuild)) return "osBuild: integer expected";
						if (message.platformId != null && message.hasOwnProperty("platformId"))
							if (!$util.isInteger(message.platformId)) return "platformId: integer expected";
						if (message.unknownValue_5 != null && message.hasOwnProperty("unknownValue_5"))
							if (!$util.isInteger(message.unknownValue_5)) return "unknownValue_5: integer expected";
						if (message.unknownValue_6 != null && message.hasOwnProperty("unknownValue_6"))
							if (!$util.isInteger(message.unknownValue_6)) return "unknownValue_6: integer expected";
						if (message.imageFileMachine != null && message.hasOwnProperty("imageFileMachine"))
							if (!$util.isInteger(message.imageFileMachine)) return "imageFileMachine: integer expected";
						if (message.peMachine != null && message.hasOwnProperty("peMachine"))
							if (!$util.isInteger(message.peMachine)) return "peMachine: integer expected";
						if (message.unknownValue_10 != null && message.hasOwnProperty("unknownValue_10"))
							if (typeof message.unknownValue_10 !== "boolean") return "unknownValue_10: boolean expected";
						return null;
					};

					/**
					 * Creates a NativeDesktopWindowsData message from a plain object. Also converts values to their respective internal types.
					 * @function fromObject
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {Object.<string,*>} object Plain object
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopWindowsData} NativeDesktopWindowsData
					 */
					NativeDesktopWindowsData.fromObject = function fromObject(object) {
						if (object instanceof $root.spotify.clienttoken.data.v0.NativeDesktopWindowsData) return object;
						var message = new $root.spotify.clienttoken.data.v0.NativeDesktopWindowsData();
						if (object.osVersion != null) message.osVersion = object.osVersion | 0;
						if (object.osBuild != null) message.osBuild = object.osBuild | 0;
						if (object.platformId != null) message.platformId = object.platformId | 0;
						if (object.unknownValue_5 != null) message.unknownValue_5 = object.unknownValue_5 | 0;
						if (object.unknownValue_6 != null) message.unknownValue_6 = object.unknownValue_6 | 0;
						if (object.imageFileMachine != null) message.imageFileMachine = object.imageFileMachine | 0;
						if (object.peMachine != null) message.peMachine = object.peMachine | 0;
						if (object.unknownValue_10 != null) message.unknownValue_10 = Boolean(object.unknownValue_10);
						return message;
					};

					/**
					 * Creates a plain object from a NativeDesktopWindowsData message. Also converts values to other types if specified.
					 * @function toObject
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {spotify.clienttoken.data.v0.NativeDesktopWindowsData} message NativeDesktopWindowsData
					 * @param {$protobuf.IConversionOptions} [options] Conversion options
					 * @returns {Object.<string,*>} Plain object
					 */
					NativeDesktopWindowsData.toObject = function toObject(message, options) {
						if (!options) options = {};
						var object = {};
						if (options.defaults) {
							object.osVersion = 0;
							object.osBuild = 0;
							object.platformId = 0;
							object.unknownValue_5 = 0;
							object.unknownValue_6 = 0;
							object.imageFileMachine = 0;
							object.peMachine = 0;
							object.unknownValue_10 = false;
						}
						if (message.osVersion != null && message.hasOwnProperty("osVersion")) object.osVersion = message.osVersion;
						if (message.osBuild != null && message.hasOwnProperty("osBuild")) object.osBuild = message.osBuild;
						if (message.platformId != null && message.hasOwnProperty("platformId")) object.platformId = message.platformId;
						if (message.unknownValue_5 != null && message.hasOwnProperty("unknownValue_5"))
							object.unknownValue_5 = message.unknownValue_5;
						if (message.unknownValue_6 != null && message.hasOwnProperty("unknownValue_6"))
							object.unknownValue_6 = message.unknownValue_6;
						if (message.imageFileMachine != null && message.hasOwnProperty("imageFileMachine"))
							object.imageFileMachine = message.imageFileMachine;
						if (message.peMachine != null && message.hasOwnProperty("peMachine")) object.peMachine = message.peMachine;
						if (message.unknownValue_10 != null && message.hasOwnProperty("unknownValue_10"))
							object.unknownValue_10 = message.unknownValue_10;
						return object;
					};

					/**
					 * Converts this NativeDesktopWindowsData to JSON.
					 * @function toJSON
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @instance
					 * @returns {Object.<string,*>} JSON object
					 */
					NativeDesktopWindowsData.prototype.toJSON = function toJSON() {
						return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
					};

					/**
					 * Gets the default type url for NativeDesktopWindowsData
					 * @function getTypeUrl
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopWindowsData
					 * @static
					 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
					 * @returns {string} The default type url
					 */
					NativeDesktopWindowsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
						if (typeUrlPrefix === undefined) {
							typeUrlPrefix = "type.googleapis.com";
						}
						return typeUrlPrefix + "/spotify.clienttoken.data.v0.NativeDesktopWindowsData";
					};

					return NativeDesktopWindowsData;
				})();

				v0.NativeDesktopLinuxData = (function () {
					/**
					 * Properties of a NativeDesktopLinuxData.
					 * @memberof spotify.clienttoken.data.v0
					 * @interface INativeDesktopLinuxData
					 * @property {string|null} [systemName] NativeDesktopLinuxData systemName
					 * @property {string|null} [systemRelease] NativeDesktopLinuxData systemRelease
					 * @property {string|null} [systemVersion] NativeDesktopLinuxData systemVersion
					 * @property {string|null} [hardware] NativeDesktopLinuxData hardware
					 */

					/**
					 * Constructs a new NativeDesktopLinuxData.
					 * @memberof spotify.clienttoken.data.v0
					 * @classdesc Represents a NativeDesktopLinuxData.
					 * @implements INativeDesktopLinuxData
					 * @constructor
					 * @param {spotify.clienttoken.data.v0.INativeDesktopLinuxData=} [properties] Properties to set
					 */
					function NativeDesktopLinuxData(properties) {
						if (properties)
							for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
								if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
					}

					/**
					 * NativeDesktopLinuxData systemName.
					 * @member {string} systemName
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @instance
					 */
					NativeDesktopLinuxData.prototype.systemName = "";

					/**
					 * NativeDesktopLinuxData systemRelease.
					 * @member {string} systemRelease
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @instance
					 */
					NativeDesktopLinuxData.prototype.systemRelease = "";

					/**
					 * NativeDesktopLinuxData systemVersion.
					 * @member {string} systemVersion
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @instance
					 */
					NativeDesktopLinuxData.prototype.systemVersion = "";

					/**
					 * NativeDesktopLinuxData hardware.
					 * @member {string} hardware
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @instance
					 */
					NativeDesktopLinuxData.prototype.hardware = "";

					/**
					 * Creates a new NativeDesktopLinuxData instance using the specified properties.
					 * @function create
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopLinuxData=} [properties] Properties to set
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopLinuxData} NativeDesktopLinuxData instance
					 */
					NativeDesktopLinuxData.create = function create(properties) {
						return new NativeDesktopLinuxData(properties);
					};

					/**
					 * Encodes the specified NativeDesktopLinuxData message. Does not implicitly {@link spotify.clienttoken.data.v0.NativeDesktopLinuxData.verify|verify} messages.
					 * @function encode
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopLinuxData} message NativeDesktopLinuxData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeDesktopLinuxData.encode = function encode(message, writer) {
						if (!writer) writer = $Writer.create();
						if (message.systemName != null && Object.hasOwnProperty.call(message, "systemName"))
							writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.systemName);
						if (message.systemRelease != null && Object.hasOwnProperty.call(message, "systemRelease"))
							writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.systemRelease);
						if (message.systemVersion != null && Object.hasOwnProperty.call(message, "systemVersion"))
							writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.systemVersion);
						if (message.hardware != null && Object.hasOwnProperty.call(message, "hardware"))
							writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.hardware);
						return writer;
					};

					/**
					 * Encodes the specified NativeDesktopLinuxData message, length delimited. Does not implicitly {@link spotify.clienttoken.data.v0.NativeDesktopLinuxData.verify|verify} messages.
					 * @function encodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopLinuxData} message NativeDesktopLinuxData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeDesktopLinuxData.encodeDelimited = function encodeDelimited(message, writer) {
						return this.encode(message, writer).ldelim();
					};

					/**
					 * Decodes a NativeDesktopLinuxData message from the specified reader or buffer.
					 * @function decode
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @param {number} [length] Message length if known beforehand
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopLinuxData} NativeDesktopLinuxData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeDesktopLinuxData.decode = function decode(reader, length) {
						if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
						var end = length === undefined ? reader.len : reader.pos + length,
							message = new $root.spotify.clienttoken.data.v0.NativeDesktopLinuxData();
						while (reader.pos < end) {
							var tag = reader.uint32();
							switch (tag >>> 3) {
								case 1: {
									message.systemName = reader.string();
									break;
								}
								case 2: {
									message.systemRelease = reader.string();
									break;
								}
								case 3: {
									message.systemVersion = reader.string();
									break;
								}
								case 4: {
									message.hardware = reader.string();
									break;
								}
								default:
									reader.skipType(tag & 7);
									break;
							}
						}
						return message;
					};

					/**
					 * Decodes a NativeDesktopLinuxData message from the specified reader or buffer, length delimited.
					 * @function decodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopLinuxData} NativeDesktopLinuxData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeDesktopLinuxData.decodeDelimited = function decodeDelimited(reader) {
						if (!(reader instanceof $Reader)) reader = new $Reader(reader);
						return this.decode(reader, reader.uint32());
					};

					/**
					 * Verifies a NativeDesktopLinuxData message.
					 * @function verify
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {Object.<string,*>} message Plain object to verify
					 * @returns {string|null} `null` if valid, otherwise the reason why it is not
					 */
					NativeDesktopLinuxData.verify = function verify(message) {
						if (typeof message !== "object" || message === null) return "object expected";
						if (message.systemName != null && message.hasOwnProperty("systemName"))
							if (!$util.isString(message.systemName)) return "systemName: string expected";
						if (message.systemRelease != null && message.hasOwnProperty("systemRelease"))
							if (!$util.isString(message.systemRelease)) return "systemRelease: string expected";
						if (message.systemVersion != null && message.hasOwnProperty("systemVersion"))
							if (!$util.isString(message.systemVersion)) return "systemVersion: string expected";
						if (message.hardware != null && message.hasOwnProperty("hardware"))
							if (!$util.isString(message.hardware)) return "hardware: string expected";
						return null;
					};

					/**
					 * Creates a NativeDesktopLinuxData message from a plain object. Also converts values to their respective internal types.
					 * @function fromObject
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {Object.<string,*>} object Plain object
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopLinuxData} NativeDesktopLinuxData
					 */
					NativeDesktopLinuxData.fromObject = function fromObject(object) {
						if (object instanceof $root.spotify.clienttoken.data.v0.NativeDesktopLinuxData) return object;
						var message = new $root.spotify.clienttoken.data.v0.NativeDesktopLinuxData();
						if (object.systemName != null) message.systemName = String(object.systemName);
						if (object.systemRelease != null) message.systemRelease = String(object.systemRelease);
						if (object.systemVersion != null) message.systemVersion = String(object.systemVersion);
						if (object.hardware != null) message.hardware = String(object.hardware);
						return message;
					};

					/**
					 * Creates a plain object from a NativeDesktopLinuxData message. Also converts values to other types if specified.
					 * @function toObject
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {spotify.clienttoken.data.v0.NativeDesktopLinuxData} message NativeDesktopLinuxData
					 * @param {$protobuf.IConversionOptions} [options] Conversion options
					 * @returns {Object.<string,*>} Plain object
					 */
					NativeDesktopLinuxData.toObject = function toObject(message, options) {
						if (!options) options = {};
						var object = {};
						if (options.defaults) {
							object.systemName = "";
							object.systemRelease = "";
							object.systemVersion = "";
							object.hardware = "";
						}
						if (message.systemName != null && message.hasOwnProperty("systemName")) object.systemName = message.systemName;
						if (message.systemRelease != null && message.hasOwnProperty("systemRelease"))
							object.systemRelease = message.systemRelease;
						if (message.systemVersion != null && message.hasOwnProperty("systemVersion"))
							object.systemVersion = message.systemVersion;
						if (message.hardware != null && message.hasOwnProperty("hardware")) object.hardware = message.hardware;
						return object;
					};

					/**
					 * Converts this NativeDesktopLinuxData to JSON.
					 * @function toJSON
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @instance
					 * @returns {Object.<string,*>} JSON object
					 */
					NativeDesktopLinuxData.prototype.toJSON = function toJSON() {
						return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
					};

					/**
					 * Gets the default type url for NativeDesktopLinuxData
					 * @function getTypeUrl
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopLinuxData
					 * @static
					 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
					 * @returns {string} The default type url
					 */
					NativeDesktopLinuxData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
						if (typeUrlPrefix === undefined) {
							typeUrlPrefix = "type.googleapis.com";
						}
						return typeUrlPrefix + "/spotify.clienttoken.data.v0.NativeDesktopLinuxData";
					};

					return NativeDesktopLinuxData;
				})();

				v0.NativeDesktopMacOSData = (function () {
					/**
					 * Properties of a NativeDesktopMacOSData.
					 * @memberof spotify.clienttoken.data.v0
					 * @interface INativeDesktopMacOSData
					 * @property {string|null} [systemVersion] NativeDesktopMacOSData systemVersion
					 * @property {string|null} [hwModel] NativeDesktopMacOSData hwModel
					 * @property {string|null} [compiledCpuType] NativeDesktopMacOSData compiledCpuType
					 */

					/**
					 * Constructs a new NativeDesktopMacOSData.
					 * @memberof spotify.clienttoken.data.v0
					 * @classdesc Represents a NativeDesktopMacOSData.
					 * @implements INativeDesktopMacOSData
					 * @constructor
					 * @param {spotify.clienttoken.data.v0.INativeDesktopMacOSData=} [properties] Properties to set
					 */
					function NativeDesktopMacOSData(properties) {
						if (properties)
							for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
								if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
					}

					/**
					 * NativeDesktopMacOSData systemVersion.
					 * @member {string} systemVersion
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @instance
					 */
					NativeDesktopMacOSData.prototype.systemVersion = "";

					/**
					 * NativeDesktopMacOSData hwModel.
					 * @member {string} hwModel
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @instance
					 */
					NativeDesktopMacOSData.prototype.hwModel = "";

					/**
					 * NativeDesktopMacOSData compiledCpuType.
					 * @member {string} compiledCpuType
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @instance
					 */
					NativeDesktopMacOSData.prototype.compiledCpuType = "";

					/**
					 * Creates a new NativeDesktopMacOSData instance using the specified properties.
					 * @function create
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopMacOSData=} [properties] Properties to set
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopMacOSData} NativeDesktopMacOSData instance
					 */
					NativeDesktopMacOSData.create = function create(properties) {
						return new NativeDesktopMacOSData(properties);
					};

					/**
					 * Encodes the specified NativeDesktopMacOSData message. Does not implicitly {@link spotify.clienttoken.data.v0.NativeDesktopMacOSData.verify|verify} messages.
					 * @function encode
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopMacOSData} message NativeDesktopMacOSData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeDesktopMacOSData.encode = function encode(message, writer) {
						if (!writer) writer = $Writer.create();
						if (message.systemVersion != null && Object.hasOwnProperty.call(message, "systemVersion"))
							writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.systemVersion);
						if (message.hwModel != null && Object.hasOwnProperty.call(message, "hwModel"))
							writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.hwModel);
						if (message.compiledCpuType != null && Object.hasOwnProperty.call(message, "compiledCpuType"))
							writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.compiledCpuType);
						return writer;
					};

					/**
					 * Encodes the specified NativeDesktopMacOSData message, length delimited. Does not implicitly {@link spotify.clienttoken.data.v0.NativeDesktopMacOSData.verify|verify} messages.
					 * @function encodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {spotify.clienttoken.data.v0.INativeDesktopMacOSData} message NativeDesktopMacOSData message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					NativeDesktopMacOSData.encodeDelimited = function encodeDelimited(message, writer) {
						return this.encode(message, writer).ldelim();
					};

					/**
					 * Decodes a NativeDesktopMacOSData message from the specified reader or buffer.
					 * @function decode
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @param {number} [length] Message length if known beforehand
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopMacOSData} NativeDesktopMacOSData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeDesktopMacOSData.decode = function decode(reader, length) {
						if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
						var end = length === undefined ? reader.len : reader.pos + length,
							message = new $root.spotify.clienttoken.data.v0.NativeDesktopMacOSData();
						while (reader.pos < end) {
							var tag = reader.uint32();
							switch (tag >>> 3) {
								case 1: {
									message.systemVersion = reader.string();
									break;
								}
								case 2: {
									message.hwModel = reader.string();
									break;
								}
								case 3: {
									message.compiledCpuType = reader.string();
									break;
								}
								default:
									reader.skipType(tag & 7);
									break;
							}
						}
						return message;
					};

					/**
					 * Decodes a NativeDesktopMacOSData message from the specified reader or buffer, length delimited.
					 * @function decodeDelimited
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopMacOSData} NativeDesktopMacOSData
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					NativeDesktopMacOSData.decodeDelimited = function decodeDelimited(reader) {
						if (!(reader instanceof $Reader)) reader = new $Reader(reader);
						return this.decode(reader, reader.uint32());
					};

					/**
					 * Verifies a NativeDesktopMacOSData message.
					 * @function verify
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {Object.<string,*>} message Plain object to verify
					 * @returns {string|null} `null` if valid, otherwise the reason why it is not
					 */
					NativeDesktopMacOSData.verify = function verify(message) {
						if (typeof message !== "object" || message === null) return "object expected";
						if (message.systemVersion != null && message.hasOwnProperty("systemVersion"))
							if (!$util.isString(message.systemVersion)) return "systemVersion: string expected";
						if (message.hwModel != null && message.hasOwnProperty("hwModel"))
							if (!$util.isString(message.hwModel)) return "hwModel: string expected";
						if (message.compiledCpuType != null && message.hasOwnProperty("compiledCpuType"))
							if (!$util.isString(message.compiledCpuType)) return "compiledCpuType: string expected";
						return null;
					};

					/**
					 * Creates a NativeDesktopMacOSData message from a plain object. Also converts values to their respective internal types.
					 * @function fromObject
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {Object.<string,*>} object Plain object
					 * @returns {spotify.clienttoken.data.v0.NativeDesktopMacOSData} NativeDesktopMacOSData
					 */
					NativeDesktopMacOSData.fromObject = function fromObject(object) {
						if (object instanceof $root.spotify.clienttoken.data.v0.NativeDesktopMacOSData) return object;
						var message = new $root.spotify.clienttoken.data.v0.NativeDesktopMacOSData();
						if (object.systemVersion != null) message.systemVersion = String(object.systemVersion);
						if (object.hwModel != null) message.hwModel = String(object.hwModel);
						if (object.compiledCpuType != null) message.compiledCpuType = String(object.compiledCpuType);
						return message;
					};

					/**
					 * Creates a plain object from a NativeDesktopMacOSData message. Also converts values to other types if specified.
					 * @function toObject
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {spotify.clienttoken.data.v0.NativeDesktopMacOSData} message NativeDesktopMacOSData
					 * @param {$protobuf.IConversionOptions} [options] Conversion options
					 * @returns {Object.<string,*>} Plain object
					 */
					NativeDesktopMacOSData.toObject = function toObject(message, options) {
						if (!options) options = {};
						var object = {};
						if (options.defaults) {
							object.systemVersion = "";
							object.hwModel = "";
							object.compiledCpuType = "";
						}
						if (message.systemVersion != null && message.hasOwnProperty("systemVersion"))
							object.systemVersion = message.systemVersion;
						if (message.hwModel != null && message.hasOwnProperty("hwModel")) object.hwModel = message.hwModel;
						if (message.compiledCpuType != null && message.hasOwnProperty("compiledCpuType"))
							object.compiledCpuType = message.compiledCpuType;
						return object;
					};

					/**
					 * Converts this NativeDesktopMacOSData to JSON.
					 * @function toJSON
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @instance
					 * @returns {Object.<string,*>} JSON object
					 */
					NativeDesktopMacOSData.prototype.toJSON = function toJSON() {
						return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
					};

					/**
					 * Gets the default type url for NativeDesktopMacOSData
					 * @function getTypeUrl
					 * @memberof spotify.clienttoken.data.v0.NativeDesktopMacOSData
					 * @static
					 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
					 * @returns {string} The default type url
					 */
					NativeDesktopMacOSData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
						if (typeUrlPrefix === undefined) {
							typeUrlPrefix = "type.googleapis.com";
						}
						return typeUrlPrefix + "/spotify.clienttoken.data.v0.NativeDesktopMacOSData";
					};

					return NativeDesktopMacOSData;
				})();

				v0.Screen = (function () {
					/**
					 * Properties of a Screen.
					 * @memberof spotify.clienttoken.data.v0
					 * @interface IScreen
					 * @property {number|null} [width] Screen width
					 * @property {number|null} [height] Screen height
					 * @property {number|null} [density] Screen density
					 * @property {number|null} [unknownValue_4] Screen unknownValue_4
					 * @property {number|null} [unknownValue_5] Screen unknownValue_5
					 */

					/**
					 * Constructs a new Screen.
					 * @memberof spotify.clienttoken.data.v0
					 * @classdesc Represents a Screen.
					 * @implements IScreen
					 * @constructor
					 * @param {spotify.clienttoken.data.v0.IScreen=} [properties] Properties to set
					 */
					function Screen(properties) {
						if (properties)
							for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
								if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
					}

					/**
					 * Screen width.
					 * @member {number} width
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @instance
					 */
					Screen.prototype.width = 0;

					/**
					 * Screen height.
					 * @member {number} height
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @instance
					 */
					Screen.prototype.height = 0;

					/**
					 * Screen density.
					 * @member {number} density
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @instance
					 */
					Screen.prototype.density = 0;

					/**
					 * Screen unknownValue_4.
					 * @member {number} unknownValue_4
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @instance
					 */
					Screen.prototype.unknownValue_4 = 0;

					/**
					 * Screen unknownValue_5.
					 * @member {number} unknownValue_5
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @instance
					 */
					Screen.prototype.unknownValue_5 = 0;

					/**
					 * Creates a new Screen instance using the specified properties.
					 * @function create
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {spotify.clienttoken.data.v0.IScreen=} [properties] Properties to set
					 * @returns {spotify.clienttoken.data.v0.Screen} Screen instance
					 */
					Screen.create = function create(properties) {
						return new Screen(properties);
					};

					/**
					 * Encodes the specified Screen message. Does not implicitly {@link spotify.clienttoken.data.v0.Screen.verify|verify} messages.
					 * @function encode
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {spotify.clienttoken.data.v0.IScreen} message Screen message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					Screen.encode = function encode(message, writer) {
						if (!writer) writer = $Writer.create();
						if (message.width != null && Object.hasOwnProperty.call(message, "width"))
							writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.width);
						if (message.height != null && Object.hasOwnProperty.call(message, "height"))
							writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.height);
						if (message.density != null && Object.hasOwnProperty.call(message, "density"))
							writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.density);
						if (message.unknownValue_4 != null && Object.hasOwnProperty.call(message, "unknownValue_4"))
							writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.unknownValue_4);
						if (message.unknownValue_5 != null && Object.hasOwnProperty.call(message, "unknownValue_5"))
							writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.unknownValue_5);
						return writer;
					};

					/**
					 * Encodes the specified Screen message, length delimited. Does not implicitly {@link spotify.clienttoken.data.v0.Screen.verify|verify} messages.
					 * @function encodeDelimited
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {spotify.clienttoken.data.v0.IScreen} message Screen message or plain object to encode
					 * @param {$protobuf.Writer} [writer] Writer to encode to
					 * @returns {$protobuf.Writer} Writer
					 */
					Screen.encodeDelimited = function encodeDelimited(message, writer) {
						return this.encode(message, writer).ldelim();
					};

					/**
					 * Decodes a Screen message from the specified reader or buffer.
					 * @function decode
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @param {number} [length] Message length if known beforehand
					 * @returns {spotify.clienttoken.data.v0.Screen} Screen
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					Screen.decode = function decode(reader, length) {
						if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
						var end = length === undefined ? reader.len : reader.pos + length,
							message = new $root.spotify.clienttoken.data.v0.Screen();
						while (reader.pos < end) {
							var tag = reader.uint32();
							switch (tag >>> 3) {
								case 1: {
									message.width = reader.int32();
									break;
								}
								case 2: {
									message.height = reader.int32();
									break;
								}
								case 3: {
									message.density = reader.int32();
									break;
								}
								case 4: {
									message.unknownValue_4 = reader.int32();
									break;
								}
								case 5: {
									message.unknownValue_5 = reader.int32();
									break;
								}
								default:
									reader.skipType(tag & 7);
									break;
							}
						}
						return message;
					};

					/**
					 * Decodes a Screen message from the specified reader or buffer, length delimited.
					 * @function decodeDelimited
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
					 * @returns {spotify.clienttoken.data.v0.Screen} Screen
					 * @throws {Error} If the payload is not a reader or valid buffer
					 * @throws {$protobuf.util.ProtocolError} If required fields are missing
					 */
					Screen.decodeDelimited = function decodeDelimited(reader) {
						if (!(reader instanceof $Reader)) reader = new $Reader(reader);
						return this.decode(reader, reader.uint32());
					};

					/**
					 * Verifies a Screen message.
					 * @function verify
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {Object.<string,*>} message Plain object to verify
					 * @returns {string|null} `null` if valid, otherwise the reason why it is not
					 */
					Screen.verify = function verify(message) {
						if (typeof message !== "object" || message === null) return "object expected";
						if (message.width != null && message.hasOwnProperty("width"))
							if (!$util.isInteger(message.width)) return "width: integer expected";
						if (message.height != null && message.hasOwnProperty("height"))
							if (!$util.isInteger(message.height)) return "height: integer expected";
						if (message.density != null && message.hasOwnProperty("density"))
							if (!$util.isInteger(message.density)) return "density: integer expected";
						if (message.unknownValue_4 != null && message.hasOwnProperty("unknownValue_4"))
							if (!$util.isInteger(message.unknownValue_4)) return "unknownValue_4: integer expected";
						if (message.unknownValue_5 != null && message.hasOwnProperty("unknownValue_5"))
							if (!$util.isInteger(message.unknownValue_5)) return "unknownValue_5: integer expected";
						return null;
					};

					/**
					 * Creates a Screen message from a plain object. Also converts values to their respective internal types.
					 * @function fromObject
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {Object.<string,*>} object Plain object
					 * @returns {spotify.clienttoken.data.v0.Screen} Screen
					 */
					Screen.fromObject = function fromObject(object) {
						if (object instanceof $root.spotify.clienttoken.data.v0.Screen) return object;
						var message = new $root.spotify.clienttoken.data.v0.Screen();
						if (object.width != null) message.width = object.width | 0;
						if (object.height != null) message.height = object.height | 0;
						if (object.density != null) message.density = object.density | 0;
						if (object.unknownValue_4 != null) message.unknownValue_4 = object.unknownValue_4 | 0;
						if (object.unknownValue_5 != null) message.unknownValue_5 = object.unknownValue_5 | 0;
						return message;
					};

					/**
					 * Creates a plain object from a Screen message. Also converts values to other types if specified.
					 * @function toObject
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {spotify.clienttoken.data.v0.Screen} message Screen
					 * @param {$protobuf.IConversionOptions} [options] Conversion options
					 * @returns {Object.<string,*>} Plain object
					 */
					Screen.toObject = function toObject(message, options) {
						if (!options) options = {};
						var object = {};
						if (options.defaults) {
							object.width = 0;
							object.height = 0;
							object.density = 0;
							object.unknownValue_4 = 0;
							object.unknownValue_5 = 0;
						}
						if (message.width != null && message.hasOwnProperty("width")) object.width = message.width;
						if (message.height != null && message.hasOwnProperty("height")) object.height = message.height;
						if (message.density != null && message.hasOwnProperty("density")) object.density = message.density;
						if (message.unknownValue_4 != null && message.hasOwnProperty("unknownValue_4"))
							object.unknownValue_4 = message.unknownValue_4;
						if (message.unknownValue_5 != null && message.hasOwnProperty("unknownValue_5"))
							object.unknownValue_5 = message.unknownValue_5;
						return object;
					};

					/**
					 * Converts this Screen to JSON.
					 * @function toJSON
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @instance
					 * @returns {Object.<string,*>} JSON object
					 */
					Screen.prototype.toJSON = function toJSON() {
						return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
					};

					/**
					 * Gets the default type url for Screen
					 * @function getTypeUrl
					 * @memberof spotify.clienttoken.data.v0.Screen
					 * @static
					 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
					 * @returns {string} The default type url
					 */
					Screen.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
						if (typeUrlPrefix === undefined) {
							typeUrlPrefix = "type.googleapis.com";
						}
						return typeUrlPrefix + "/spotify.clienttoken.data.v0.Screen";
					};

					return Screen;
				})();

				return v0;
			})();

			return data;
		})();

		return clienttoken;
	})();

	return spotify;
})();

$root.ClientHello = (function () {
	/**
	 * Properties of a ClientHello.
	 * @exports IClientHello
	 * @interface IClientHello
	 * @property {IBuildInfo} buildInfo ClientHello buildInfo
	 * @property {Array.<Fingerprint>|null} [fingerprintsSupported] ClientHello fingerprintsSupported
	 * @property {Array.<Cryptosuite>|null} [cryptosuitesSupported] ClientHello cryptosuitesSupported
	 * @property {Array.<Powscheme>|null} [powschemesSupported] ClientHello powschemesSupported
	 * @property {ILoginCryptoHelloUnion} loginCryptoHello ClientHello loginCryptoHello
	 * @property {Uint8Array} clientNonce ClientHello clientNonce
	 * @property {Uint8Array|null} [padding] ClientHello padding
	 * @property {IFeatureSet|null} [featureSet] ClientHello featureSet
	 */

	/**
	 * Constructs a new ClientHello.
	 * @exports ClientHello
	 * @classdesc Represents a ClientHello.
	 * @implements IClientHello
	 * @constructor
	 * @param {IClientHello=} [properties] Properties to set
	 */
	function ClientHello(properties) {
		this.fingerprintsSupported = [];
		this.cryptosuitesSupported = [];
		this.powschemesSupported = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientHello buildInfo.
	 * @member {IBuildInfo} buildInfo
	 * @memberof ClientHello
	 * @instance
	 */
	ClientHello.prototype.buildInfo = null;

	/**
	 * ClientHello fingerprintsSupported.
	 * @member {Array.<Fingerprint>} fingerprintsSupported
	 * @memberof ClientHello
	 * @instance
	 */
	ClientHello.prototype.fingerprintsSupported = $util.emptyArray;

	/**
	 * ClientHello cryptosuitesSupported.
	 * @member {Array.<Cryptosuite>} cryptosuitesSupported
	 * @memberof ClientHello
	 * @instance
	 */
	ClientHello.prototype.cryptosuitesSupported = $util.emptyArray;

	/**
	 * ClientHello powschemesSupported.
	 * @member {Array.<Powscheme>} powschemesSupported
	 * @memberof ClientHello
	 * @instance
	 */
	ClientHello.prototype.powschemesSupported = $util.emptyArray;

	/**
	 * ClientHello loginCryptoHello.
	 * @member {ILoginCryptoHelloUnion} loginCryptoHello
	 * @memberof ClientHello
	 * @instance
	 */
	ClientHello.prototype.loginCryptoHello = null;

	/**
	 * ClientHello clientNonce.
	 * @member {Uint8Array} clientNonce
	 * @memberof ClientHello
	 * @instance
	 */
	ClientHello.prototype.clientNonce = $util.newBuffer([]);

	/**
	 * ClientHello padding.
	 * @member {Uint8Array} padding
	 * @memberof ClientHello
	 * @instance
	 */
	ClientHello.prototype.padding = $util.newBuffer([]);

	/**
	 * ClientHello featureSet.
	 * @member {IFeatureSet|null|undefined} featureSet
	 * @memberof ClientHello
	 * @instance
	 */
	ClientHello.prototype.featureSet = null;

	/**
	 * Creates a new ClientHello instance using the specified properties.
	 * @function create
	 * @memberof ClientHello
	 * @static
	 * @param {IClientHello=} [properties] Properties to set
	 * @returns {ClientHello} ClientHello instance
	 */
	ClientHello.create = function create(properties) {
		return new ClientHello(properties);
	};

	/**
	 * Encodes the specified ClientHello message. Does not implicitly {@link ClientHello.verify|verify} messages.
	 * @function encode
	 * @memberof ClientHello
	 * @static
	 * @param {IClientHello} message ClientHello message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientHello.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		$root.BuildInfo.encode(message.buildInfo, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.fingerprintsSupported != null && message.fingerprintsSupported.length)
			for (var i = 0; i < message.fingerprintsSupported.length; ++i)
				writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.fingerprintsSupported[i]);
		if (message.cryptosuitesSupported != null && message.cryptosuitesSupported.length)
			for (var i = 0; i < message.cryptosuitesSupported.length; ++i)
				writer.uint32(/* id 30, wireType 0 =*/ 240).int32(message.cryptosuitesSupported[i]);
		if (message.powschemesSupported != null && message.powschemesSupported.length)
			for (var i = 0; i < message.powschemesSupported.length; ++i)
				writer.uint32(/* id 40, wireType 0 =*/ 320).int32(message.powschemesSupported[i]);
		$root.LoginCryptoHelloUnion.encode(message.loginCryptoHello, writer.uint32(/* id 50, wireType 2 =*/ 402).fork()).ldelim();
		writer.uint32(/* id 60, wireType 2 =*/ 482).bytes(message.clientNonce);
		if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
			writer.uint32(/* id 70, wireType 2 =*/ 562).bytes(message.padding);
		if (message.featureSet != null && Object.hasOwnProperty.call(message, "featureSet"))
			$root.FeatureSet.encode(message.featureSet, writer.uint32(/* id 80, wireType 2 =*/ 642).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ClientHello message, length delimited. Does not implicitly {@link ClientHello.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientHello
	 * @static
	 * @param {IClientHello} message ClientHello message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientHello.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientHello message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientHello
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientHello} ClientHello
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientHello.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientHello();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.buildInfo = $root.BuildInfo.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					if (!(message.fingerprintsSupported && message.fingerprintsSupported.length)) message.fingerprintsSupported = [];
					if ((tag & 7) === 2) {
						var end2 = reader.uint32() + reader.pos;
						while (reader.pos < end2) message.fingerprintsSupported.push(reader.int32());
					} else message.fingerprintsSupported.push(reader.int32());
					break;
				}
				case 30: {
					if (!(message.cryptosuitesSupported && message.cryptosuitesSupported.length)) message.cryptosuitesSupported = [];
					if ((tag & 7) === 2) {
						var end2 = reader.uint32() + reader.pos;
						while (reader.pos < end2) message.cryptosuitesSupported.push(reader.int32());
					} else message.cryptosuitesSupported.push(reader.int32());
					break;
				}
				case 40: {
					if (!(message.powschemesSupported && message.powschemesSupported.length)) message.powschemesSupported = [];
					if ((tag & 7) === 2) {
						var end2 = reader.uint32() + reader.pos;
						while (reader.pos < end2) message.powschemesSupported.push(reader.int32());
					} else message.powschemesSupported.push(reader.int32());
					break;
				}
				case 50: {
					message.loginCryptoHello = $root.LoginCryptoHelloUnion.decode(reader, reader.uint32());
					break;
				}
				case 60: {
					message.clientNonce = reader.bytes();
					break;
				}
				case 70: {
					message.padding = reader.bytes();
					break;
				}
				case 80: {
					message.featureSet = $root.FeatureSet.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("buildInfo")) throw $util.ProtocolError("missing required 'buildInfo'", { instance: message });
		if (!message.hasOwnProperty("loginCryptoHello"))
			throw $util.ProtocolError("missing required 'loginCryptoHello'", { instance: message });
		if (!message.hasOwnProperty("clientNonce")) throw $util.ProtocolError("missing required 'clientNonce'", { instance: message });
		return message;
	};

	/**
	 * Decodes a ClientHello message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientHello
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientHello} ClientHello
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientHello.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientHello message.
	 * @function verify
	 * @memberof ClientHello
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientHello.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		{
			var error = $root.BuildInfo.verify(message.buildInfo);
			if (error) return "buildInfo." + error;
		}
		if (message.fingerprintsSupported != null && message.hasOwnProperty("fingerprintsSupported")) {
			if (!Array.isArray(message.fingerprintsSupported)) return "fingerprintsSupported: array expected";
			for (var i = 0; i < message.fingerprintsSupported.length; ++i)
				switch (message.fingerprintsSupported[i]) {
					default:
						return "fingerprintsSupported: enum value[] expected";
					case 0:
					case 1:
						break;
				}
		}
		if (message.cryptosuitesSupported != null && message.hasOwnProperty("cryptosuitesSupported")) {
			if (!Array.isArray(message.cryptosuitesSupported)) return "cryptosuitesSupported: array expected";
			for (var i = 0; i < message.cryptosuitesSupported.length; ++i)
				switch (message.cryptosuitesSupported[i]) {
					default:
						return "cryptosuitesSupported: enum value[] expected";
					case 0:
					case 1:
						break;
				}
		}
		if (message.powschemesSupported != null && message.hasOwnProperty("powschemesSupported")) {
			if (!Array.isArray(message.powschemesSupported)) return "powschemesSupported: array expected";
			for (var i = 0; i < message.powschemesSupported.length; ++i)
				switch (message.powschemesSupported[i]) {
					default:
						return "powschemesSupported: enum value[] expected";
					case 0:
						break;
				}
		}
		{
			var error = $root.LoginCryptoHelloUnion.verify(message.loginCryptoHello);
			if (error) return "loginCryptoHello." + error;
		}
		if (!((message.clientNonce && typeof message.clientNonce.length === "number") || $util.isString(message.clientNonce)))
			return "clientNonce: buffer expected";
		if (message.padding != null && message.hasOwnProperty("padding"))
			if (!((message.padding && typeof message.padding.length === "number") || $util.isString(message.padding)))
				return "padding: buffer expected";
		if (message.featureSet != null && message.hasOwnProperty("featureSet")) {
			var error = $root.FeatureSet.verify(message.featureSet);
			if (error) return "featureSet." + error;
		}
		return null;
	};

	/**
	 * Creates a ClientHello message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientHello
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientHello} ClientHello
	 */
	ClientHello.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientHello) return object;
		var message = new $root.ClientHello();
		if (object.buildInfo != null) {
			if (typeof object.buildInfo !== "object") throw TypeError(".ClientHello.buildInfo: object expected");
			message.buildInfo = $root.BuildInfo.fromObject(object.buildInfo);
		}
		if (object.fingerprintsSupported) {
			if (!Array.isArray(object.fingerprintsSupported)) throw TypeError(".ClientHello.fingerprintsSupported: array expected");
			message.fingerprintsSupported = [];
			for (var i = 0; i < object.fingerprintsSupported.length; ++i)
				switch (object.fingerprintsSupported[i]) {
					default:
						if (typeof object.fingerprintsSupported[i] === "number") {
							message.fingerprintsSupported[i] = object.fingerprintsSupported[i];
							break;
						}
					case "FINGERPRINT_GRAIN":
					case 0:
						message.fingerprintsSupported[i] = 0;
						break;
					case "FINGERPRINT_HMAC_RIPEMD":
					case 1:
						message.fingerprintsSupported[i] = 1;
						break;
				}
		}
		if (object.cryptosuitesSupported) {
			if (!Array.isArray(object.cryptosuitesSupported)) throw TypeError(".ClientHello.cryptosuitesSupported: array expected");
			message.cryptosuitesSupported = [];
			for (var i = 0; i < object.cryptosuitesSupported.length; ++i)
				switch (object.cryptosuitesSupported[i]) {
					default:
						if (typeof object.cryptosuitesSupported[i] === "number") {
							message.cryptosuitesSupported[i] = object.cryptosuitesSupported[i];
							break;
						}
					case "CRYPTO_SUITE_SHANNON":
					case 0:
						message.cryptosuitesSupported[i] = 0;
						break;
					case "CRYPTO_SUITE_RC4_SHA1_HMAC":
					case 1:
						message.cryptosuitesSupported[i] = 1;
						break;
				}
		}
		if (object.powschemesSupported) {
			if (!Array.isArray(object.powschemesSupported)) throw TypeError(".ClientHello.powschemesSupported: array expected");
			message.powschemesSupported = [];
			for (var i = 0; i < object.powschemesSupported.length; ++i)
				switch (object.powschemesSupported[i]) {
					default:
						if (typeof object.powschemesSupported[i] === "number") {
							message.powschemesSupported[i] = object.powschemesSupported[i];
							break;
						}
					case "POW_HASH_CASH":
					case 0:
						message.powschemesSupported[i] = 0;
						break;
				}
		}
		if (object.loginCryptoHello != null) {
			if (typeof object.loginCryptoHello !== "object") throw TypeError(".ClientHello.loginCryptoHello: object expected");
			message.loginCryptoHello = $root.LoginCryptoHelloUnion.fromObject(object.loginCryptoHello);
		}
		if (object.clientNonce != null)
			if (typeof object.clientNonce === "string")
				$util.base64.decode(
					object.clientNonce,
					(message.clientNonce = $util.newBuffer($util.base64.length(object.clientNonce))),
					0,
				);
			else if (object.clientNonce.length >= 0) message.clientNonce = object.clientNonce;
		if (object.padding != null)
			if (typeof object.padding === "string")
				$util.base64.decode(object.padding, (message.padding = $util.newBuffer($util.base64.length(object.padding))), 0);
			else if (object.padding.length >= 0) message.padding = object.padding;
		if (object.featureSet != null) {
			if (typeof object.featureSet !== "object") throw TypeError(".ClientHello.featureSet: object expected");
			message.featureSet = $root.FeatureSet.fromObject(object.featureSet);
		}
		return message;
	};

	/**
	 * Creates a plain object from a ClientHello message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientHello
	 * @static
	 * @param {ClientHello} message ClientHello
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientHello.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) {
			object.fingerprintsSupported = [];
			object.cryptosuitesSupported = [];
			object.powschemesSupported = [];
		}
		if (options.defaults) {
			object.buildInfo = null;
			object.loginCryptoHello = null;
			if (options.bytes === String) object.clientNonce = "";
			else {
				object.clientNonce = [];
				if (options.bytes !== Array) object.clientNonce = $util.newBuffer(object.clientNonce);
			}
			if (options.bytes === String) object.padding = "";
			else {
				object.padding = [];
				if (options.bytes !== Array) object.padding = $util.newBuffer(object.padding);
			}
			object.featureSet = null;
		}
		if (message.buildInfo != null && message.hasOwnProperty("buildInfo"))
			object.buildInfo = $root.BuildInfo.toObject(message.buildInfo, options);
		if (message.fingerprintsSupported && message.fingerprintsSupported.length) {
			object.fingerprintsSupported = [];
			for (var j = 0; j < message.fingerprintsSupported.length; ++j)
				object.fingerprintsSupported[j] =
					options.enums === String
						? $root.Fingerprint[message.fingerprintsSupported[j]] === undefined
							? message.fingerprintsSupported[j]
							: $root.Fingerprint[message.fingerprintsSupported[j]]
						: message.fingerprintsSupported[j];
		}
		if (message.cryptosuitesSupported && message.cryptosuitesSupported.length) {
			object.cryptosuitesSupported = [];
			for (var j = 0; j < message.cryptosuitesSupported.length; ++j)
				object.cryptosuitesSupported[j] =
					options.enums === String
						? $root.Cryptosuite[message.cryptosuitesSupported[j]] === undefined
							? message.cryptosuitesSupported[j]
							: $root.Cryptosuite[message.cryptosuitesSupported[j]]
						: message.cryptosuitesSupported[j];
		}
		if (message.powschemesSupported && message.powschemesSupported.length) {
			object.powschemesSupported = [];
			for (var j = 0; j < message.powschemesSupported.length; ++j)
				object.powschemesSupported[j] =
					options.enums === String
						? $root.Powscheme[message.powschemesSupported[j]] === undefined
							? message.powschemesSupported[j]
							: $root.Powscheme[message.powschemesSupported[j]]
						: message.powschemesSupported[j];
		}
		if (message.loginCryptoHello != null && message.hasOwnProperty("loginCryptoHello"))
			object.loginCryptoHello = $root.LoginCryptoHelloUnion.toObject(message.loginCryptoHello, options);
		if (message.clientNonce != null && message.hasOwnProperty("clientNonce"))
			object.clientNonce =
				options.bytes === String
					? $util.base64.encode(message.clientNonce, 0, message.clientNonce.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.clientNonce)
					: message.clientNonce;
		if (message.padding != null && message.hasOwnProperty("padding"))
			object.padding =
				options.bytes === String
					? $util.base64.encode(message.padding, 0, message.padding.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.padding)
					: message.padding;
		if (message.featureSet != null && message.hasOwnProperty("featureSet"))
			object.featureSet = $root.FeatureSet.toObject(message.featureSet, options);
		return object;
	};

	/**
	 * Converts this ClientHello to JSON.
	 * @function toJSON
	 * @memberof ClientHello
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientHello.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientHello
	 * @function getTypeUrl
	 * @memberof ClientHello
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientHello.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientHello";
	};

	return ClientHello;
})();

$root.BuildInfo = (function () {
	/**
	 * Properties of a BuildInfo.
	 * @exports IBuildInfo
	 * @interface IBuildInfo
	 * @property {Product} product BuildInfo product
	 * @property {Array.<ProductFlags>|null} [productFlags] BuildInfo productFlags
	 * @property {Platform} platform BuildInfo platform
	 * @property {number|Long} version BuildInfo version
	 */

	/**
	 * Constructs a new BuildInfo.
	 * @exports BuildInfo
	 * @classdesc Represents a BuildInfo.
	 * @implements IBuildInfo
	 * @constructor
	 * @param {IBuildInfo=} [properties] Properties to set
	 */
	function BuildInfo(properties) {
		this.productFlags = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * BuildInfo product.
	 * @member {Product} product
	 * @memberof BuildInfo
	 * @instance
	 */
	BuildInfo.prototype.product = 0;

	/**
	 * BuildInfo productFlags.
	 * @member {Array.<ProductFlags>} productFlags
	 * @memberof BuildInfo
	 * @instance
	 */
	BuildInfo.prototype.productFlags = $util.emptyArray;

	/**
	 * BuildInfo platform.
	 * @member {Platform} platform
	 * @memberof BuildInfo
	 * @instance
	 */
	BuildInfo.prototype.platform = 0;

	/**
	 * BuildInfo version.
	 * @member {number|Long} version
	 * @memberof BuildInfo
	 * @instance
	 */
	BuildInfo.prototype.version = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

	/**
	 * Creates a new BuildInfo instance using the specified properties.
	 * @function create
	 * @memberof BuildInfo
	 * @static
	 * @param {IBuildInfo=} [properties] Properties to set
	 * @returns {BuildInfo} BuildInfo instance
	 */
	BuildInfo.create = function create(properties) {
		return new BuildInfo(properties);
	};

	/**
	 * Encodes the specified BuildInfo message. Does not implicitly {@link BuildInfo.verify|verify} messages.
	 * @function encode
	 * @memberof BuildInfo
	 * @static
	 * @param {IBuildInfo} message BuildInfo message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	BuildInfo.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.product);
		if (message.productFlags != null && message.productFlags.length)
			for (var i = 0; i < message.productFlags.length; ++i)
				writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.productFlags[i]);
		writer.uint32(/* id 30, wireType 0 =*/ 240).int32(message.platform);
		writer.uint32(/* id 40, wireType 0 =*/ 320).uint64(message.version);
		return writer;
	};

	/**
	 * Encodes the specified BuildInfo message, length delimited. Does not implicitly {@link BuildInfo.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof BuildInfo
	 * @static
	 * @param {IBuildInfo} message BuildInfo message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	BuildInfo.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a BuildInfo message from the specified reader or buffer.
	 * @function decode
	 * @memberof BuildInfo
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {BuildInfo} BuildInfo
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	BuildInfo.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.BuildInfo();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.product = reader.int32();
					break;
				}
				case 20: {
					if (!(message.productFlags && message.productFlags.length)) message.productFlags = [];
					if ((tag & 7) === 2) {
						var end2 = reader.uint32() + reader.pos;
						while (reader.pos < end2) message.productFlags.push(reader.int32());
					} else message.productFlags.push(reader.int32());
					break;
				}
				case 30: {
					message.platform = reader.int32();
					break;
				}
				case 40: {
					message.version = reader.uint64();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("product")) throw $util.ProtocolError("missing required 'product'", { instance: message });
		if (!message.hasOwnProperty("platform")) throw $util.ProtocolError("missing required 'platform'", { instance: message });
		if (!message.hasOwnProperty("version")) throw $util.ProtocolError("missing required 'version'", { instance: message });
		return message;
	};

	/**
	 * Decodes a BuildInfo message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof BuildInfo
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {BuildInfo} BuildInfo
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	BuildInfo.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a BuildInfo message.
	 * @function verify
	 * @memberof BuildInfo
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	BuildInfo.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		switch (message.product) {
			default:
				return "product: enum value expected";
			case 0:
			case 1:
			case 2:
			case 3:
			case 5:
				break;
		}
		if (message.productFlags != null && message.hasOwnProperty("productFlags")) {
			if (!Array.isArray(message.productFlags)) return "productFlags: array expected";
			for (var i = 0; i < message.productFlags.length; ++i)
				switch (message.productFlags[i]) {
					default:
						return "productFlags: enum value[] expected";
					case 0:
					case 1:
						break;
				}
		}
		switch (message.platform) {
			default:
				return "platform: enum value expected";
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
			case 28:
			case 29:
			case 30:
			case 31:
			case 32:
			case 33:
			case 34:
			case 35:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
				break;
		}
		if (
			!$util.isInteger(message.version) &&
			!(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high))
		)
			return "version: integer|Long expected";
		return null;
	};

	/**
	 * Creates a BuildInfo message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof BuildInfo
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {BuildInfo} BuildInfo
	 */
	BuildInfo.fromObject = function fromObject(object) {
		if (object instanceof $root.BuildInfo) return object;
		var message = new $root.BuildInfo();
		switch (object.product) {
			default:
				if (typeof object.product === "number") {
					message.product = object.product;
					break;
				}
				break;
			case "PRODUCT_CLIENT":
			case 0:
				message.product = 0;
				break;
			case "PRODUCT_LIBSPOTIFY":
			case 1:
				message.product = 1;
				break;
			case "PRODUCT_MOBILE":
			case 2:
				message.product = 2;
				break;
			case "PRODUCT_PARTNER":
			case 3:
				message.product = 3;
				break;
			case "PRODUCT_LIBSPOTIFY_EMBEDDED":
			case 5:
				message.product = 5;
				break;
		}
		if (object.productFlags) {
			if (!Array.isArray(object.productFlags)) throw TypeError(".BuildInfo.productFlags: array expected");
			message.productFlags = [];
			for (var i = 0; i < object.productFlags.length; ++i)
				switch (object.productFlags[i]) {
					default:
						if (typeof object.productFlags[i] === "number") {
							message.productFlags[i] = object.productFlags[i];
							break;
						}
					case "PRODUCT_FLAG_NONE":
					case 0:
						message.productFlags[i] = 0;
						break;
					case "PRODUCT_FLAG_DEV_BUILD":
					case 1:
						message.productFlags[i] = 1;
						break;
				}
		}
		switch (object.platform) {
			default:
				if (typeof object.platform === "number") {
					message.platform = object.platform;
					break;
				}
				break;
			case "PLATFORM_WIN32_X86":
			case 0:
				message.platform = 0;
				break;
			case "PLATFORM_OSX_X86":
			case 1:
				message.platform = 1;
				break;
			case "PLATFORM_LINUX_X86":
			case 2:
				message.platform = 2;
				break;
			case "PLATFORM_IPHONE_ARM":
			case 3:
				message.platform = 3;
				break;
			case "PLATFORM_S60_ARM":
			case 4:
				message.platform = 4;
				break;
			case "PLATFORM_OSX_PPC":
			case 5:
				message.platform = 5;
				break;
			case "PLATFORM_ANDROID_ARM":
			case 6:
				message.platform = 6;
				break;
			case "PLATFORM_WINDOWS_CE_ARM":
			case 7:
				message.platform = 7;
				break;
			case "PLATFORM_LINUX_X86_64":
			case 8:
				message.platform = 8;
				break;
			case "PLATFORM_OSX_X86_64":
			case 9:
				message.platform = 9;
				break;
			case "PLATFORM_PALM_ARM":
			case 10:
				message.platform = 10;
				break;
			case "PLATFORM_LINUX_SH":
			case 11:
				message.platform = 11;
				break;
			case "PLATFORM_FREEBSD_X86":
			case 12:
				message.platform = 12;
				break;
			case "PLATFORM_FREEBSD_X86_64":
			case 13:
				message.platform = 13;
				break;
			case "PLATFORM_BLACKBERRY_ARM":
			case 14:
				message.platform = 14;
				break;
			case "PLATFORM_SONOS":
			case 15:
				message.platform = 15;
				break;
			case "PLATFORM_LINUX_MIPS":
			case 16:
				message.platform = 16;
				break;
			case "PLATFORM_LINUX_ARM":
			case 17:
				message.platform = 17;
				break;
			case "PLATFORM_LOGITECH_ARM":
			case 18:
				message.platform = 18;
				break;
			case "PLATFORM_LINUX_BLACKFIN":
			case 19:
				message.platform = 19;
				break;
			case "PLATFORM_WP7_ARM":
			case 20:
				message.platform = 20;
				break;
			case "PLATFORM_ONKYO_ARM":
			case 21:
				message.platform = 21;
				break;
			case "PLATFORM_QNXNTO_ARM":
			case 22:
				message.platform = 22;
				break;
			case "PLATFORM_BCO_ARM":
			case 23:
				message.platform = 23;
				break;
			case "PLATFORM_WEBPLAYER":
			case 24:
				message.platform = 24;
				break;
			case "PLATFORM_WP8_ARM":
			case 25:
				message.platform = 25;
				break;
			case "PLATFORM_WP8_X86":
			case 26:
				message.platform = 26;
				break;
			case "PLATFORM_WINRT_ARM":
			case 27:
				message.platform = 27;
				break;
			case "PLATFORM_WINRT_X86":
			case 28:
				message.platform = 28;
				break;
			case "PLATFORM_WINRT_X86_64":
			case 29:
				message.platform = 29;
				break;
			case "PLATFORM_FRONTIER":
			case 30:
				message.platform = 30;
				break;
			case "PLATFORM_AMIGA_PPC":
			case 31:
				message.platform = 31;
				break;
			case "PLATFORM_NANRADIO_NRX901":
			case 32:
				message.platform = 32;
				break;
			case "PLATFORM_HARMAN_ARM":
			case 33:
				message.platform = 33;
				break;
			case "PLATFORM_SONY_PS3":
			case 34:
				message.platform = 34;
				break;
			case "PLATFORM_SONY_PS4":
			case 35:
				message.platform = 35;
				break;
			case "PLATFORM_IPHONE_ARM64":
			case 36:
				message.platform = 36;
				break;
			case "PLATFORM_RTEMS_PPC":
			case 37:
				message.platform = 37;
				break;
			case "PLATFORM_GENERIC_PARTNER":
			case 38:
				message.platform = 38;
				break;
			case "PLATFORM_WIN32_X86_64":
			case 39:
				message.platform = 39;
				break;
			case "PLATFORM_WATCHOS":
			case 40:
				message.platform = 40;
				break;
		}
		if (object.version != null)
			if ($util.Long) (message.version = $util.Long.fromValue(object.version)).unsigned = true;
			else if (typeof object.version === "string") message.version = parseInt(object.version, 10);
			else if (typeof object.version === "number") message.version = object.version;
			else if (typeof object.version === "object")
				message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
		return message;
	};

	/**
	 * Creates a plain object from a BuildInfo message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof BuildInfo
	 * @static
	 * @param {BuildInfo} message BuildInfo
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	BuildInfo.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.productFlags = [];
		if (options.defaults) {
			object.product = options.enums === String ? "PRODUCT_CLIENT" : 0;
			object.platform = options.enums === String ? "PLATFORM_WIN32_X86" : 0;
			if ($util.Long) {
				var long = new $util.Long(0, 0, true);
				object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
			} else object.version = options.longs === String ? "0" : 0;
		}
		if (message.product != null && message.hasOwnProperty("product"))
			object.product =
				options.enums === String
					? $root.Product[message.product] === undefined
						? message.product
						: $root.Product[message.product]
					: message.product;
		if (message.productFlags && message.productFlags.length) {
			object.productFlags = [];
			for (var j = 0; j < message.productFlags.length; ++j)
				object.productFlags[j] =
					options.enums === String
						? $root.ProductFlags[message.productFlags[j]] === undefined
							? message.productFlags[j]
							: $root.ProductFlags[message.productFlags[j]]
						: message.productFlags[j];
		}
		if (message.platform != null && message.hasOwnProperty("platform"))
			object.platform =
				options.enums === String
					? $root.Platform[message.platform] === undefined
						? message.platform
						: $root.Platform[message.platform]
					: message.platform;
		if (message.version != null && message.hasOwnProperty("version"))
			if (typeof message.version === "number") object.version = options.longs === String ? String(message.version) : message.version;
			else
				object.version =
					options.longs === String
						? $util.Long.prototype.toString.call(message.version)
						: options.longs === Number
						? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true)
						: message.version;
		return object;
	};

	/**
	 * Converts this BuildInfo to JSON.
	 * @function toJSON
	 * @memberof BuildInfo
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	BuildInfo.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for BuildInfo
	 * @function getTypeUrl
	 * @memberof BuildInfo
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	BuildInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/BuildInfo";
	};

	return BuildInfo;
})();

/**
 * Product enum.
 * @exports Product
 * @enum {number}
 * @property {number} PRODUCT_CLIENT=0 PRODUCT_CLIENT value
 * @property {number} PRODUCT_LIBSPOTIFY=1 PRODUCT_LIBSPOTIFY value
 * @property {number} PRODUCT_MOBILE=2 PRODUCT_MOBILE value
 * @property {number} PRODUCT_PARTNER=3 PRODUCT_PARTNER value
 * @property {number} PRODUCT_LIBSPOTIFY_EMBEDDED=5 PRODUCT_LIBSPOTIFY_EMBEDDED value
 */
$root.Product = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "PRODUCT_CLIENT")] = 0;
	values[(valuesById[1] = "PRODUCT_LIBSPOTIFY")] = 1;
	values[(valuesById[2] = "PRODUCT_MOBILE")] = 2;
	values[(valuesById[3] = "PRODUCT_PARTNER")] = 3;
	values[(valuesById[5] = "PRODUCT_LIBSPOTIFY_EMBEDDED")] = 5;
	return values;
})();

/**
 * ProductFlags enum.
 * @exports ProductFlags
 * @enum {number}
 * @property {number} PRODUCT_FLAG_NONE=0 PRODUCT_FLAG_NONE value
 * @property {number} PRODUCT_FLAG_DEV_BUILD=1 PRODUCT_FLAG_DEV_BUILD value
 */
$root.ProductFlags = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "PRODUCT_FLAG_NONE")] = 0;
	values[(valuesById[1] = "PRODUCT_FLAG_DEV_BUILD")] = 1;
	return values;
})();

/**
 * Platform enum.
 * @exports Platform
 * @enum {number}
 * @property {number} PLATFORM_WIN32_X86=0 PLATFORM_WIN32_X86 value
 * @property {number} PLATFORM_OSX_X86=1 PLATFORM_OSX_X86 value
 * @property {number} PLATFORM_LINUX_X86=2 PLATFORM_LINUX_X86 value
 * @property {number} PLATFORM_IPHONE_ARM=3 PLATFORM_IPHONE_ARM value
 * @property {number} PLATFORM_S60_ARM=4 PLATFORM_S60_ARM value
 * @property {number} PLATFORM_OSX_PPC=5 PLATFORM_OSX_PPC value
 * @property {number} PLATFORM_ANDROID_ARM=6 PLATFORM_ANDROID_ARM value
 * @property {number} PLATFORM_WINDOWS_CE_ARM=7 PLATFORM_WINDOWS_CE_ARM value
 * @property {number} PLATFORM_LINUX_X86_64=8 PLATFORM_LINUX_X86_64 value
 * @property {number} PLATFORM_OSX_X86_64=9 PLATFORM_OSX_X86_64 value
 * @property {number} PLATFORM_PALM_ARM=10 PLATFORM_PALM_ARM value
 * @property {number} PLATFORM_LINUX_SH=11 PLATFORM_LINUX_SH value
 * @property {number} PLATFORM_FREEBSD_X86=12 PLATFORM_FREEBSD_X86 value
 * @property {number} PLATFORM_FREEBSD_X86_64=13 PLATFORM_FREEBSD_X86_64 value
 * @property {number} PLATFORM_BLACKBERRY_ARM=14 PLATFORM_BLACKBERRY_ARM value
 * @property {number} PLATFORM_SONOS=15 PLATFORM_SONOS value
 * @property {number} PLATFORM_LINUX_MIPS=16 PLATFORM_LINUX_MIPS value
 * @property {number} PLATFORM_LINUX_ARM=17 PLATFORM_LINUX_ARM value
 * @property {number} PLATFORM_LOGITECH_ARM=18 PLATFORM_LOGITECH_ARM value
 * @property {number} PLATFORM_LINUX_BLACKFIN=19 PLATFORM_LINUX_BLACKFIN value
 * @property {number} PLATFORM_WP7_ARM=20 PLATFORM_WP7_ARM value
 * @property {number} PLATFORM_ONKYO_ARM=21 PLATFORM_ONKYO_ARM value
 * @property {number} PLATFORM_QNXNTO_ARM=22 PLATFORM_QNXNTO_ARM value
 * @property {number} PLATFORM_BCO_ARM=23 PLATFORM_BCO_ARM value
 * @property {number} PLATFORM_WEBPLAYER=24 PLATFORM_WEBPLAYER value
 * @property {number} PLATFORM_WP8_ARM=25 PLATFORM_WP8_ARM value
 * @property {number} PLATFORM_WP8_X86=26 PLATFORM_WP8_X86 value
 * @property {number} PLATFORM_WINRT_ARM=27 PLATFORM_WINRT_ARM value
 * @property {number} PLATFORM_WINRT_X86=28 PLATFORM_WINRT_X86 value
 * @property {number} PLATFORM_WINRT_X86_64=29 PLATFORM_WINRT_X86_64 value
 * @property {number} PLATFORM_FRONTIER=30 PLATFORM_FRONTIER value
 * @property {number} PLATFORM_AMIGA_PPC=31 PLATFORM_AMIGA_PPC value
 * @property {number} PLATFORM_NANRADIO_NRX901=32 PLATFORM_NANRADIO_NRX901 value
 * @property {number} PLATFORM_HARMAN_ARM=33 PLATFORM_HARMAN_ARM value
 * @property {number} PLATFORM_SONY_PS3=34 PLATFORM_SONY_PS3 value
 * @property {number} PLATFORM_SONY_PS4=35 PLATFORM_SONY_PS4 value
 * @property {number} PLATFORM_IPHONE_ARM64=36 PLATFORM_IPHONE_ARM64 value
 * @property {number} PLATFORM_RTEMS_PPC=37 PLATFORM_RTEMS_PPC value
 * @property {number} PLATFORM_GENERIC_PARTNER=38 PLATFORM_GENERIC_PARTNER value
 * @property {number} PLATFORM_WIN32_X86_64=39 PLATFORM_WIN32_X86_64 value
 * @property {number} PLATFORM_WATCHOS=40 PLATFORM_WATCHOS value
 */
$root.Platform = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "PLATFORM_WIN32_X86")] = 0;
	values[(valuesById[1] = "PLATFORM_OSX_X86")] = 1;
	values[(valuesById[2] = "PLATFORM_LINUX_X86")] = 2;
	values[(valuesById[3] = "PLATFORM_IPHONE_ARM")] = 3;
	values[(valuesById[4] = "PLATFORM_S60_ARM")] = 4;
	values[(valuesById[5] = "PLATFORM_OSX_PPC")] = 5;
	values[(valuesById[6] = "PLATFORM_ANDROID_ARM")] = 6;
	values[(valuesById[7] = "PLATFORM_WINDOWS_CE_ARM")] = 7;
	values[(valuesById[8] = "PLATFORM_LINUX_X86_64")] = 8;
	values[(valuesById[9] = "PLATFORM_OSX_X86_64")] = 9;
	values[(valuesById[10] = "PLATFORM_PALM_ARM")] = 10;
	values[(valuesById[11] = "PLATFORM_LINUX_SH")] = 11;
	values[(valuesById[12] = "PLATFORM_FREEBSD_X86")] = 12;
	values[(valuesById[13] = "PLATFORM_FREEBSD_X86_64")] = 13;
	values[(valuesById[14] = "PLATFORM_BLACKBERRY_ARM")] = 14;
	values[(valuesById[15] = "PLATFORM_SONOS")] = 15;
	values[(valuesById[16] = "PLATFORM_LINUX_MIPS")] = 16;
	values[(valuesById[17] = "PLATFORM_LINUX_ARM")] = 17;
	values[(valuesById[18] = "PLATFORM_LOGITECH_ARM")] = 18;
	values[(valuesById[19] = "PLATFORM_LINUX_BLACKFIN")] = 19;
	values[(valuesById[20] = "PLATFORM_WP7_ARM")] = 20;
	values[(valuesById[21] = "PLATFORM_ONKYO_ARM")] = 21;
	values[(valuesById[22] = "PLATFORM_QNXNTO_ARM")] = 22;
	values[(valuesById[23] = "PLATFORM_BCO_ARM")] = 23;
	values[(valuesById[24] = "PLATFORM_WEBPLAYER")] = 24;
	values[(valuesById[25] = "PLATFORM_WP8_ARM")] = 25;
	values[(valuesById[26] = "PLATFORM_WP8_X86")] = 26;
	values[(valuesById[27] = "PLATFORM_WINRT_ARM")] = 27;
	values[(valuesById[28] = "PLATFORM_WINRT_X86")] = 28;
	values[(valuesById[29] = "PLATFORM_WINRT_X86_64")] = 29;
	values[(valuesById[30] = "PLATFORM_FRONTIER")] = 30;
	values[(valuesById[31] = "PLATFORM_AMIGA_PPC")] = 31;
	values[(valuesById[32] = "PLATFORM_NANRADIO_NRX901")] = 32;
	values[(valuesById[33] = "PLATFORM_HARMAN_ARM")] = 33;
	values[(valuesById[34] = "PLATFORM_SONY_PS3")] = 34;
	values[(valuesById[35] = "PLATFORM_SONY_PS4")] = 35;
	values[(valuesById[36] = "PLATFORM_IPHONE_ARM64")] = 36;
	values[(valuesById[37] = "PLATFORM_RTEMS_PPC")] = 37;
	values[(valuesById[38] = "PLATFORM_GENERIC_PARTNER")] = 38;
	values[(valuesById[39] = "PLATFORM_WIN32_X86_64")] = 39;
	values[(valuesById[40] = "PLATFORM_WATCHOS")] = 40;
	return values;
})();

/**
 * Fingerprint enum.
 * @exports Fingerprint
 * @enum {number}
 * @property {number} FINGERPRINT_GRAIN=0 FINGERPRINT_GRAIN value
 * @property {number} FINGERPRINT_HMAC_RIPEMD=1 FINGERPRINT_HMAC_RIPEMD value
 */
$root.Fingerprint = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "FINGERPRINT_GRAIN")] = 0;
	values[(valuesById[1] = "FINGERPRINT_HMAC_RIPEMD")] = 1;
	return values;
})();

/**
 * Cryptosuite enum.
 * @exports Cryptosuite
 * @enum {number}
 * @property {number} CRYPTO_SUITE_SHANNON=0 CRYPTO_SUITE_SHANNON value
 * @property {number} CRYPTO_SUITE_RC4_SHA1_HMAC=1 CRYPTO_SUITE_RC4_SHA1_HMAC value
 */
$root.Cryptosuite = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "CRYPTO_SUITE_SHANNON")] = 0;
	values[(valuesById[1] = "CRYPTO_SUITE_RC4_SHA1_HMAC")] = 1;
	return values;
})();

/**
 * Powscheme enum.
 * @exports Powscheme
 * @enum {number}
 * @property {number} POW_HASH_CASH=0 POW_HASH_CASH value
 */
$root.Powscheme = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "POW_HASH_CASH")] = 0;
	return values;
})();

$root.LoginCryptoHelloUnion = (function () {
	/**
	 * Properties of a LoginCryptoHelloUnion.
	 * @exports ILoginCryptoHelloUnion
	 * @interface ILoginCryptoHelloUnion
	 * @property {ILoginCryptoDiffieHellmanHello|null} [diffieHellman] LoginCryptoHelloUnion diffieHellman
	 */

	/**
	 * Constructs a new LoginCryptoHelloUnion.
	 * @exports LoginCryptoHelloUnion
	 * @classdesc Represents a LoginCryptoHelloUnion.
	 * @implements ILoginCryptoHelloUnion
	 * @constructor
	 * @param {ILoginCryptoHelloUnion=} [properties] Properties to set
	 */
	function LoginCryptoHelloUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * LoginCryptoHelloUnion diffieHellman.
	 * @member {ILoginCryptoDiffieHellmanHello|null|undefined} diffieHellman
	 * @memberof LoginCryptoHelloUnion
	 * @instance
	 */
	LoginCryptoHelloUnion.prototype.diffieHellman = null;

	/**
	 * Creates a new LoginCryptoHelloUnion instance using the specified properties.
	 * @function create
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {ILoginCryptoHelloUnion=} [properties] Properties to set
	 * @returns {LoginCryptoHelloUnion} LoginCryptoHelloUnion instance
	 */
	LoginCryptoHelloUnion.create = function create(properties) {
		return new LoginCryptoHelloUnion(properties);
	};

	/**
	 * Encodes the specified LoginCryptoHelloUnion message. Does not implicitly {@link LoginCryptoHelloUnion.verify|verify} messages.
	 * @function encode
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {ILoginCryptoHelloUnion} message LoginCryptoHelloUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoHelloUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.diffieHellman != null && Object.hasOwnProperty.call(message, "diffieHellman"))
			$root.LoginCryptoDiffieHellmanHello.encode(message.diffieHellman, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified LoginCryptoHelloUnion message, length delimited. Does not implicitly {@link LoginCryptoHelloUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {ILoginCryptoHelloUnion} message LoginCryptoHelloUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoHelloUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a LoginCryptoHelloUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {LoginCryptoHelloUnion} LoginCryptoHelloUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoHelloUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.LoginCryptoHelloUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.diffieHellman = $root.LoginCryptoDiffieHellmanHello.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a LoginCryptoHelloUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {LoginCryptoHelloUnion} LoginCryptoHelloUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoHelloUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a LoginCryptoHelloUnion message.
	 * @function verify
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	LoginCryptoHelloUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.diffieHellman != null && message.hasOwnProperty("diffieHellman")) {
			var error = $root.LoginCryptoDiffieHellmanHello.verify(message.diffieHellman);
			if (error) return "diffieHellman." + error;
		}
		return null;
	};

	/**
	 * Creates a LoginCryptoHelloUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {LoginCryptoHelloUnion} LoginCryptoHelloUnion
	 */
	LoginCryptoHelloUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.LoginCryptoHelloUnion) return object;
		var message = new $root.LoginCryptoHelloUnion();
		if (object.diffieHellman != null) {
			if (typeof object.diffieHellman !== "object") throw TypeError(".LoginCryptoHelloUnion.diffieHellman: object expected");
			message.diffieHellman = $root.LoginCryptoDiffieHellmanHello.fromObject(object.diffieHellman);
		}
		return message;
	};

	/**
	 * Creates a plain object from a LoginCryptoHelloUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {LoginCryptoHelloUnion} message LoginCryptoHelloUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	LoginCryptoHelloUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.diffieHellman = null;
		if (message.diffieHellman != null && message.hasOwnProperty("diffieHellman"))
			object.diffieHellman = $root.LoginCryptoDiffieHellmanHello.toObject(message.diffieHellman, options);
		return object;
	};

	/**
	 * Converts this LoginCryptoHelloUnion to JSON.
	 * @function toJSON
	 * @memberof LoginCryptoHelloUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	LoginCryptoHelloUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for LoginCryptoHelloUnion
	 * @function getTypeUrl
	 * @memberof LoginCryptoHelloUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	LoginCryptoHelloUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/LoginCryptoHelloUnion";
	};

	return LoginCryptoHelloUnion;
})();

$root.LoginCryptoDiffieHellmanHello = (function () {
	/**
	 * Properties of a LoginCryptoDiffieHellmanHello.
	 * @exports ILoginCryptoDiffieHellmanHello
	 * @interface ILoginCryptoDiffieHellmanHello
	 * @property {Uint8Array} gc LoginCryptoDiffieHellmanHello gc
	 * @property {number} serverKeysKnown LoginCryptoDiffieHellmanHello serverKeysKnown
	 */

	/**
	 * Constructs a new LoginCryptoDiffieHellmanHello.
	 * @exports LoginCryptoDiffieHellmanHello
	 * @classdesc Represents a LoginCryptoDiffieHellmanHello.
	 * @implements ILoginCryptoDiffieHellmanHello
	 * @constructor
	 * @param {ILoginCryptoDiffieHellmanHello=} [properties] Properties to set
	 */
	function LoginCryptoDiffieHellmanHello(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * LoginCryptoDiffieHellmanHello gc.
	 * @member {Uint8Array} gc
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @instance
	 */
	LoginCryptoDiffieHellmanHello.prototype.gc = $util.newBuffer([]);

	/**
	 * LoginCryptoDiffieHellmanHello serverKeysKnown.
	 * @member {number} serverKeysKnown
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @instance
	 */
	LoginCryptoDiffieHellmanHello.prototype.serverKeysKnown = 0;

	/**
	 * Creates a new LoginCryptoDiffieHellmanHello instance using the specified properties.
	 * @function create
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {ILoginCryptoDiffieHellmanHello=} [properties] Properties to set
	 * @returns {LoginCryptoDiffieHellmanHello} LoginCryptoDiffieHellmanHello instance
	 */
	LoginCryptoDiffieHellmanHello.create = function create(properties) {
		return new LoginCryptoDiffieHellmanHello(properties);
	};

	/**
	 * Encodes the specified LoginCryptoDiffieHellmanHello message. Does not implicitly {@link LoginCryptoDiffieHellmanHello.verify|verify} messages.
	 * @function encode
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {ILoginCryptoDiffieHellmanHello} message LoginCryptoDiffieHellmanHello message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoDiffieHellmanHello.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.gc);
		writer.uint32(/* id 20, wireType 0 =*/ 160).uint32(message.serverKeysKnown);
		return writer;
	};

	/**
	 * Encodes the specified LoginCryptoDiffieHellmanHello message, length delimited. Does not implicitly {@link LoginCryptoDiffieHellmanHello.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {ILoginCryptoDiffieHellmanHello} message LoginCryptoDiffieHellmanHello message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoDiffieHellmanHello.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a LoginCryptoDiffieHellmanHello message from the specified reader or buffer.
	 * @function decode
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {LoginCryptoDiffieHellmanHello} LoginCryptoDiffieHellmanHello
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoDiffieHellmanHello.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.LoginCryptoDiffieHellmanHello();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.gc = reader.bytes();
					break;
				}
				case 20: {
					message.serverKeysKnown = reader.uint32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("gc")) throw $util.ProtocolError("missing required 'gc'", { instance: message });
		if (!message.hasOwnProperty("serverKeysKnown"))
			throw $util.ProtocolError("missing required 'serverKeysKnown'", { instance: message });
		return message;
	};

	/**
	 * Decodes a LoginCryptoDiffieHellmanHello message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {LoginCryptoDiffieHellmanHello} LoginCryptoDiffieHellmanHello
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoDiffieHellmanHello.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a LoginCryptoDiffieHellmanHello message.
	 * @function verify
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	LoginCryptoDiffieHellmanHello.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.gc && typeof message.gc.length === "number") || $util.isString(message.gc))) return "gc: buffer expected";
		if (!$util.isInteger(message.serverKeysKnown)) return "serverKeysKnown: integer expected";
		return null;
	};

	/**
	 * Creates a LoginCryptoDiffieHellmanHello message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {LoginCryptoDiffieHellmanHello} LoginCryptoDiffieHellmanHello
	 */
	LoginCryptoDiffieHellmanHello.fromObject = function fromObject(object) {
		if (object instanceof $root.LoginCryptoDiffieHellmanHello) return object;
		var message = new $root.LoginCryptoDiffieHellmanHello();
		if (object.gc != null)
			if (typeof object.gc === "string")
				$util.base64.decode(object.gc, (message.gc = $util.newBuffer($util.base64.length(object.gc))), 0);
			else if (object.gc.length >= 0) message.gc = object.gc;
		if (object.serverKeysKnown != null) message.serverKeysKnown = object.serverKeysKnown >>> 0;
		return message;
	};

	/**
	 * Creates a plain object from a LoginCryptoDiffieHellmanHello message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {LoginCryptoDiffieHellmanHello} message LoginCryptoDiffieHellmanHello
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	LoginCryptoDiffieHellmanHello.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			if (options.bytes === String) object.gc = "";
			else {
				object.gc = [];
				if (options.bytes !== Array) object.gc = $util.newBuffer(object.gc);
			}
			object.serverKeysKnown = 0;
		}
		if (message.gc != null && message.hasOwnProperty("gc"))
			object.gc =
				options.bytes === String
					? $util.base64.encode(message.gc, 0, message.gc.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.gc)
					: message.gc;
		if (message.serverKeysKnown != null && message.hasOwnProperty("serverKeysKnown")) object.serverKeysKnown = message.serverKeysKnown;
		return object;
	};

	/**
	 * Converts this LoginCryptoDiffieHellmanHello to JSON.
	 * @function toJSON
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	LoginCryptoDiffieHellmanHello.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for LoginCryptoDiffieHellmanHello
	 * @function getTypeUrl
	 * @memberof LoginCryptoDiffieHellmanHello
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	LoginCryptoDiffieHellmanHello.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/LoginCryptoDiffieHellmanHello";
	};

	return LoginCryptoDiffieHellmanHello;
})();

$root.FeatureSet = (function () {
	/**
	 * Properties of a FeatureSet.
	 * @exports IFeatureSet
	 * @interface IFeatureSet
	 * @property {boolean|null} [autoupdate2] FeatureSet autoupdate2
	 * @property {boolean|null} [currentLocation] FeatureSet currentLocation
	 */

	/**
	 * Constructs a new FeatureSet.
	 * @exports FeatureSet
	 * @classdesc Represents a FeatureSet.
	 * @implements IFeatureSet
	 * @constructor
	 * @param {IFeatureSet=} [properties] Properties to set
	 */
	function FeatureSet(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * FeatureSet autoupdate2.
	 * @member {boolean} autoupdate2
	 * @memberof FeatureSet
	 * @instance
	 */
	FeatureSet.prototype.autoupdate2 = false;

	/**
	 * FeatureSet currentLocation.
	 * @member {boolean} currentLocation
	 * @memberof FeatureSet
	 * @instance
	 */
	FeatureSet.prototype.currentLocation = false;

	/**
	 * Creates a new FeatureSet instance using the specified properties.
	 * @function create
	 * @memberof FeatureSet
	 * @static
	 * @param {IFeatureSet=} [properties] Properties to set
	 * @returns {FeatureSet} FeatureSet instance
	 */
	FeatureSet.create = function create(properties) {
		return new FeatureSet(properties);
	};

	/**
	 * Encodes the specified FeatureSet message. Does not implicitly {@link FeatureSet.verify|verify} messages.
	 * @function encode
	 * @memberof FeatureSet
	 * @static
	 * @param {IFeatureSet} message FeatureSet message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FeatureSet.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.autoupdate2 != null && Object.hasOwnProperty.call(message, "autoupdate2"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.autoupdate2);
		if (message.currentLocation != null && Object.hasOwnProperty.call(message, "currentLocation"))
			writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.currentLocation);
		return writer;
	};

	/**
	 * Encodes the specified FeatureSet message, length delimited. Does not implicitly {@link FeatureSet.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof FeatureSet
	 * @static
	 * @param {IFeatureSet} message FeatureSet message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FeatureSet.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a FeatureSet message from the specified reader or buffer.
	 * @function decode
	 * @memberof FeatureSet
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {FeatureSet} FeatureSet
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FeatureSet.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.FeatureSet();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.autoupdate2 = reader.bool();
					break;
				}
				case 2: {
					message.currentLocation = reader.bool();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a FeatureSet message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof FeatureSet
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {FeatureSet} FeatureSet
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FeatureSet.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a FeatureSet message.
	 * @function verify
	 * @memberof FeatureSet
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	FeatureSet.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.autoupdate2 != null && message.hasOwnProperty("autoupdate2"))
			if (typeof message.autoupdate2 !== "boolean") return "autoupdate2: boolean expected";
		if (message.currentLocation != null && message.hasOwnProperty("currentLocation"))
			if (typeof message.currentLocation !== "boolean") return "currentLocation: boolean expected";
		return null;
	};

	/**
	 * Creates a FeatureSet message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof FeatureSet
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {FeatureSet} FeatureSet
	 */
	FeatureSet.fromObject = function fromObject(object) {
		if (object instanceof $root.FeatureSet) return object;
		var message = new $root.FeatureSet();
		if (object.autoupdate2 != null) message.autoupdate2 = Boolean(object.autoupdate2);
		if (object.currentLocation != null) message.currentLocation = Boolean(object.currentLocation);
		return message;
	};

	/**
	 * Creates a plain object from a FeatureSet message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof FeatureSet
	 * @static
	 * @param {FeatureSet} message FeatureSet
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	FeatureSet.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.autoupdate2 = false;
			object.currentLocation = false;
		}
		if (message.autoupdate2 != null && message.hasOwnProperty("autoupdate2")) object.autoupdate2 = message.autoupdate2;
		if (message.currentLocation != null && message.hasOwnProperty("currentLocation")) object.currentLocation = message.currentLocation;
		return object;
	};

	/**
	 * Converts this FeatureSet to JSON.
	 * @function toJSON
	 * @memberof FeatureSet
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	FeatureSet.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for FeatureSet
	 * @function getTypeUrl
	 * @memberof FeatureSet
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	FeatureSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/FeatureSet";
	};

	return FeatureSet;
})();

$root.APResponseMessage = (function () {
	/**
	 * Properties of a APResponseMessage.
	 * @exports IAPResponseMessage
	 * @interface IAPResponseMessage
	 * @property {IAPChallenge|null} [challenge] APResponseMessage challenge
	 * @property {IUpgradeRequiredMessage|null} [upgrade] APResponseMessage upgrade
	 * @property {IAPLoginFailed|null} [loginFailed] APResponseMessage loginFailed
	 */

	/**
	 * Constructs a new APResponseMessage.
	 * @exports APResponseMessage
	 * @classdesc Represents a APResponseMessage.
	 * @implements IAPResponseMessage
	 * @constructor
	 * @param {IAPResponseMessage=} [properties] Properties to set
	 */
	function APResponseMessage(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * APResponseMessage challenge.
	 * @member {IAPChallenge|null|undefined} challenge
	 * @memberof APResponseMessage
	 * @instance
	 */
	APResponseMessage.prototype.challenge = null;

	/**
	 * APResponseMessage upgrade.
	 * @member {IUpgradeRequiredMessage|null|undefined} upgrade
	 * @memberof APResponseMessage
	 * @instance
	 */
	APResponseMessage.prototype.upgrade = null;

	/**
	 * APResponseMessage loginFailed.
	 * @member {IAPLoginFailed|null|undefined} loginFailed
	 * @memberof APResponseMessage
	 * @instance
	 */
	APResponseMessage.prototype.loginFailed = null;

	/**
	 * Creates a new APResponseMessage instance using the specified properties.
	 * @function create
	 * @memberof APResponseMessage
	 * @static
	 * @param {IAPResponseMessage=} [properties] Properties to set
	 * @returns {APResponseMessage} APResponseMessage instance
	 */
	APResponseMessage.create = function create(properties) {
		return new APResponseMessage(properties);
	};

	/**
	 * Encodes the specified APResponseMessage message. Does not implicitly {@link APResponseMessage.verify|verify} messages.
	 * @function encode
	 * @memberof APResponseMessage
	 * @static
	 * @param {IAPResponseMessage} message APResponseMessage message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	APResponseMessage.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.challenge != null && Object.hasOwnProperty.call(message, "challenge"))
			$root.APChallenge.encode(message.challenge, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.upgrade != null && Object.hasOwnProperty.call(message, "upgrade"))
			$root.UpgradeRequiredMessage.encode(message.upgrade, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		if (message.loginFailed != null && Object.hasOwnProperty.call(message, "loginFailed"))
			$root.APLoginFailed.encode(message.loginFailed, writer.uint32(/* id 30, wireType 2 =*/ 242).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified APResponseMessage message, length delimited. Does not implicitly {@link APResponseMessage.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof APResponseMessage
	 * @static
	 * @param {IAPResponseMessage} message APResponseMessage message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	APResponseMessage.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a APResponseMessage message from the specified reader or buffer.
	 * @function decode
	 * @memberof APResponseMessage
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {APResponseMessage} APResponseMessage
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	APResponseMessage.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.APResponseMessage();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.challenge = $root.APChallenge.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.upgrade = $root.UpgradeRequiredMessage.decode(reader, reader.uint32());
					break;
				}
				case 30: {
					message.loginFailed = $root.APLoginFailed.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a APResponseMessage message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof APResponseMessage
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {APResponseMessage} APResponseMessage
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	APResponseMessage.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a APResponseMessage message.
	 * @function verify
	 * @memberof APResponseMessage
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	APResponseMessage.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.challenge != null && message.hasOwnProperty("challenge")) {
			var error = $root.APChallenge.verify(message.challenge);
			if (error) return "challenge." + error;
		}
		if (message.upgrade != null && message.hasOwnProperty("upgrade")) {
			var error = $root.UpgradeRequiredMessage.verify(message.upgrade);
			if (error) return "upgrade." + error;
		}
		if (message.loginFailed != null && message.hasOwnProperty("loginFailed")) {
			var error = $root.APLoginFailed.verify(message.loginFailed);
			if (error) return "loginFailed." + error;
		}
		return null;
	};

	/**
	 * Creates a APResponseMessage message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof APResponseMessage
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {APResponseMessage} APResponseMessage
	 */
	APResponseMessage.fromObject = function fromObject(object) {
		if (object instanceof $root.APResponseMessage) return object;
		var message = new $root.APResponseMessage();
		if (object.challenge != null) {
			if (typeof object.challenge !== "object") throw TypeError(".APResponseMessage.challenge: object expected");
			message.challenge = $root.APChallenge.fromObject(object.challenge);
		}
		if (object.upgrade != null) {
			if (typeof object.upgrade !== "object") throw TypeError(".APResponseMessage.upgrade: object expected");
			message.upgrade = $root.UpgradeRequiredMessage.fromObject(object.upgrade);
		}
		if (object.loginFailed != null) {
			if (typeof object.loginFailed !== "object") throw TypeError(".APResponseMessage.loginFailed: object expected");
			message.loginFailed = $root.APLoginFailed.fromObject(object.loginFailed);
		}
		return message;
	};

	/**
	 * Creates a plain object from a APResponseMessage message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof APResponseMessage
	 * @static
	 * @param {APResponseMessage} message APResponseMessage
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	APResponseMessage.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.challenge = null;
			object.upgrade = null;
			object.loginFailed = null;
		}
		if (message.challenge != null && message.hasOwnProperty("challenge"))
			object.challenge = $root.APChallenge.toObject(message.challenge, options);
		if (message.upgrade != null && message.hasOwnProperty("upgrade"))
			object.upgrade = $root.UpgradeRequiredMessage.toObject(message.upgrade, options);
		if (message.loginFailed != null && message.hasOwnProperty("loginFailed"))
			object.loginFailed = $root.APLoginFailed.toObject(message.loginFailed, options);
		return object;
	};

	/**
	 * Converts this APResponseMessage to JSON.
	 * @function toJSON
	 * @memberof APResponseMessage
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	APResponseMessage.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for APResponseMessage
	 * @function getTypeUrl
	 * @memberof APResponseMessage
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	APResponseMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/APResponseMessage";
	};

	return APResponseMessage;
})();

$root.APChallenge = (function () {
	/**
	 * Properties of a APChallenge.
	 * @exports IAPChallenge
	 * @interface IAPChallenge
	 * @property {ILoginCryptoChallengeUnion} loginCryptoChallenge APChallenge loginCryptoChallenge
	 * @property {IFingerprintChallengeUnion} fingerprintChallenge APChallenge fingerprintChallenge
	 * @property {IPoWChallengeUnion} powChallenge APChallenge powChallenge
	 * @property {ICryptoChallengeUnion} cryptoChallenge APChallenge cryptoChallenge
	 * @property {Uint8Array} serverNonce APChallenge serverNonce
	 * @property {Uint8Array|null} [padding] APChallenge padding
	 */

	/**
	 * Constructs a new APChallenge.
	 * @exports APChallenge
	 * @classdesc Represents a APChallenge.
	 * @implements IAPChallenge
	 * @constructor
	 * @param {IAPChallenge=} [properties] Properties to set
	 */
	function APChallenge(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * APChallenge loginCryptoChallenge.
	 * @member {ILoginCryptoChallengeUnion} loginCryptoChallenge
	 * @memberof APChallenge
	 * @instance
	 */
	APChallenge.prototype.loginCryptoChallenge = null;

	/**
	 * APChallenge fingerprintChallenge.
	 * @member {IFingerprintChallengeUnion} fingerprintChallenge
	 * @memberof APChallenge
	 * @instance
	 */
	APChallenge.prototype.fingerprintChallenge = null;

	/**
	 * APChallenge powChallenge.
	 * @member {IPoWChallengeUnion} powChallenge
	 * @memberof APChallenge
	 * @instance
	 */
	APChallenge.prototype.powChallenge = null;

	/**
	 * APChallenge cryptoChallenge.
	 * @member {ICryptoChallengeUnion} cryptoChallenge
	 * @memberof APChallenge
	 * @instance
	 */
	APChallenge.prototype.cryptoChallenge = null;

	/**
	 * APChallenge serverNonce.
	 * @member {Uint8Array} serverNonce
	 * @memberof APChallenge
	 * @instance
	 */
	APChallenge.prototype.serverNonce = $util.newBuffer([]);

	/**
	 * APChallenge padding.
	 * @member {Uint8Array} padding
	 * @memberof APChallenge
	 * @instance
	 */
	APChallenge.prototype.padding = $util.newBuffer([]);

	/**
	 * Creates a new APChallenge instance using the specified properties.
	 * @function create
	 * @memberof APChallenge
	 * @static
	 * @param {IAPChallenge=} [properties] Properties to set
	 * @returns {APChallenge} APChallenge instance
	 */
	APChallenge.create = function create(properties) {
		return new APChallenge(properties);
	};

	/**
	 * Encodes the specified APChallenge message. Does not implicitly {@link APChallenge.verify|verify} messages.
	 * @function encode
	 * @memberof APChallenge
	 * @static
	 * @param {IAPChallenge} message APChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	APChallenge.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		$root.LoginCryptoChallengeUnion.encode(message.loginCryptoChallenge, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		$root.FingerprintChallengeUnion.encode(message.fingerprintChallenge, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		$root.PoWChallengeUnion.encode(message.powChallenge, writer.uint32(/* id 30, wireType 2 =*/ 242).fork()).ldelim();
		$root.CryptoChallengeUnion.encode(message.cryptoChallenge, writer.uint32(/* id 40, wireType 2 =*/ 322).fork()).ldelim();
		writer.uint32(/* id 50, wireType 2 =*/ 402).bytes(message.serverNonce);
		if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
			writer.uint32(/* id 60, wireType 2 =*/ 482).bytes(message.padding);
		return writer;
	};

	/**
	 * Encodes the specified APChallenge message, length delimited. Does not implicitly {@link APChallenge.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof APChallenge
	 * @static
	 * @param {IAPChallenge} message APChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	APChallenge.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a APChallenge message from the specified reader or buffer.
	 * @function decode
	 * @memberof APChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {APChallenge} APChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	APChallenge.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.APChallenge();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.loginCryptoChallenge = $root.LoginCryptoChallengeUnion.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.fingerprintChallenge = $root.FingerprintChallengeUnion.decode(reader, reader.uint32());
					break;
				}
				case 30: {
					message.powChallenge = $root.PoWChallengeUnion.decode(reader, reader.uint32());
					break;
				}
				case 40: {
					message.cryptoChallenge = $root.CryptoChallengeUnion.decode(reader, reader.uint32());
					break;
				}
				case 50: {
					message.serverNonce = reader.bytes();
					break;
				}
				case 60: {
					message.padding = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("loginCryptoChallenge"))
			throw $util.ProtocolError("missing required 'loginCryptoChallenge'", { instance: message });
		if (!message.hasOwnProperty("fingerprintChallenge"))
			throw $util.ProtocolError("missing required 'fingerprintChallenge'", { instance: message });
		if (!message.hasOwnProperty("powChallenge")) throw $util.ProtocolError("missing required 'powChallenge'", { instance: message });
		if (!message.hasOwnProperty("cryptoChallenge"))
			throw $util.ProtocolError("missing required 'cryptoChallenge'", { instance: message });
		if (!message.hasOwnProperty("serverNonce")) throw $util.ProtocolError("missing required 'serverNonce'", { instance: message });
		return message;
	};

	/**
	 * Decodes a APChallenge message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof APChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {APChallenge} APChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	APChallenge.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a APChallenge message.
	 * @function verify
	 * @memberof APChallenge
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	APChallenge.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		{
			var error = $root.LoginCryptoChallengeUnion.verify(message.loginCryptoChallenge);
			if (error) return "loginCryptoChallenge." + error;
		}
		{
			var error = $root.FingerprintChallengeUnion.verify(message.fingerprintChallenge);
			if (error) return "fingerprintChallenge." + error;
		}
		{
			var error = $root.PoWChallengeUnion.verify(message.powChallenge);
			if (error) return "powChallenge." + error;
		}
		{
			var error = $root.CryptoChallengeUnion.verify(message.cryptoChallenge);
			if (error) return "cryptoChallenge." + error;
		}
		if (!((message.serverNonce && typeof message.serverNonce.length === "number") || $util.isString(message.serverNonce)))
			return "serverNonce: buffer expected";
		if (message.padding != null && message.hasOwnProperty("padding"))
			if (!((message.padding && typeof message.padding.length === "number") || $util.isString(message.padding)))
				return "padding: buffer expected";
		return null;
	};

	/**
	 * Creates a APChallenge message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof APChallenge
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {APChallenge} APChallenge
	 */
	APChallenge.fromObject = function fromObject(object) {
		if (object instanceof $root.APChallenge) return object;
		var message = new $root.APChallenge();
		if (object.loginCryptoChallenge != null) {
			if (typeof object.loginCryptoChallenge !== "object") throw TypeError(".APChallenge.loginCryptoChallenge: object expected");
			message.loginCryptoChallenge = $root.LoginCryptoChallengeUnion.fromObject(object.loginCryptoChallenge);
		}
		if (object.fingerprintChallenge != null) {
			if (typeof object.fingerprintChallenge !== "object") throw TypeError(".APChallenge.fingerprintChallenge: object expected");
			message.fingerprintChallenge = $root.FingerprintChallengeUnion.fromObject(object.fingerprintChallenge);
		}
		if (object.powChallenge != null) {
			if (typeof object.powChallenge !== "object") throw TypeError(".APChallenge.powChallenge: object expected");
			message.powChallenge = $root.PoWChallengeUnion.fromObject(object.powChallenge);
		}
		if (object.cryptoChallenge != null) {
			if (typeof object.cryptoChallenge !== "object") throw TypeError(".APChallenge.cryptoChallenge: object expected");
			message.cryptoChallenge = $root.CryptoChallengeUnion.fromObject(object.cryptoChallenge);
		}
		if (object.serverNonce != null)
			if (typeof object.serverNonce === "string")
				$util.base64.decode(
					object.serverNonce,
					(message.serverNonce = $util.newBuffer($util.base64.length(object.serverNonce))),
					0,
				);
			else if (object.serverNonce.length >= 0) message.serverNonce = object.serverNonce;
		if (object.padding != null)
			if (typeof object.padding === "string")
				$util.base64.decode(object.padding, (message.padding = $util.newBuffer($util.base64.length(object.padding))), 0);
			else if (object.padding.length >= 0) message.padding = object.padding;
		return message;
	};

	/**
	 * Creates a plain object from a APChallenge message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof APChallenge
	 * @static
	 * @param {APChallenge} message APChallenge
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	APChallenge.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.loginCryptoChallenge = null;
			object.fingerprintChallenge = null;
			object.powChallenge = null;
			object.cryptoChallenge = null;
			if (options.bytes === String) object.serverNonce = "";
			else {
				object.serverNonce = [];
				if (options.bytes !== Array) object.serverNonce = $util.newBuffer(object.serverNonce);
			}
			if (options.bytes === String) object.padding = "";
			else {
				object.padding = [];
				if (options.bytes !== Array) object.padding = $util.newBuffer(object.padding);
			}
		}
		if (message.loginCryptoChallenge != null && message.hasOwnProperty("loginCryptoChallenge"))
			object.loginCryptoChallenge = $root.LoginCryptoChallengeUnion.toObject(message.loginCryptoChallenge, options);
		if (message.fingerprintChallenge != null && message.hasOwnProperty("fingerprintChallenge"))
			object.fingerprintChallenge = $root.FingerprintChallengeUnion.toObject(message.fingerprintChallenge, options);
		if (message.powChallenge != null && message.hasOwnProperty("powChallenge"))
			object.powChallenge = $root.PoWChallengeUnion.toObject(message.powChallenge, options);
		if (message.cryptoChallenge != null && message.hasOwnProperty("cryptoChallenge"))
			object.cryptoChallenge = $root.CryptoChallengeUnion.toObject(message.cryptoChallenge, options);
		if (message.serverNonce != null && message.hasOwnProperty("serverNonce"))
			object.serverNonce =
				options.bytes === String
					? $util.base64.encode(message.serverNonce, 0, message.serverNonce.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.serverNonce)
					: message.serverNonce;
		if (message.padding != null && message.hasOwnProperty("padding"))
			object.padding =
				options.bytes === String
					? $util.base64.encode(message.padding, 0, message.padding.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.padding)
					: message.padding;
		return object;
	};

	/**
	 * Converts this APChallenge to JSON.
	 * @function toJSON
	 * @memberof APChallenge
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	APChallenge.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for APChallenge
	 * @function getTypeUrl
	 * @memberof APChallenge
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	APChallenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/APChallenge";
	};

	return APChallenge;
})();

$root.LoginCryptoChallengeUnion = (function () {
	/**
	 * Properties of a LoginCryptoChallengeUnion.
	 * @exports ILoginCryptoChallengeUnion
	 * @interface ILoginCryptoChallengeUnion
	 * @property {ILoginCryptoDiffieHellmanChallenge|null} [diffieHellman] LoginCryptoChallengeUnion diffieHellman
	 */

	/**
	 * Constructs a new LoginCryptoChallengeUnion.
	 * @exports LoginCryptoChallengeUnion
	 * @classdesc Represents a LoginCryptoChallengeUnion.
	 * @implements ILoginCryptoChallengeUnion
	 * @constructor
	 * @param {ILoginCryptoChallengeUnion=} [properties] Properties to set
	 */
	function LoginCryptoChallengeUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * LoginCryptoChallengeUnion diffieHellman.
	 * @member {ILoginCryptoDiffieHellmanChallenge|null|undefined} diffieHellman
	 * @memberof LoginCryptoChallengeUnion
	 * @instance
	 */
	LoginCryptoChallengeUnion.prototype.diffieHellman = null;

	/**
	 * Creates a new LoginCryptoChallengeUnion instance using the specified properties.
	 * @function create
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {ILoginCryptoChallengeUnion=} [properties] Properties to set
	 * @returns {LoginCryptoChallengeUnion} LoginCryptoChallengeUnion instance
	 */
	LoginCryptoChallengeUnion.create = function create(properties) {
		return new LoginCryptoChallengeUnion(properties);
	};

	/**
	 * Encodes the specified LoginCryptoChallengeUnion message. Does not implicitly {@link LoginCryptoChallengeUnion.verify|verify} messages.
	 * @function encode
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {ILoginCryptoChallengeUnion} message LoginCryptoChallengeUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoChallengeUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.diffieHellman != null && Object.hasOwnProperty.call(message, "diffieHellman"))
			$root.LoginCryptoDiffieHellmanChallenge.encode(
				message.diffieHellman,
				writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
			).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified LoginCryptoChallengeUnion message, length delimited. Does not implicitly {@link LoginCryptoChallengeUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {ILoginCryptoChallengeUnion} message LoginCryptoChallengeUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoChallengeUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a LoginCryptoChallengeUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {LoginCryptoChallengeUnion} LoginCryptoChallengeUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoChallengeUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.LoginCryptoChallengeUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.diffieHellman = $root.LoginCryptoDiffieHellmanChallenge.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a LoginCryptoChallengeUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {LoginCryptoChallengeUnion} LoginCryptoChallengeUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoChallengeUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a LoginCryptoChallengeUnion message.
	 * @function verify
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	LoginCryptoChallengeUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.diffieHellman != null && message.hasOwnProperty("diffieHellman")) {
			var error = $root.LoginCryptoDiffieHellmanChallenge.verify(message.diffieHellman);
			if (error) return "diffieHellman." + error;
		}
		return null;
	};

	/**
	 * Creates a LoginCryptoChallengeUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {LoginCryptoChallengeUnion} LoginCryptoChallengeUnion
	 */
	LoginCryptoChallengeUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.LoginCryptoChallengeUnion) return object;
		var message = new $root.LoginCryptoChallengeUnion();
		if (object.diffieHellman != null) {
			if (typeof object.diffieHellman !== "object") throw TypeError(".LoginCryptoChallengeUnion.diffieHellman: object expected");
			message.diffieHellman = $root.LoginCryptoDiffieHellmanChallenge.fromObject(object.diffieHellman);
		}
		return message;
	};

	/**
	 * Creates a plain object from a LoginCryptoChallengeUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {LoginCryptoChallengeUnion} message LoginCryptoChallengeUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	LoginCryptoChallengeUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.diffieHellman = null;
		if (message.diffieHellman != null && message.hasOwnProperty("diffieHellman"))
			object.diffieHellman = $root.LoginCryptoDiffieHellmanChallenge.toObject(message.diffieHellman, options);
		return object;
	};

	/**
	 * Converts this LoginCryptoChallengeUnion to JSON.
	 * @function toJSON
	 * @memberof LoginCryptoChallengeUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	LoginCryptoChallengeUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for LoginCryptoChallengeUnion
	 * @function getTypeUrl
	 * @memberof LoginCryptoChallengeUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	LoginCryptoChallengeUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/LoginCryptoChallengeUnion";
	};

	return LoginCryptoChallengeUnion;
})();

$root.LoginCryptoDiffieHellmanChallenge = (function () {
	/**
	 * Properties of a LoginCryptoDiffieHellmanChallenge.
	 * @exports ILoginCryptoDiffieHellmanChallenge
	 * @interface ILoginCryptoDiffieHellmanChallenge
	 * @property {Uint8Array} gs LoginCryptoDiffieHellmanChallenge gs
	 * @property {number} serverSignatureKey LoginCryptoDiffieHellmanChallenge serverSignatureKey
	 * @property {Uint8Array} gsSignature LoginCryptoDiffieHellmanChallenge gsSignature
	 */

	/**
	 * Constructs a new LoginCryptoDiffieHellmanChallenge.
	 * @exports LoginCryptoDiffieHellmanChallenge
	 * @classdesc Represents a LoginCryptoDiffieHellmanChallenge.
	 * @implements ILoginCryptoDiffieHellmanChallenge
	 * @constructor
	 * @param {ILoginCryptoDiffieHellmanChallenge=} [properties] Properties to set
	 */
	function LoginCryptoDiffieHellmanChallenge(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * LoginCryptoDiffieHellmanChallenge gs.
	 * @member {Uint8Array} gs
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @instance
	 */
	LoginCryptoDiffieHellmanChallenge.prototype.gs = $util.newBuffer([]);

	/**
	 * LoginCryptoDiffieHellmanChallenge serverSignatureKey.
	 * @member {number} serverSignatureKey
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @instance
	 */
	LoginCryptoDiffieHellmanChallenge.prototype.serverSignatureKey = 0;

	/**
	 * LoginCryptoDiffieHellmanChallenge gsSignature.
	 * @member {Uint8Array} gsSignature
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @instance
	 */
	LoginCryptoDiffieHellmanChallenge.prototype.gsSignature = $util.newBuffer([]);

	/**
	 * Creates a new LoginCryptoDiffieHellmanChallenge instance using the specified properties.
	 * @function create
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {ILoginCryptoDiffieHellmanChallenge=} [properties] Properties to set
	 * @returns {LoginCryptoDiffieHellmanChallenge} LoginCryptoDiffieHellmanChallenge instance
	 */
	LoginCryptoDiffieHellmanChallenge.create = function create(properties) {
		return new LoginCryptoDiffieHellmanChallenge(properties);
	};

	/**
	 * Encodes the specified LoginCryptoDiffieHellmanChallenge message. Does not implicitly {@link LoginCryptoDiffieHellmanChallenge.verify|verify} messages.
	 * @function encode
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {ILoginCryptoDiffieHellmanChallenge} message LoginCryptoDiffieHellmanChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoDiffieHellmanChallenge.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.gs);
		writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.serverSignatureKey);
		writer.uint32(/* id 30, wireType 2 =*/ 242).bytes(message.gsSignature);
		return writer;
	};

	/**
	 * Encodes the specified LoginCryptoDiffieHellmanChallenge message, length delimited. Does not implicitly {@link LoginCryptoDiffieHellmanChallenge.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {ILoginCryptoDiffieHellmanChallenge} message LoginCryptoDiffieHellmanChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoDiffieHellmanChallenge.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a LoginCryptoDiffieHellmanChallenge message from the specified reader or buffer.
	 * @function decode
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {LoginCryptoDiffieHellmanChallenge} LoginCryptoDiffieHellmanChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoDiffieHellmanChallenge.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.LoginCryptoDiffieHellmanChallenge();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.gs = reader.bytes();
					break;
				}
				case 20: {
					message.serverSignatureKey = reader.int32();
					break;
				}
				case 30: {
					message.gsSignature = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("gs")) throw $util.ProtocolError("missing required 'gs'", { instance: message });
		if (!message.hasOwnProperty("serverSignatureKey"))
			throw $util.ProtocolError("missing required 'serverSignatureKey'", { instance: message });
		if (!message.hasOwnProperty("gsSignature")) throw $util.ProtocolError("missing required 'gsSignature'", { instance: message });
		return message;
	};

	/**
	 * Decodes a LoginCryptoDiffieHellmanChallenge message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {LoginCryptoDiffieHellmanChallenge} LoginCryptoDiffieHellmanChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoDiffieHellmanChallenge.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a LoginCryptoDiffieHellmanChallenge message.
	 * @function verify
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	LoginCryptoDiffieHellmanChallenge.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.gs && typeof message.gs.length === "number") || $util.isString(message.gs))) return "gs: buffer expected";
		if (!$util.isInteger(message.serverSignatureKey)) return "serverSignatureKey: integer expected";
		if (!((message.gsSignature && typeof message.gsSignature.length === "number") || $util.isString(message.gsSignature)))
			return "gsSignature: buffer expected";
		return null;
	};

	/**
	 * Creates a LoginCryptoDiffieHellmanChallenge message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {LoginCryptoDiffieHellmanChallenge} LoginCryptoDiffieHellmanChallenge
	 */
	LoginCryptoDiffieHellmanChallenge.fromObject = function fromObject(object) {
		if (object instanceof $root.LoginCryptoDiffieHellmanChallenge) return object;
		var message = new $root.LoginCryptoDiffieHellmanChallenge();
		if (object.gs != null)
			if (typeof object.gs === "string")
				$util.base64.decode(object.gs, (message.gs = $util.newBuffer($util.base64.length(object.gs))), 0);
			else if (object.gs.length >= 0) message.gs = object.gs;
		if (object.serverSignatureKey != null) message.serverSignatureKey = object.serverSignatureKey | 0;
		if (object.gsSignature != null)
			if (typeof object.gsSignature === "string")
				$util.base64.decode(
					object.gsSignature,
					(message.gsSignature = $util.newBuffer($util.base64.length(object.gsSignature))),
					0,
				);
			else if (object.gsSignature.length >= 0) message.gsSignature = object.gsSignature;
		return message;
	};

	/**
	 * Creates a plain object from a LoginCryptoDiffieHellmanChallenge message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {LoginCryptoDiffieHellmanChallenge} message LoginCryptoDiffieHellmanChallenge
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	LoginCryptoDiffieHellmanChallenge.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			if (options.bytes === String) object.gs = "";
			else {
				object.gs = [];
				if (options.bytes !== Array) object.gs = $util.newBuffer(object.gs);
			}
			object.serverSignatureKey = 0;
			if (options.bytes === String) object.gsSignature = "";
			else {
				object.gsSignature = [];
				if (options.bytes !== Array) object.gsSignature = $util.newBuffer(object.gsSignature);
			}
		}
		if (message.gs != null && message.hasOwnProperty("gs"))
			object.gs =
				options.bytes === String
					? $util.base64.encode(message.gs, 0, message.gs.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.gs)
					: message.gs;
		if (message.serverSignatureKey != null && message.hasOwnProperty("serverSignatureKey"))
			object.serverSignatureKey = message.serverSignatureKey;
		if (message.gsSignature != null && message.hasOwnProperty("gsSignature"))
			object.gsSignature =
				options.bytes === String
					? $util.base64.encode(message.gsSignature, 0, message.gsSignature.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.gsSignature)
					: message.gsSignature;
		return object;
	};

	/**
	 * Converts this LoginCryptoDiffieHellmanChallenge to JSON.
	 * @function toJSON
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	LoginCryptoDiffieHellmanChallenge.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for LoginCryptoDiffieHellmanChallenge
	 * @function getTypeUrl
	 * @memberof LoginCryptoDiffieHellmanChallenge
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	LoginCryptoDiffieHellmanChallenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/LoginCryptoDiffieHellmanChallenge";
	};

	return LoginCryptoDiffieHellmanChallenge;
})();

$root.FingerprintChallengeUnion = (function () {
	/**
	 * Properties of a FingerprintChallengeUnion.
	 * @exports IFingerprintChallengeUnion
	 * @interface IFingerprintChallengeUnion
	 * @property {IFingerprintGrainChallenge|null} [grain] FingerprintChallengeUnion grain
	 * @property {IFingerprintHmacRipemdChallenge|null} [hmacRipemd] FingerprintChallengeUnion hmacRipemd
	 */

	/**
	 * Constructs a new FingerprintChallengeUnion.
	 * @exports FingerprintChallengeUnion
	 * @classdesc Represents a FingerprintChallengeUnion.
	 * @implements IFingerprintChallengeUnion
	 * @constructor
	 * @param {IFingerprintChallengeUnion=} [properties] Properties to set
	 */
	function FingerprintChallengeUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * FingerprintChallengeUnion grain.
	 * @member {IFingerprintGrainChallenge|null|undefined} grain
	 * @memberof FingerprintChallengeUnion
	 * @instance
	 */
	FingerprintChallengeUnion.prototype.grain = null;

	/**
	 * FingerprintChallengeUnion hmacRipemd.
	 * @member {IFingerprintHmacRipemdChallenge|null|undefined} hmacRipemd
	 * @memberof FingerprintChallengeUnion
	 * @instance
	 */
	FingerprintChallengeUnion.prototype.hmacRipemd = null;

	/**
	 * Creates a new FingerprintChallengeUnion instance using the specified properties.
	 * @function create
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {IFingerprintChallengeUnion=} [properties] Properties to set
	 * @returns {FingerprintChallengeUnion} FingerprintChallengeUnion instance
	 */
	FingerprintChallengeUnion.create = function create(properties) {
		return new FingerprintChallengeUnion(properties);
	};

	/**
	 * Encodes the specified FingerprintChallengeUnion message. Does not implicitly {@link FingerprintChallengeUnion.verify|verify} messages.
	 * @function encode
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {IFingerprintChallengeUnion} message FingerprintChallengeUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintChallengeUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.grain != null && Object.hasOwnProperty.call(message, "grain"))
			$root.FingerprintGrainChallenge.encode(message.grain, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.hmacRipemd != null && Object.hasOwnProperty.call(message, "hmacRipemd"))
			$root.FingerprintHmacRipemdChallenge.encode(message.hmacRipemd, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified FingerprintChallengeUnion message, length delimited. Does not implicitly {@link FingerprintChallengeUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {IFingerprintChallengeUnion} message FingerprintChallengeUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintChallengeUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a FingerprintChallengeUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {FingerprintChallengeUnion} FingerprintChallengeUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintChallengeUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.FingerprintChallengeUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.grain = $root.FingerprintGrainChallenge.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.hmacRipemd = $root.FingerprintHmacRipemdChallenge.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a FingerprintChallengeUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {FingerprintChallengeUnion} FingerprintChallengeUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintChallengeUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a FingerprintChallengeUnion message.
	 * @function verify
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	FingerprintChallengeUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.grain != null && message.hasOwnProperty("grain")) {
			var error = $root.FingerprintGrainChallenge.verify(message.grain);
			if (error) return "grain." + error;
		}
		if (message.hmacRipemd != null && message.hasOwnProperty("hmacRipemd")) {
			var error = $root.FingerprintHmacRipemdChallenge.verify(message.hmacRipemd);
			if (error) return "hmacRipemd." + error;
		}
		return null;
	};

	/**
	 * Creates a FingerprintChallengeUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {FingerprintChallengeUnion} FingerprintChallengeUnion
	 */
	FingerprintChallengeUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.FingerprintChallengeUnion) return object;
		var message = new $root.FingerprintChallengeUnion();
		if (object.grain != null) {
			if (typeof object.grain !== "object") throw TypeError(".FingerprintChallengeUnion.grain: object expected");
			message.grain = $root.FingerprintGrainChallenge.fromObject(object.grain);
		}
		if (object.hmacRipemd != null) {
			if (typeof object.hmacRipemd !== "object") throw TypeError(".FingerprintChallengeUnion.hmacRipemd: object expected");
			message.hmacRipemd = $root.FingerprintHmacRipemdChallenge.fromObject(object.hmacRipemd);
		}
		return message;
	};

	/**
	 * Creates a plain object from a FingerprintChallengeUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {FingerprintChallengeUnion} message FingerprintChallengeUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	FingerprintChallengeUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.grain = null;
			object.hmacRipemd = null;
		}
		if (message.grain != null && message.hasOwnProperty("grain"))
			object.grain = $root.FingerprintGrainChallenge.toObject(message.grain, options);
		if (message.hmacRipemd != null && message.hasOwnProperty("hmacRipemd"))
			object.hmacRipemd = $root.FingerprintHmacRipemdChallenge.toObject(message.hmacRipemd, options);
		return object;
	};

	/**
	 * Converts this FingerprintChallengeUnion to JSON.
	 * @function toJSON
	 * @memberof FingerprintChallengeUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	FingerprintChallengeUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for FingerprintChallengeUnion
	 * @function getTypeUrl
	 * @memberof FingerprintChallengeUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	FingerprintChallengeUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/FingerprintChallengeUnion";
	};

	return FingerprintChallengeUnion;
})();

$root.FingerprintGrainChallenge = (function () {
	/**
	 * Properties of a FingerprintGrainChallenge.
	 * @exports IFingerprintGrainChallenge
	 * @interface IFingerprintGrainChallenge
	 * @property {Uint8Array} kek FingerprintGrainChallenge kek
	 */

	/**
	 * Constructs a new FingerprintGrainChallenge.
	 * @exports FingerprintGrainChallenge
	 * @classdesc Represents a FingerprintGrainChallenge.
	 * @implements IFingerprintGrainChallenge
	 * @constructor
	 * @param {IFingerprintGrainChallenge=} [properties] Properties to set
	 */
	function FingerprintGrainChallenge(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * FingerprintGrainChallenge kek.
	 * @member {Uint8Array} kek
	 * @memberof FingerprintGrainChallenge
	 * @instance
	 */
	FingerprintGrainChallenge.prototype.kek = $util.newBuffer([]);

	/**
	 * Creates a new FingerprintGrainChallenge instance using the specified properties.
	 * @function create
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {IFingerprintGrainChallenge=} [properties] Properties to set
	 * @returns {FingerprintGrainChallenge} FingerprintGrainChallenge instance
	 */
	FingerprintGrainChallenge.create = function create(properties) {
		return new FingerprintGrainChallenge(properties);
	};

	/**
	 * Encodes the specified FingerprintGrainChallenge message. Does not implicitly {@link FingerprintGrainChallenge.verify|verify} messages.
	 * @function encode
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {IFingerprintGrainChallenge} message FingerprintGrainChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintGrainChallenge.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.kek);
		return writer;
	};

	/**
	 * Encodes the specified FingerprintGrainChallenge message, length delimited. Does not implicitly {@link FingerprintGrainChallenge.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {IFingerprintGrainChallenge} message FingerprintGrainChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintGrainChallenge.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a FingerprintGrainChallenge message from the specified reader or buffer.
	 * @function decode
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {FingerprintGrainChallenge} FingerprintGrainChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintGrainChallenge.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.FingerprintGrainChallenge();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.kek = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("kek")) throw $util.ProtocolError("missing required 'kek'", { instance: message });
		return message;
	};

	/**
	 * Decodes a FingerprintGrainChallenge message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {FingerprintGrainChallenge} FingerprintGrainChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintGrainChallenge.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a FingerprintGrainChallenge message.
	 * @function verify
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	FingerprintGrainChallenge.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.kek && typeof message.kek.length === "number") || $util.isString(message.kek))) return "kek: buffer expected";
		return null;
	};

	/**
	 * Creates a FingerprintGrainChallenge message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {FingerprintGrainChallenge} FingerprintGrainChallenge
	 */
	FingerprintGrainChallenge.fromObject = function fromObject(object) {
		if (object instanceof $root.FingerprintGrainChallenge) return object;
		var message = new $root.FingerprintGrainChallenge();
		if (object.kek != null)
			if (typeof object.kek === "string")
				$util.base64.decode(object.kek, (message.kek = $util.newBuffer($util.base64.length(object.kek))), 0);
			else if (object.kek.length >= 0) message.kek = object.kek;
		return message;
	};

	/**
	 * Creates a plain object from a FingerprintGrainChallenge message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {FingerprintGrainChallenge} message FingerprintGrainChallenge
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	FingerprintGrainChallenge.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.kek = "";
			else {
				object.kek = [];
				if (options.bytes !== Array) object.kek = $util.newBuffer(object.kek);
			}
		if (message.kek != null && message.hasOwnProperty("kek"))
			object.kek =
				options.bytes === String
					? $util.base64.encode(message.kek, 0, message.kek.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.kek)
					: message.kek;
		return object;
	};

	/**
	 * Converts this FingerprintGrainChallenge to JSON.
	 * @function toJSON
	 * @memberof FingerprintGrainChallenge
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	FingerprintGrainChallenge.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for FingerprintGrainChallenge
	 * @function getTypeUrl
	 * @memberof FingerprintGrainChallenge
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	FingerprintGrainChallenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/FingerprintGrainChallenge";
	};

	return FingerprintGrainChallenge;
})();

$root.FingerprintHmacRipemdChallenge = (function () {
	/**
	 * Properties of a FingerprintHmacRipemdChallenge.
	 * @exports IFingerprintHmacRipemdChallenge
	 * @interface IFingerprintHmacRipemdChallenge
	 * @property {Uint8Array} challenge FingerprintHmacRipemdChallenge challenge
	 */

	/**
	 * Constructs a new FingerprintHmacRipemdChallenge.
	 * @exports FingerprintHmacRipemdChallenge
	 * @classdesc Represents a FingerprintHmacRipemdChallenge.
	 * @implements IFingerprintHmacRipemdChallenge
	 * @constructor
	 * @param {IFingerprintHmacRipemdChallenge=} [properties] Properties to set
	 */
	function FingerprintHmacRipemdChallenge(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * FingerprintHmacRipemdChallenge challenge.
	 * @member {Uint8Array} challenge
	 * @memberof FingerprintHmacRipemdChallenge
	 * @instance
	 */
	FingerprintHmacRipemdChallenge.prototype.challenge = $util.newBuffer([]);

	/**
	 * Creates a new FingerprintHmacRipemdChallenge instance using the specified properties.
	 * @function create
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {IFingerprintHmacRipemdChallenge=} [properties] Properties to set
	 * @returns {FingerprintHmacRipemdChallenge} FingerprintHmacRipemdChallenge instance
	 */
	FingerprintHmacRipemdChallenge.create = function create(properties) {
		return new FingerprintHmacRipemdChallenge(properties);
	};

	/**
	 * Encodes the specified FingerprintHmacRipemdChallenge message. Does not implicitly {@link FingerprintHmacRipemdChallenge.verify|verify} messages.
	 * @function encode
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {IFingerprintHmacRipemdChallenge} message FingerprintHmacRipemdChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintHmacRipemdChallenge.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.challenge);
		return writer;
	};

	/**
	 * Encodes the specified FingerprintHmacRipemdChallenge message, length delimited. Does not implicitly {@link FingerprintHmacRipemdChallenge.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {IFingerprintHmacRipemdChallenge} message FingerprintHmacRipemdChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	FingerprintHmacRipemdChallenge.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a FingerprintHmacRipemdChallenge message from the specified reader or buffer.
	 * @function decode
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {FingerprintHmacRipemdChallenge} FingerprintHmacRipemdChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintHmacRipemdChallenge.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.FingerprintHmacRipemdChallenge();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.challenge = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("challenge")) throw $util.ProtocolError("missing required 'challenge'", { instance: message });
		return message;
	};

	/**
	 * Decodes a FingerprintHmacRipemdChallenge message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {FingerprintHmacRipemdChallenge} FingerprintHmacRipemdChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	FingerprintHmacRipemdChallenge.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a FingerprintHmacRipemdChallenge message.
	 * @function verify
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	FingerprintHmacRipemdChallenge.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.challenge && typeof message.challenge.length === "number") || $util.isString(message.challenge)))
			return "challenge: buffer expected";
		return null;
	};

	/**
	 * Creates a FingerprintHmacRipemdChallenge message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {FingerprintHmacRipemdChallenge} FingerprintHmacRipemdChallenge
	 */
	FingerprintHmacRipemdChallenge.fromObject = function fromObject(object) {
		if (object instanceof $root.FingerprintHmacRipemdChallenge) return object;
		var message = new $root.FingerprintHmacRipemdChallenge();
		if (object.challenge != null)
			if (typeof object.challenge === "string")
				$util.base64.decode(object.challenge, (message.challenge = $util.newBuffer($util.base64.length(object.challenge))), 0);
			else if (object.challenge.length >= 0) message.challenge = object.challenge;
		return message;
	};

	/**
	 * Creates a plain object from a FingerprintHmacRipemdChallenge message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {FingerprintHmacRipemdChallenge} message FingerprintHmacRipemdChallenge
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	FingerprintHmacRipemdChallenge.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.challenge = "";
			else {
				object.challenge = [];
				if (options.bytes !== Array) object.challenge = $util.newBuffer(object.challenge);
			}
		if (message.challenge != null && message.hasOwnProperty("challenge"))
			object.challenge =
				options.bytes === String
					? $util.base64.encode(message.challenge, 0, message.challenge.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.challenge)
					: message.challenge;
		return object;
	};

	/**
	 * Converts this FingerprintHmacRipemdChallenge to JSON.
	 * @function toJSON
	 * @memberof FingerprintHmacRipemdChallenge
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	FingerprintHmacRipemdChallenge.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for FingerprintHmacRipemdChallenge
	 * @function getTypeUrl
	 * @memberof FingerprintHmacRipemdChallenge
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	FingerprintHmacRipemdChallenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/FingerprintHmacRipemdChallenge";
	};

	return FingerprintHmacRipemdChallenge;
})();

$root.PoWChallengeUnion = (function () {
	/**
	 * Properties of a PoWChallengeUnion.
	 * @exports IPoWChallengeUnion
	 * @interface IPoWChallengeUnion
	 * @property {IPoWHashCashChallenge|null} [hashCash] PoWChallengeUnion hashCash
	 */

	/**
	 * Constructs a new PoWChallengeUnion.
	 * @exports PoWChallengeUnion
	 * @classdesc Represents a PoWChallengeUnion.
	 * @implements IPoWChallengeUnion
	 * @constructor
	 * @param {IPoWChallengeUnion=} [properties] Properties to set
	 */
	function PoWChallengeUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * PoWChallengeUnion hashCash.
	 * @member {IPoWHashCashChallenge|null|undefined} hashCash
	 * @memberof PoWChallengeUnion
	 * @instance
	 */
	PoWChallengeUnion.prototype.hashCash = null;

	/**
	 * Creates a new PoWChallengeUnion instance using the specified properties.
	 * @function create
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {IPoWChallengeUnion=} [properties] Properties to set
	 * @returns {PoWChallengeUnion} PoWChallengeUnion instance
	 */
	PoWChallengeUnion.create = function create(properties) {
		return new PoWChallengeUnion(properties);
	};

	/**
	 * Encodes the specified PoWChallengeUnion message. Does not implicitly {@link PoWChallengeUnion.verify|verify} messages.
	 * @function encode
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {IPoWChallengeUnion} message PoWChallengeUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PoWChallengeUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.hashCash != null && Object.hasOwnProperty.call(message, "hashCash"))
			$root.PoWHashCashChallenge.encode(message.hashCash, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified PoWChallengeUnion message, length delimited. Does not implicitly {@link PoWChallengeUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {IPoWChallengeUnion} message PoWChallengeUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PoWChallengeUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a PoWChallengeUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {PoWChallengeUnion} PoWChallengeUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PoWChallengeUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.PoWChallengeUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.hashCash = $root.PoWHashCashChallenge.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a PoWChallengeUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {PoWChallengeUnion} PoWChallengeUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PoWChallengeUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a PoWChallengeUnion message.
	 * @function verify
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	PoWChallengeUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.hashCash != null && message.hasOwnProperty("hashCash")) {
			var error = $root.PoWHashCashChallenge.verify(message.hashCash);
			if (error) return "hashCash." + error;
		}
		return null;
	};

	/**
	 * Creates a PoWChallengeUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {PoWChallengeUnion} PoWChallengeUnion
	 */
	PoWChallengeUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.PoWChallengeUnion) return object;
		var message = new $root.PoWChallengeUnion();
		if (object.hashCash != null) {
			if (typeof object.hashCash !== "object") throw TypeError(".PoWChallengeUnion.hashCash: object expected");
			message.hashCash = $root.PoWHashCashChallenge.fromObject(object.hashCash);
		}
		return message;
	};

	/**
	 * Creates a plain object from a PoWChallengeUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {PoWChallengeUnion} message PoWChallengeUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	PoWChallengeUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.hashCash = null;
		if (message.hashCash != null && message.hasOwnProperty("hashCash"))
			object.hashCash = $root.PoWHashCashChallenge.toObject(message.hashCash, options);
		return object;
	};

	/**
	 * Converts this PoWChallengeUnion to JSON.
	 * @function toJSON
	 * @memberof PoWChallengeUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	PoWChallengeUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for PoWChallengeUnion
	 * @function getTypeUrl
	 * @memberof PoWChallengeUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	PoWChallengeUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/PoWChallengeUnion";
	};

	return PoWChallengeUnion;
})();

$root.PoWHashCashChallenge = (function () {
	/**
	 * Properties of a PoWHashCashChallenge.
	 * @exports IPoWHashCashChallenge
	 * @interface IPoWHashCashChallenge
	 * @property {Uint8Array|null} [prefix] PoWHashCashChallenge prefix
	 * @property {number|null} [length] PoWHashCashChallenge length
	 * @property {number|null} [target] PoWHashCashChallenge target
	 */

	/**
	 * Constructs a new PoWHashCashChallenge.
	 * @exports PoWHashCashChallenge
	 * @classdesc Represents a PoWHashCashChallenge.
	 * @implements IPoWHashCashChallenge
	 * @constructor
	 * @param {IPoWHashCashChallenge=} [properties] Properties to set
	 */
	function PoWHashCashChallenge(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * PoWHashCashChallenge prefix.
	 * @member {Uint8Array} prefix
	 * @memberof PoWHashCashChallenge
	 * @instance
	 */
	PoWHashCashChallenge.prototype.prefix = $util.newBuffer([]);

	/**
	 * PoWHashCashChallenge length.
	 * @member {number} length
	 * @memberof PoWHashCashChallenge
	 * @instance
	 */
	PoWHashCashChallenge.prototype.length = 0;

	/**
	 * PoWHashCashChallenge target.
	 * @member {number} target
	 * @memberof PoWHashCashChallenge
	 * @instance
	 */
	PoWHashCashChallenge.prototype.target = 0;

	/**
	 * Creates a new PoWHashCashChallenge instance using the specified properties.
	 * @function create
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {IPoWHashCashChallenge=} [properties] Properties to set
	 * @returns {PoWHashCashChallenge} PoWHashCashChallenge instance
	 */
	PoWHashCashChallenge.create = function create(properties) {
		return new PoWHashCashChallenge(properties);
	};

	/**
	 * Encodes the specified PoWHashCashChallenge message. Does not implicitly {@link PoWHashCashChallenge.verify|verify} messages.
	 * @function encode
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {IPoWHashCashChallenge} message PoWHashCashChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PoWHashCashChallenge.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
			writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.prefix);
		if (message.length != null && Object.hasOwnProperty.call(message, "length"))
			writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.length);
		if (message.target != null && Object.hasOwnProperty.call(message, "target"))
			writer.uint32(/* id 30, wireType 0 =*/ 240).int32(message.target);
		return writer;
	};

	/**
	 * Encodes the specified PoWHashCashChallenge message, length delimited. Does not implicitly {@link PoWHashCashChallenge.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {IPoWHashCashChallenge} message PoWHashCashChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PoWHashCashChallenge.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a PoWHashCashChallenge message from the specified reader or buffer.
	 * @function decode
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {PoWHashCashChallenge} PoWHashCashChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PoWHashCashChallenge.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.PoWHashCashChallenge();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.prefix = reader.bytes();
					break;
				}
				case 20: {
					message.length = reader.int32();
					break;
				}
				case 30: {
					message.target = reader.int32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a PoWHashCashChallenge message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {PoWHashCashChallenge} PoWHashCashChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PoWHashCashChallenge.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a PoWHashCashChallenge message.
	 * @function verify
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	PoWHashCashChallenge.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.prefix != null && message.hasOwnProperty("prefix"))
			if (!((message.prefix && typeof message.prefix.length === "number") || $util.isString(message.prefix)))
				return "prefix: buffer expected";
		if (message.length != null && message.hasOwnProperty("length"))
			if (!$util.isInteger(message.length)) return "length: integer expected";
		if (message.target != null && message.hasOwnProperty("target"))
			if (!$util.isInteger(message.target)) return "target: integer expected";
		return null;
	};

	/**
	 * Creates a PoWHashCashChallenge message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {PoWHashCashChallenge} PoWHashCashChallenge
	 */
	PoWHashCashChallenge.fromObject = function fromObject(object) {
		if (object instanceof $root.PoWHashCashChallenge) return object;
		var message = new $root.PoWHashCashChallenge();
		if (object.prefix != null)
			if (typeof object.prefix === "string")
				$util.base64.decode(object.prefix, (message.prefix = $util.newBuffer($util.base64.length(object.prefix))), 0);
			else if (object.prefix.length >= 0) message.prefix = object.prefix;
		if (object.length != null) message.length = object.length | 0;
		if (object.target != null) message.target = object.target | 0;
		return message;
	};

	/**
	 * Creates a plain object from a PoWHashCashChallenge message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {PoWHashCashChallenge} message PoWHashCashChallenge
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	PoWHashCashChallenge.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			if (options.bytes === String) object.prefix = "";
			else {
				object.prefix = [];
				if (options.bytes !== Array) object.prefix = $util.newBuffer(object.prefix);
			}
			object.length = 0;
			object.target = 0;
		}
		if (message.prefix != null && message.hasOwnProperty("prefix"))
			object.prefix =
				options.bytes === String
					? $util.base64.encode(message.prefix, 0, message.prefix.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.prefix)
					: message.prefix;
		if (message.length != null && message.hasOwnProperty("length")) object.length = message.length;
		if (message.target != null && message.hasOwnProperty("target")) object.target = message.target;
		return object;
	};

	/**
	 * Converts this PoWHashCashChallenge to JSON.
	 * @function toJSON
	 * @memberof PoWHashCashChallenge
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	PoWHashCashChallenge.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for PoWHashCashChallenge
	 * @function getTypeUrl
	 * @memberof PoWHashCashChallenge
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	PoWHashCashChallenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/PoWHashCashChallenge";
	};

	return PoWHashCashChallenge;
})();

$root.CryptoChallengeUnion = (function () {
	/**
	 * Properties of a CryptoChallengeUnion.
	 * @exports ICryptoChallengeUnion
	 * @interface ICryptoChallengeUnion
	 * @property {ICryptoShannonChallenge|null} [shannon] CryptoChallengeUnion shannon
	 * @property {ICryptoRc4Sha1HmacChallenge|null} [rc4Sha1Hmac] CryptoChallengeUnion rc4Sha1Hmac
	 */

	/**
	 * Constructs a new CryptoChallengeUnion.
	 * @exports CryptoChallengeUnion
	 * @classdesc Represents a CryptoChallengeUnion.
	 * @implements ICryptoChallengeUnion
	 * @constructor
	 * @param {ICryptoChallengeUnion=} [properties] Properties to set
	 */
	function CryptoChallengeUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * CryptoChallengeUnion shannon.
	 * @member {ICryptoShannonChallenge|null|undefined} shannon
	 * @memberof CryptoChallengeUnion
	 * @instance
	 */
	CryptoChallengeUnion.prototype.shannon = null;

	/**
	 * CryptoChallengeUnion rc4Sha1Hmac.
	 * @member {ICryptoRc4Sha1HmacChallenge|null|undefined} rc4Sha1Hmac
	 * @memberof CryptoChallengeUnion
	 * @instance
	 */
	CryptoChallengeUnion.prototype.rc4Sha1Hmac = null;

	/**
	 * Creates a new CryptoChallengeUnion instance using the specified properties.
	 * @function create
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {ICryptoChallengeUnion=} [properties] Properties to set
	 * @returns {CryptoChallengeUnion} CryptoChallengeUnion instance
	 */
	CryptoChallengeUnion.create = function create(properties) {
		return new CryptoChallengeUnion(properties);
	};

	/**
	 * Encodes the specified CryptoChallengeUnion message. Does not implicitly {@link CryptoChallengeUnion.verify|verify} messages.
	 * @function encode
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {ICryptoChallengeUnion} message CryptoChallengeUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoChallengeUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.shannon != null && Object.hasOwnProperty.call(message, "shannon"))
			$root.CryptoShannonChallenge.encode(message.shannon, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.rc4Sha1Hmac != null && Object.hasOwnProperty.call(message, "rc4Sha1Hmac"))
			$root.CryptoRc4Sha1HmacChallenge.encode(message.rc4Sha1Hmac, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified CryptoChallengeUnion message, length delimited. Does not implicitly {@link CryptoChallengeUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {ICryptoChallengeUnion} message CryptoChallengeUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoChallengeUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a CryptoChallengeUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {CryptoChallengeUnion} CryptoChallengeUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoChallengeUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.CryptoChallengeUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.shannon = $root.CryptoShannonChallenge.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.rc4Sha1Hmac = $root.CryptoRc4Sha1HmacChallenge.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a CryptoChallengeUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {CryptoChallengeUnion} CryptoChallengeUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoChallengeUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a CryptoChallengeUnion message.
	 * @function verify
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	CryptoChallengeUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.shannon != null && message.hasOwnProperty("shannon")) {
			var error = $root.CryptoShannonChallenge.verify(message.shannon);
			if (error) return "shannon." + error;
		}
		if (message.rc4Sha1Hmac != null && message.hasOwnProperty("rc4Sha1Hmac")) {
			var error = $root.CryptoRc4Sha1HmacChallenge.verify(message.rc4Sha1Hmac);
			if (error) return "rc4Sha1Hmac." + error;
		}
		return null;
	};

	/**
	 * Creates a CryptoChallengeUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {CryptoChallengeUnion} CryptoChallengeUnion
	 */
	CryptoChallengeUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.CryptoChallengeUnion) return object;
		var message = new $root.CryptoChallengeUnion();
		if (object.shannon != null) {
			if (typeof object.shannon !== "object") throw TypeError(".CryptoChallengeUnion.shannon: object expected");
			message.shannon = $root.CryptoShannonChallenge.fromObject(object.shannon);
		}
		if (object.rc4Sha1Hmac != null) {
			if (typeof object.rc4Sha1Hmac !== "object") throw TypeError(".CryptoChallengeUnion.rc4Sha1Hmac: object expected");
			message.rc4Sha1Hmac = $root.CryptoRc4Sha1HmacChallenge.fromObject(object.rc4Sha1Hmac);
		}
		return message;
	};

	/**
	 * Creates a plain object from a CryptoChallengeUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {CryptoChallengeUnion} message CryptoChallengeUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	CryptoChallengeUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.shannon = null;
			object.rc4Sha1Hmac = null;
		}
		if (message.shannon != null && message.hasOwnProperty("shannon"))
			object.shannon = $root.CryptoShannonChallenge.toObject(message.shannon, options);
		if (message.rc4Sha1Hmac != null && message.hasOwnProperty("rc4Sha1Hmac"))
			object.rc4Sha1Hmac = $root.CryptoRc4Sha1HmacChallenge.toObject(message.rc4Sha1Hmac, options);
		return object;
	};

	/**
	 * Converts this CryptoChallengeUnion to JSON.
	 * @function toJSON
	 * @memberof CryptoChallengeUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	CryptoChallengeUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for CryptoChallengeUnion
	 * @function getTypeUrl
	 * @memberof CryptoChallengeUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	CryptoChallengeUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/CryptoChallengeUnion";
	};

	return CryptoChallengeUnion;
})();

$root.CryptoShannonChallenge = (function () {
	/**
	 * Properties of a CryptoShannonChallenge.
	 * @exports ICryptoShannonChallenge
	 * @interface ICryptoShannonChallenge
	 */

	/**
	 * Constructs a new CryptoShannonChallenge.
	 * @exports CryptoShannonChallenge
	 * @classdesc Represents a CryptoShannonChallenge.
	 * @implements ICryptoShannonChallenge
	 * @constructor
	 * @param {ICryptoShannonChallenge=} [properties] Properties to set
	 */
	function CryptoShannonChallenge(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Creates a new CryptoShannonChallenge instance using the specified properties.
	 * @function create
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {ICryptoShannonChallenge=} [properties] Properties to set
	 * @returns {CryptoShannonChallenge} CryptoShannonChallenge instance
	 */
	CryptoShannonChallenge.create = function create(properties) {
		return new CryptoShannonChallenge(properties);
	};

	/**
	 * Encodes the specified CryptoShannonChallenge message. Does not implicitly {@link CryptoShannonChallenge.verify|verify} messages.
	 * @function encode
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {ICryptoShannonChallenge} message CryptoShannonChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoShannonChallenge.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		return writer;
	};

	/**
	 * Encodes the specified CryptoShannonChallenge message, length delimited. Does not implicitly {@link CryptoShannonChallenge.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {ICryptoShannonChallenge} message CryptoShannonChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoShannonChallenge.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a CryptoShannonChallenge message from the specified reader or buffer.
	 * @function decode
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {CryptoShannonChallenge} CryptoShannonChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoShannonChallenge.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.CryptoShannonChallenge();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a CryptoShannonChallenge message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {CryptoShannonChallenge} CryptoShannonChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoShannonChallenge.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a CryptoShannonChallenge message.
	 * @function verify
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	CryptoShannonChallenge.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		return null;
	};

	/**
	 * Creates a CryptoShannonChallenge message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {CryptoShannonChallenge} CryptoShannonChallenge
	 */
	CryptoShannonChallenge.fromObject = function fromObject(object) {
		if (object instanceof $root.CryptoShannonChallenge) return object;
		return new $root.CryptoShannonChallenge();
	};

	/**
	 * Creates a plain object from a CryptoShannonChallenge message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {CryptoShannonChallenge} message CryptoShannonChallenge
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	CryptoShannonChallenge.toObject = function toObject() {
		return {};
	};

	/**
	 * Converts this CryptoShannonChallenge to JSON.
	 * @function toJSON
	 * @memberof CryptoShannonChallenge
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	CryptoShannonChallenge.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for CryptoShannonChallenge
	 * @function getTypeUrl
	 * @memberof CryptoShannonChallenge
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	CryptoShannonChallenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/CryptoShannonChallenge";
	};

	return CryptoShannonChallenge;
})();

$root.CryptoRc4Sha1HmacChallenge = (function () {
	/**
	 * Properties of a CryptoRc4Sha1HmacChallenge.
	 * @exports ICryptoRc4Sha1HmacChallenge
	 * @interface ICryptoRc4Sha1HmacChallenge
	 */

	/**
	 * Constructs a new CryptoRc4Sha1HmacChallenge.
	 * @exports CryptoRc4Sha1HmacChallenge
	 * @classdesc Represents a CryptoRc4Sha1HmacChallenge.
	 * @implements ICryptoRc4Sha1HmacChallenge
	 * @constructor
	 * @param {ICryptoRc4Sha1HmacChallenge=} [properties] Properties to set
	 */
	function CryptoRc4Sha1HmacChallenge(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Creates a new CryptoRc4Sha1HmacChallenge instance using the specified properties.
	 * @function create
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {ICryptoRc4Sha1HmacChallenge=} [properties] Properties to set
	 * @returns {CryptoRc4Sha1HmacChallenge} CryptoRc4Sha1HmacChallenge instance
	 */
	CryptoRc4Sha1HmacChallenge.create = function create(properties) {
		return new CryptoRc4Sha1HmacChallenge(properties);
	};

	/**
	 * Encodes the specified CryptoRc4Sha1HmacChallenge message. Does not implicitly {@link CryptoRc4Sha1HmacChallenge.verify|verify} messages.
	 * @function encode
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {ICryptoRc4Sha1HmacChallenge} message CryptoRc4Sha1HmacChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoRc4Sha1HmacChallenge.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		return writer;
	};

	/**
	 * Encodes the specified CryptoRc4Sha1HmacChallenge message, length delimited. Does not implicitly {@link CryptoRc4Sha1HmacChallenge.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {ICryptoRc4Sha1HmacChallenge} message CryptoRc4Sha1HmacChallenge message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoRc4Sha1HmacChallenge.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a CryptoRc4Sha1HmacChallenge message from the specified reader or buffer.
	 * @function decode
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {CryptoRc4Sha1HmacChallenge} CryptoRc4Sha1HmacChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoRc4Sha1HmacChallenge.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.CryptoRc4Sha1HmacChallenge();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a CryptoRc4Sha1HmacChallenge message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {CryptoRc4Sha1HmacChallenge} CryptoRc4Sha1HmacChallenge
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoRc4Sha1HmacChallenge.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a CryptoRc4Sha1HmacChallenge message.
	 * @function verify
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	CryptoRc4Sha1HmacChallenge.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		return null;
	};

	/**
	 * Creates a CryptoRc4Sha1HmacChallenge message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {CryptoRc4Sha1HmacChallenge} CryptoRc4Sha1HmacChallenge
	 */
	CryptoRc4Sha1HmacChallenge.fromObject = function fromObject(object) {
		if (object instanceof $root.CryptoRc4Sha1HmacChallenge) return object;
		return new $root.CryptoRc4Sha1HmacChallenge();
	};

	/**
	 * Creates a plain object from a CryptoRc4Sha1HmacChallenge message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {CryptoRc4Sha1HmacChallenge} message CryptoRc4Sha1HmacChallenge
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	CryptoRc4Sha1HmacChallenge.toObject = function toObject() {
		return {};
	};

	/**
	 * Converts this CryptoRc4Sha1HmacChallenge to JSON.
	 * @function toJSON
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	CryptoRc4Sha1HmacChallenge.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for CryptoRc4Sha1HmacChallenge
	 * @function getTypeUrl
	 * @memberof CryptoRc4Sha1HmacChallenge
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	CryptoRc4Sha1HmacChallenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/CryptoRc4Sha1HmacChallenge";
	};

	return CryptoRc4Sha1HmacChallenge;
})();

$root.UpgradeRequiredMessage = (function () {
	/**
	 * Properties of an UpgradeRequiredMessage.
	 * @exports IUpgradeRequiredMessage
	 * @interface IUpgradeRequiredMessage
	 * @property {Uint8Array} upgradeSignedPart UpgradeRequiredMessage upgradeSignedPart
	 * @property {Uint8Array} signature UpgradeRequiredMessage signature
	 * @property {string|null} [httpSuffix] UpgradeRequiredMessage httpSuffix
	 */

	/**
	 * Constructs a new UpgradeRequiredMessage.
	 * @exports UpgradeRequiredMessage
	 * @classdesc Represents an UpgradeRequiredMessage.
	 * @implements IUpgradeRequiredMessage
	 * @constructor
	 * @param {IUpgradeRequiredMessage=} [properties] Properties to set
	 */
	function UpgradeRequiredMessage(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * UpgradeRequiredMessage upgradeSignedPart.
	 * @member {Uint8Array} upgradeSignedPart
	 * @memberof UpgradeRequiredMessage
	 * @instance
	 */
	UpgradeRequiredMessage.prototype.upgradeSignedPart = $util.newBuffer([]);

	/**
	 * UpgradeRequiredMessage signature.
	 * @member {Uint8Array} signature
	 * @memberof UpgradeRequiredMessage
	 * @instance
	 */
	UpgradeRequiredMessage.prototype.signature = $util.newBuffer([]);

	/**
	 * UpgradeRequiredMessage httpSuffix.
	 * @member {string} httpSuffix
	 * @memberof UpgradeRequiredMessage
	 * @instance
	 */
	UpgradeRequiredMessage.prototype.httpSuffix = "";

	/**
	 * Creates a new UpgradeRequiredMessage instance using the specified properties.
	 * @function create
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {IUpgradeRequiredMessage=} [properties] Properties to set
	 * @returns {UpgradeRequiredMessage} UpgradeRequiredMessage instance
	 */
	UpgradeRequiredMessage.create = function create(properties) {
		return new UpgradeRequiredMessage(properties);
	};

	/**
	 * Encodes the specified UpgradeRequiredMessage message. Does not implicitly {@link UpgradeRequiredMessage.verify|verify} messages.
	 * @function encode
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {IUpgradeRequiredMessage} message UpgradeRequiredMessage message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	UpgradeRequiredMessage.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.upgradeSignedPart);
		writer.uint32(/* id 20, wireType 2 =*/ 162).bytes(message.signature);
		if (message.httpSuffix != null && Object.hasOwnProperty.call(message, "httpSuffix"))
			writer.uint32(/* id 30, wireType 2 =*/ 242).string(message.httpSuffix);
		return writer;
	};

	/**
	 * Encodes the specified UpgradeRequiredMessage message, length delimited. Does not implicitly {@link UpgradeRequiredMessage.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {IUpgradeRequiredMessage} message UpgradeRequiredMessage message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	UpgradeRequiredMessage.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an UpgradeRequiredMessage message from the specified reader or buffer.
	 * @function decode
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {UpgradeRequiredMessage} UpgradeRequiredMessage
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	UpgradeRequiredMessage.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.UpgradeRequiredMessage();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.upgradeSignedPart = reader.bytes();
					break;
				}
				case 20: {
					message.signature = reader.bytes();
					break;
				}
				case 30: {
					message.httpSuffix = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("upgradeSignedPart"))
			throw $util.ProtocolError("missing required 'upgradeSignedPart'", { instance: message });
		if (!message.hasOwnProperty("signature")) throw $util.ProtocolError("missing required 'signature'", { instance: message });
		return message;
	};

	/**
	 * Decodes an UpgradeRequiredMessage message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {UpgradeRequiredMessage} UpgradeRequiredMessage
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	UpgradeRequiredMessage.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an UpgradeRequiredMessage message.
	 * @function verify
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	UpgradeRequiredMessage.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (
			!(
				(message.upgradeSignedPart && typeof message.upgradeSignedPart.length === "number") ||
				$util.isString(message.upgradeSignedPart)
			)
		)
			return "upgradeSignedPart: buffer expected";
		if (!((message.signature && typeof message.signature.length === "number") || $util.isString(message.signature)))
			return "signature: buffer expected";
		if (message.httpSuffix != null && message.hasOwnProperty("httpSuffix"))
			if (!$util.isString(message.httpSuffix)) return "httpSuffix: string expected";
		return null;
	};

	/**
	 * Creates an UpgradeRequiredMessage message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {UpgradeRequiredMessage} UpgradeRequiredMessage
	 */
	UpgradeRequiredMessage.fromObject = function fromObject(object) {
		if (object instanceof $root.UpgradeRequiredMessage) return object;
		var message = new $root.UpgradeRequiredMessage();
		if (object.upgradeSignedPart != null)
			if (typeof object.upgradeSignedPart === "string")
				$util.base64.decode(
					object.upgradeSignedPart,
					(message.upgradeSignedPart = $util.newBuffer($util.base64.length(object.upgradeSignedPart))),
					0,
				);
			else if (object.upgradeSignedPart.length >= 0) message.upgradeSignedPart = object.upgradeSignedPart;
		if (object.signature != null)
			if (typeof object.signature === "string")
				$util.base64.decode(object.signature, (message.signature = $util.newBuffer($util.base64.length(object.signature))), 0);
			else if (object.signature.length >= 0) message.signature = object.signature;
		if (object.httpSuffix != null) message.httpSuffix = String(object.httpSuffix);
		return message;
	};

	/**
	 * Creates a plain object from an UpgradeRequiredMessage message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {UpgradeRequiredMessage} message UpgradeRequiredMessage
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	UpgradeRequiredMessage.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			if (options.bytes === String) object.upgradeSignedPart = "";
			else {
				object.upgradeSignedPart = [];
				if (options.bytes !== Array) object.upgradeSignedPart = $util.newBuffer(object.upgradeSignedPart);
			}
			if (options.bytes === String) object.signature = "";
			else {
				object.signature = [];
				if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);
			}
			object.httpSuffix = "";
		}
		if (message.upgradeSignedPart != null && message.hasOwnProperty("upgradeSignedPart"))
			object.upgradeSignedPart =
				options.bytes === String
					? $util.base64.encode(message.upgradeSignedPart, 0, message.upgradeSignedPart.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.upgradeSignedPart)
					: message.upgradeSignedPart;
		if (message.signature != null && message.hasOwnProperty("signature"))
			object.signature =
				options.bytes === String
					? $util.base64.encode(message.signature, 0, message.signature.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.signature)
					: message.signature;
		if (message.httpSuffix != null && message.hasOwnProperty("httpSuffix")) object.httpSuffix = message.httpSuffix;
		return object;
	};

	/**
	 * Converts this UpgradeRequiredMessage to JSON.
	 * @function toJSON
	 * @memberof UpgradeRequiredMessage
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	UpgradeRequiredMessage.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for UpgradeRequiredMessage
	 * @function getTypeUrl
	 * @memberof UpgradeRequiredMessage
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	UpgradeRequiredMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/UpgradeRequiredMessage";
	};

	return UpgradeRequiredMessage;
})();

$root.APLoginFailed = (function () {
	/**
	 * Properties of a APLoginFailed.
	 * @exports IAPLoginFailed
	 * @interface IAPLoginFailed
	 * @property {ErrorCode} errorCode APLoginFailed errorCode
	 * @property {number|null} [retryDelay] APLoginFailed retryDelay
	 * @property {number|null} [expiry] APLoginFailed expiry
	 * @property {string|null} [errorDescription] APLoginFailed errorDescription
	 */

	/**
	 * Constructs a new APLoginFailed.
	 * @exports APLoginFailed
	 * @classdesc Represents a APLoginFailed.
	 * @implements IAPLoginFailed
	 * @constructor
	 * @param {IAPLoginFailed=} [properties] Properties to set
	 */
	function APLoginFailed(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * APLoginFailed errorCode.
	 * @member {ErrorCode} errorCode
	 * @memberof APLoginFailed
	 * @instance
	 */
	APLoginFailed.prototype.errorCode = 0;

	/**
	 * APLoginFailed retryDelay.
	 * @member {number} retryDelay
	 * @memberof APLoginFailed
	 * @instance
	 */
	APLoginFailed.prototype.retryDelay = 0;

	/**
	 * APLoginFailed expiry.
	 * @member {number} expiry
	 * @memberof APLoginFailed
	 * @instance
	 */
	APLoginFailed.prototype.expiry = 0;

	/**
	 * APLoginFailed errorDescription.
	 * @member {string} errorDescription
	 * @memberof APLoginFailed
	 * @instance
	 */
	APLoginFailed.prototype.errorDescription = "";

	/**
	 * Creates a new APLoginFailed instance using the specified properties.
	 * @function create
	 * @memberof APLoginFailed
	 * @static
	 * @param {IAPLoginFailed=} [properties] Properties to set
	 * @returns {APLoginFailed} APLoginFailed instance
	 */
	APLoginFailed.create = function create(properties) {
		return new APLoginFailed(properties);
	};

	/**
	 * Encodes the specified APLoginFailed message. Does not implicitly {@link APLoginFailed.verify|verify} messages.
	 * @function encode
	 * @memberof APLoginFailed
	 * @static
	 * @param {IAPLoginFailed} message APLoginFailed message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	APLoginFailed.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.errorCode);
		if (message.retryDelay != null && Object.hasOwnProperty.call(message, "retryDelay"))
			writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.retryDelay);
		if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
			writer.uint32(/* id 30, wireType 0 =*/ 240).int32(message.expiry);
		if (message.errorDescription != null && Object.hasOwnProperty.call(message, "errorDescription"))
			writer.uint32(/* id 40, wireType 2 =*/ 322).string(message.errorDescription);
		return writer;
	};

	/**
	 * Encodes the specified APLoginFailed message, length delimited. Does not implicitly {@link APLoginFailed.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof APLoginFailed
	 * @static
	 * @param {IAPLoginFailed} message APLoginFailed message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	APLoginFailed.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a APLoginFailed message from the specified reader or buffer.
	 * @function decode
	 * @memberof APLoginFailed
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {APLoginFailed} APLoginFailed
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	APLoginFailed.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.APLoginFailed();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.errorCode = reader.int32();
					break;
				}
				case 20: {
					message.retryDelay = reader.int32();
					break;
				}
				case 30: {
					message.expiry = reader.int32();
					break;
				}
				case 40: {
					message.errorDescription = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("errorCode")) throw $util.ProtocolError("missing required 'errorCode'", { instance: message });
		return message;
	};

	/**
	 * Decodes a APLoginFailed message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof APLoginFailed
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {APLoginFailed} APLoginFailed
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	APLoginFailed.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a APLoginFailed message.
	 * @function verify
	 * @memberof APLoginFailed
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	APLoginFailed.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		switch (message.errorCode) {
			default:
				return "errorCode: enum value expected";
			case 0:
			case 2:
			case 5:
			case 9:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
			case 16:
			case 17:
				break;
		}
		if (message.retryDelay != null && message.hasOwnProperty("retryDelay"))
			if (!$util.isInteger(message.retryDelay)) return "retryDelay: integer expected";
		if (message.expiry != null && message.hasOwnProperty("expiry"))
			if (!$util.isInteger(message.expiry)) return "expiry: integer expected";
		if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
			if (!$util.isString(message.errorDescription)) return "errorDescription: string expected";
		return null;
	};

	/**
	 * Creates a APLoginFailed message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof APLoginFailed
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {APLoginFailed} APLoginFailed
	 */
	APLoginFailed.fromObject = function fromObject(object) {
		if (object instanceof $root.APLoginFailed) return object;
		var message = new $root.APLoginFailed();
		switch (object.errorCode) {
			default:
				if (typeof object.errorCode === "number") {
					message.errorCode = object.errorCode;
					break;
				}
				break;
			case "ProtocolError":
			case 0:
				message.errorCode = 0;
				break;
			case "TryAnotherAP":
			case 2:
				message.errorCode = 2;
				break;
			case "BadConnectionId":
			case 5:
				message.errorCode = 5;
				break;
			case "TravelRestriction":
			case 9:
				message.errorCode = 9;
				break;
			case "PremiumAccountRequired":
			case 11:
				message.errorCode = 11;
				break;
			case "BadCredentials":
			case 12:
				message.errorCode = 12;
				break;
			case "CouldNotValidateCredentials":
			case 13:
				message.errorCode = 13;
				break;
			case "AccountExists":
			case 14:
				message.errorCode = 14;
				break;
			case "ExtraVerificationRequired":
			case 15:
				message.errorCode = 15;
				break;
			case "InvalidAppKey":
			case 16:
				message.errorCode = 16;
				break;
			case "ApplicationBanned":
			case 17:
				message.errorCode = 17;
				break;
		}
		if (object.retryDelay != null) message.retryDelay = object.retryDelay | 0;
		if (object.expiry != null) message.expiry = object.expiry | 0;
		if (object.errorDescription != null) message.errorDescription = String(object.errorDescription);
		return message;
	};

	/**
	 * Creates a plain object from a APLoginFailed message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof APLoginFailed
	 * @static
	 * @param {APLoginFailed} message APLoginFailed
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	APLoginFailed.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.errorCode = options.enums === String ? "ProtocolError" : 0;
			object.retryDelay = 0;
			object.expiry = 0;
			object.errorDescription = "";
		}
		if (message.errorCode != null && message.hasOwnProperty("errorCode"))
			object.errorCode =
				options.enums === String
					? $root.ErrorCode[message.errorCode] === undefined
						? message.errorCode
						: $root.ErrorCode[message.errorCode]
					: message.errorCode;
		if (message.retryDelay != null && message.hasOwnProperty("retryDelay")) object.retryDelay = message.retryDelay;
		if (message.expiry != null && message.hasOwnProperty("expiry")) object.expiry = message.expiry;
		if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
			object.errorDescription = message.errorDescription;
		return object;
	};

	/**
	 * Converts this APLoginFailed to JSON.
	 * @function toJSON
	 * @memberof APLoginFailed
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	APLoginFailed.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for APLoginFailed
	 * @function getTypeUrl
	 * @memberof APLoginFailed
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	APLoginFailed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/APLoginFailed";
	};

	return APLoginFailed;
})();

/**
 * ErrorCode enum.
 * @exports ErrorCode
 * @enum {number}
 * @property {number} ProtocolError=0 ProtocolError value
 * @property {number} TryAnotherAP=2 TryAnotherAP value
 * @property {number} BadConnectionId=5 BadConnectionId value
 * @property {number} TravelRestriction=9 TravelRestriction value
 * @property {number} PremiumAccountRequired=11 PremiumAccountRequired value
 * @property {number} BadCredentials=12 BadCredentials value
 * @property {number} CouldNotValidateCredentials=13 CouldNotValidateCredentials value
 * @property {number} AccountExists=14 AccountExists value
 * @property {number} ExtraVerificationRequired=15 ExtraVerificationRequired value
 * @property {number} InvalidAppKey=16 InvalidAppKey value
 * @property {number} ApplicationBanned=17 ApplicationBanned value
 */
$root.ErrorCode = (function () {
	var valuesById = {},
		values = Object.create(valuesById);
	values[(valuesById[0] = "ProtocolError")] = 0;
	values[(valuesById[2] = "TryAnotherAP")] = 2;
	values[(valuesById[5] = "BadConnectionId")] = 5;
	values[(valuesById[9] = "TravelRestriction")] = 9;
	values[(valuesById[11] = "PremiumAccountRequired")] = 11;
	values[(valuesById[12] = "BadCredentials")] = 12;
	values[(valuesById[13] = "CouldNotValidateCredentials")] = 13;
	values[(valuesById[14] = "AccountExists")] = 14;
	values[(valuesById[15] = "ExtraVerificationRequired")] = 15;
	values[(valuesById[16] = "InvalidAppKey")] = 16;
	values[(valuesById[17] = "ApplicationBanned")] = 17;
	return values;
})();

$root.ClientResponsePlaintext = (function () {
	/**
	 * Properties of a ClientResponsePlaintext.
	 * @exports IClientResponsePlaintext
	 * @interface IClientResponsePlaintext
	 * @property {ILoginCryptoResponseUnion} loginCryptoResponse ClientResponsePlaintext loginCryptoResponse
	 * @property {IPoWResponseUnion} powResponse ClientResponsePlaintext powResponse
	 * @property {ICryptoResponseUnion} cryptoResponse ClientResponsePlaintext cryptoResponse
	 */

	/**
	 * Constructs a new ClientResponsePlaintext.
	 * @exports ClientResponsePlaintext
	 * @classdesc Represents a ClientResponsePlaintext.
	 * @implements IClientResponsePlaintext
	 * @constructor
	 * @param {IClientResponsePlaintext=} [properties] Properties to set
	 */
	function ClientResponsePlaintext(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ClientResponsePlaintext loginCryptoResponse.
	 * @member {ILoginCryptoResponseUnion} loginCryptoResponse
	 * @memberof ClientResponsePlaintext
	 * @instance
	 */
	ClientResponsePlaintext.prototype.loginCryptoResponse = null;

	/**
	 * ClientResponsePlaintext powResponse.
	 * @member {IPoWResponseUnion} powResponse
	 * @memberof ClientResponsePlaintext
	 * @instance
	 */
	ClientResponsePlaintext.prototype.powResponse = null;

	/**
	 * ClientResponsePlaintext cryptoResponse.
	 * @member {ICryptoResponseUnion} cryptoResponse
	 * @memberof ClientResponsePlaintext
	 * @instance
	 */
	ClientResponsePlaintext.prototype.cryptoResponse = null;

	/**
	 * Creates a new ClientResponsePlaintext instance using the specified properties.
	 * @function create
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {IClientResponsePlaintext=} [properties] Properties to set
	 * @returns {ClientResponsePlaintext} ClientResponsePlaintext instance
	 */
	ClientResponsePlaintext.create = function create(properties) {
		return new ClientResponsePlaintext(properties);
	};

	/**
	 * Encodes the specified ClientResponsePlaintext message. Does not implicitly {@link ClientResponsePlaintext.verify|verify} messages.
	 * @function encode
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {IClientResponsePlaintext} message ClientResponsePlaintext message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientResponsePlaintext.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		$root.LoginCryptoResponseUnion.encode(message.loginCryptoResponse, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		$root.PoWResponseUnion.encode(message.powResponse, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		$root.CryptoResponseUnion.encode(message.cryptoResponse, writer.uint32(/* id 30, wireType 2 =*/ 242).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ClientResponsePlaintext message, length delimited. Does not implicitly {@link ClientResponsePlaintext.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {IClientResponsePlaintext} message ClientResponsePlaintext message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ClientResponsePlaintext.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ClientResponsePlaintext message from the specified reader or buffer.
	 * @function decode
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ClientResponsePlaintext} ClientResponsePlaintext
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientResponsePlaintext.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ClientResponsePlaintext();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.loginCryptoResponse = $root.LoginCryptoResponseUnion.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.powResponse = $root.PoWResponseUnion.decode(reader, reader.uint32());
					break;
				}
				case 30: {
					message.cryptoResponse = $root.CryptoResponseUnion.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("loginCryptoResponse"))
			throw $util.ProtocolError("missing required 'loginCryptoResponse'", { instance: message });
		if (!message.hasOwnProperty("powResponse")) throw $util.ProtocolError("missing required 'powResponse'", { instance: message });
		if (!message.hasOwnProperty("cryptoResponse"))
			throw $util.ProtocolError("missing required 'cryptoResponse'", { instance: message });
		return message;
	};

	/**
	 * Decodes a ClientResponsePlaintext message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ClientResponsePlaintext} ClientResponsePlaintext
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ClientResponsePlaintext.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ClientResponsePlaintext message.
	 * @function verify
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ClientResponsePlaintext.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		{
			var error = $root.LoginCryptoResponseUnion.verify(message.loginCryptoResponse);
			if (error) return "loginCryptoResponse." + error;
		}
		{
			var error = $root.PoWResponseUnion.verify(message.powResponse);
			if (error) return "powResponse." + error;
		}
		{
			var error = $root.CryptoResponseUnion.verify(message.cryptoResponse);
			if (error) return "cryptoResponse." + error;
		}
		return null;
	};

	/**
	 * Creates a ClientResponsePlaintext message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ClientResponsePlaintext} ClientResponsePlaintext
	 */
	ClientResponsePlaintext.fromObject = function fromObject(object) {
		if (object instanceof $root.ClientResponsePlaintext) return object;
		var message = new $root.ClientResponsePlaintext();
		if (object.loginCryptoResponse != null) {
			if (typeof object.loginCryptoResponse !== "object")
				throw TypeError(".ClientResponsePlaintext.loginCryptoResponse: object expected");
			message.loginCryptoResponse = $root.LoginCryptoResponseUnion.fromObject(object.loginCryptoResponse);
		}
		if (object.powResponse != null) {
			if (typeof object.powResponse !== "object") throw TypeError(".ClientResponsePlaintext.powResponse: object expected");
			message.powResponse = $root.PoWResponseUnion.fromObject(object.powResponse);
		}
		if (object.cryptoResponse != null) {
			if (typeof object.cryptoResponse !== "object") throw TypeError(".ClientResponsePlaintext.cryptoResponse: object expected");
			message.cryptoResponse = $root.CryptoResponseUnion.fromObject(object.cryptoResponse);
		}
		return message;
	};

	/**
	 * Creates a plain object from a ClientResponsePlaintext message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {ClientResponsePlaintext} message ClientResponsePlaintext
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ClientResponsePlaintext.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.loginCryptoResponse = null;
			object.powResponse = null;
			object.cryptoResponse = null;
		}
		if (message.loginCryptoResponse != null && message.hasOwnProperty("loginCryptoResponse"))
			object.loginCryptoResponse = $root.LoginCryptoResponseUnion.toObject(message.loginCryptoResponse, options);
		if (message.powResponse != null && message.hasOwnProperty("powResponse"))
			object.powResponse = $root.PoWResponseUnion.toObject(message.powResponse, options);
		if (message.cryptoResponse != null && message.hasOwnProperty("cryptoResponse"))
			object.cryptoResponse = $root.CryptoResponseUnion.toObject(message.cryptoResponse, options);
		return object;
	};

	/**
	 * Converts this ClientResponsePlaintext to JSON.
	 * @function toJSON
	 * @memberof ClientResponsePlaintext
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ClientResponsePlaintext.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ClientResponsePlaintext
	 * @function getTypeUrl
	 * @memberof ClientResponsePlaintext
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ClientResponsePlaintext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ClientResponsePlaintext";
	};

	return ClientResponsePlaintext;
})();

$root.LoginCryptoResponseUnion = (function () {
	/**
	 * Properties of a LoginCryptoResponseUnion.
	 * @exports ILoginCryptoResponseUnion
	 * @interface ILoginCryptoResponseUnion
	 * @property {ILoginCryptoDiffieHellmanResponse|null} [diffieHellman] LoginCryptoResponseUnion diffieHellman
	 */

	/**
	 * Constructs a new LoginCryptoResponseUnion.
	 * @exports LoginCryptoResponseUnion
	 * @classdesc Represents a LoginCryptoResponseUnion.
	 * @implements ILoginCryptoResponseUnion
	 * @constructor
	 * @param {ILoginCryptoResponseUnion=} [properties] Properties to set
	 */
	function LoginCryptoResponseUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * LoginCryptoResponseUnion diffieHellman.
	 * @member {ILoginCryptoDiffieHellmanResponse|null|undefined} diffieHellman
	 * @memberof LoginCryptoResponseUnion
	 * @instance
	 */
	LoginCryptoResponseUnion.prototype.diffieHellman = null;

	/**
	 * Creates a new LoginCryptoResponseUnion instance using the specified properties.
	 * @function create
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {ILoginCryptoResponseUnion=} [properties] Properties to set
	 * @returns {LoginCryptoResponseUnion} LoginCryptoResponseUnion instance
	 */
	LoginCryptoResponseUnion.create = function create(properties) {
		return new LoginCryptoResponseUnion(properties);
	};

	/**
	 * Encodes the specified LoginCryptoResponseUnion message. Does not implicitly {@link LoginCryptoResponseUnion.verify|verify} messages.
	 * @function encode
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {ILoginCryptoResponseUnion} message LoginCryptoResponseUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoResponseUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.diffieHellman != null && Object.hasOwnProperty.call(message, "diffieHellman"))
			$root.LoginCryptoDiffieHellmanResponse.encode(
				message.diffieHellman,
				writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
			).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified LoginCryptoResponseUnion message, length delimited. Does not implicitly {@link LoginCryptoResponseUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {ILoginCryptoResponseUnion} message LoginCryptoResponseUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoResponseUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a LoginCryptoResponseUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {LoginCryptoResponseUnion} LoginCryptoResponseUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoResponseUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.LoginCryptoResponseUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.diffieHellman = $root.LoginCryptoDiffieHellmanResponse.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a LoginCryptoResponseUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {LoginCryptoResponseUnion} LoginCryptoResponseUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoResponseUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a LoginCryptoResponseUnion message.
	 * @function verify
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	LoginCryptoResponseUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.diffieHellman != null && message.hasOwnProperty("diffieHellman")) {
			var error = $root.LoginCryptoDiffieHellmanResponse.verify(message.diffieHellman);
			if (error) return "diffieHellman." + error;
		}
		return null;
	};

	/**
	 * Creates a LoginCryptoResponseUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {LoginCryptoResponseUnion} LoginCryptoResponseUnion
	 */
	LoginCryptoResponseUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.LoginCryptoResponseUnion) return object;
		var message = new $root.LoginCryptoResponseUnion();
		if (object.diffieHellman != null) {
			if (typeof object.diffieHellman !== "object") throw TypeError(".LoginCryptoResponseUnion.diffieHellman: object expected");
			message.diffieHellman = $root.LoginCryptoDiffieHellmanResponse.fromObject(object.diffieHellman);
		}
		return message;
	};

	/**
	 * Creates a plain object from a LoginCryptoResponseUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {LoginCryptoResponseUnion} message LoginCryptoResponseUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	LoginCryptoResponseUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.diffieHellman = null;
		if (message.diffieHellman != null && message.hasOwnProperty("diffieHellman"))
			object.diffieHellman = $root.LoginCryptoDiffieHellmanResponse.toObject(message.diffieHellman, options);
		return object;
	};

	/**
	 * Converts this LoginCryptoResponseUnion to JSON.
	 * @function toJSON
	 * @memberof LoginCryptoResponseUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	LoginCryptoResponseUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for LoginCryptoResponseUnion
	 * @function getTypeUrl
	 * @memberof LoginCryptoResponseUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	LoginCryptoResponseUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/LoginCryptoResponseUnion";
	};

	return LoginCryptoResponseUnion;
})();

$root.LoginCryptoDiffieHellmanResponse = (function () {
	/**
	 * Properties of a LoginCryptoDiffieHellmanResponse.
	 * @exports ILoginCryptoDiffieHellmanResponse
	 * @interface ILoginCryptoDiffieHellmanResponse
	 * @property {Uint8Array} hmac LoginCryptoDiffieHellmanResponse hmac
	 */

	/**
	 * Constructs a new LoginCryptoDiffieHellmanResponse.
	 * @exports LoginCryptoDiffieHellmanResponse
	 * @classdesc Represents a LoginCryptoDiffieHellmanResponse.
	 * @implements ILoginCryptoDiffieHellmanResponse
	 * @constructor
	 * @param {ILoginCryptoDiffieHellmanResponse=} [properties] Properties to set
	 */
	function LoginCryptoDiffieHellmanResponse(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * LoginCryptoDiffieHellmanResponse hmac.
	 * @member {Uint8Array} hmac
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @instance
	 */
	LoginCryptoDiffieHellmanResponse.prototype.hmac = $util.newBuffer([]);

	/**
	 * Creates a new LoginCryptoDiffieHellmanResponse instance using the specified properties.
	 * @function create
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {ILoginCryptoDiffieHellmanResponse=} [properties] Properties to set
	 * @returns {LoginCryptoDiffieHellmanResponse} LoginCryptoDiffieHellmanResponse instance
	 */
	LoginCryptoDiffieHellmanResponse.create = function create(properties) {
		return new LoginCryptoDiffieHellmanResponse(properties);
	};

	/**
	 * Encodes the specified LoginCryptoDiffieHellmanResponse message. Does not implicitly {@link LoginCryptoDiffieHellmanResponse.verify|verify} messages.
	 * @function encode
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {ILoginCryptoDiffieHellmanResponse} message LoginCryptoDiffieHellmanResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoDiffieHellmanResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.hmac);
		return writer;
	};

	/**
	 * Encodes the specified LoginCryptoDiffieHellmanResponse message, length delimited. Does not implicitly {@link LoginCryptoDiffieHellmanResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {ILoginCryptoDiffieHellmanResponse} message LoginCryptoDiffieHellmanResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	LoginCryptoDiffieHellmanResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a LoginCryptoDiffieHellmanResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {LoginCryptoDiffieHellmanResponse} LoginCryptoDiffieHellmanResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoDiffieHellmanResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.LoginCryptoDiffieHellmanResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.hmac = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("hmac")) throw $util.ProtocolError("missing required 'hmac'", { instance: message });
		return message;
	};

	/**
	 * Decodes a LoginCryptoDiffieHellmanResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {LoginCryptoDiffieHellmanResponse} LoginCryptoDiffieHellmanResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	LoginCryptoDiffieHellmanResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a LoginCryptoDiffieHellmanResponse message.
	 * @function verify
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	LoginCryptoDiffieHellmanResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.hmac && typeof message.hmac.length === "number") || $util.isString(message.hmac))) return "hmac: buffer expected";
		return null;
	};

	/**
	 * Creates a LoginCryptoDiffieHellmanResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {LoginCryptoDiffieHellmanResponse} LoginCryptoDiffieHellmanResponse
	 */
	LoginCryptoDiffieHellmanResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.LoginCryptoDiffieHellmanResponse) return object;
		var message = new $root.LoginCryptoDiffieHellmanResponse();
		if (object.hmac != null)
			if (typeof object.hmac === "string")
				$util.base64.decode(object.hmac, (message.hmac = $util.newBuffer($util.base64.length(object.hmac))), 0);
			else if (object.hmac.length >= 0) message.hmac = object.hmac;
		return message;
	};

	/**
	 * Creates a plain object from a LoginCryptoDiffieHellmanResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {LoginCryptoDiffieHellmanResponse} message LoginCryptoDiffieHellmanResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	LoginCryptoDiffieHellmanResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.hmac = "";
			else {
				object.hmac = [];
				if (options.bytes !== Array) object.hmac = $util.newBuffer(object.hmac);
			}
		if (message.hmac != null && message.hasOwnProperty("hmac"))
			object.hmac =
				options.bytes === String
					? $util.base64.encode(message.hmac, 0, message.hmac.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.hmac)
					: message.hmac;
		return object;
	};

	/**
	 * Converts this LoginCryptoDiffieHellmanResponse to JSON.
	 * @function toJSON
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	LoginCryptoDiffieHellmanResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for LoginCryptoDiffieHellmanResponse
	 * @function getTypeUrl
	 * @memberof LoginCryptoDiffieHellmanResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	LoginCryptoDiffieHellmanResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/LoginCryptoDiffieHellmanResponse";
	};

	return LoginCryptoDiffieHellmanResponse;
})();

$root.PoWResponseUnion = (function () {
	/**
	 * Properties of a PoWResponseUnion.
	 * @exports IPoWResponseUnion
	 * @interface IPoWResponseUnion
	 * @property {IPoWHashCashResponse|null} [hashCash] PoWResponseUnion hashCash
	 */

	/**
	 * Constructs a new PoWResponseUnion.
	 * @exports PoWResponseUnion
	 * @classdesc Represents a PoWResponseUnion.
	 * @implements IPoWResponseUnion
	 * @constructor
	 * @param {IPoWResponseUnion=} [properties] Properties to set
	 */
	function PoWResponseUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * PoWResponseUnion hashCash.
	 * @member {IPoWHashCashResponse|null|undefined} hashCash
	 * @memberof PoWResponseUnion
	 * @instance
	 */
	PoWResponseUnion.prototype.hashCash = null;

	/**
	 * Creates a new PoWResponseUnion instance using the specified properties.
	 * @function create
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {IPoWResponseUnion=} [properties] Properties to set
	 * @returns {PoWResponseUnion} PoWResponseUnion instance
	 */
	PoWResponseUnion.create = function create(properties) {
		return new PoWResponseUnion(properties);
	};

	/**
	 * Encodes the specified PoWResponseUnion message. Does not implicitly {@link PoWResponseUnion.verify|verify} messages.
	 * @function encode
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {IPoWResponseUnion} message PoWResponseUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PoWResponseUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.hashCash != null && Object.hasOwnProperty.call(message, "hashCash"))
			$root.PoWHashCashResponse.encode(message.hashCash, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified PoWResponseUnion message, length delimited. Does not implicitly {@link PoWResponseUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {IPoWResponseUnion} message PoWResponseUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PoWResponseUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a PoWResponseUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {PoWResponseUnion} PoWResponseUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PoWResponseUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.PoWResponseUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.hashCash = $root.PoWHashCashResponse.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a PoWResponseUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {PoWResponseUnion} PoWResponseUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PoWResponseUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a PoWResponseUnion message.
	 * @function verify
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	PoWResponseUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.hashCash != null && message.hasOwnProperty("hashCash")) {
			var error = $root.PoWHashCashResponse.verify(message.hashCash);
			if (error) return "hashCash." + error;
		}
		return null;
	};

	/**
	 * Creates a PoWResponseUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {PoWResponseUnion} PoWResponseUnion
	 */
	PoWResponseUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.PoWResponseUnion) return object;
		var message = new $root.PoWResponseUnion();
		if (object.hashCash != null) {
			if (typeof object.hashCash !== "object") throw TypeError(".PoWResponseUnion.hashCash: object expected");
			message.hashCash = $root.PoWHashCashResponse.fromObject(object.hashCash);
		}
		return message;
	};

	/**
	 * Creates a plain object from a PoWResponseUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {PoWResponseUnion} message PoWResponseUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	PoWResponseUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.hashCash = null;
		if (message.hashCash != null && message.hasOwnProperty("hashCash"))
			object.hashCash = $root.PoWHashCashResponse.toObject(message.hashCash, options);
		return object;
	};

	/**
	 * Converts this PoWResponseUnion to JSON.
	 * @function toJSON
	 * @memberof PoWResponseUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	PoWResponseUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for PoWResponseUnion
	 * @function getTypeUrl
	 * @memberof PoWResponseUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	PoWResponseUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/PoWResponseUnion";
	};

	return PoWResponseUnion;
})();

$root.PoWHashCashResponse = (function () {
	/**
	 * Properties of a PoWHashCashResponse.
	 * @exports IPoWHashCashResponse
	 * @interface IPoWHashCashResponse
	 * @property {Uint8Array} hashSuffix PoWHashCashResponse hashSuffix
	 */

	/**
	 * Constructs a new PoWHashCashResponse.
	 * @exports PoWHashCashResponse
	 * @classdesc Represents a PoWHashCashResponse.
	 * @implements IPoWHashCashResponse
	 * @constructor
	 * @param {IPoWHashCashResponse=} [properties] Properties to set
	 */
	function PoWHashCashResponse(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * PoWHashCashResponse hashSuffix.
	 * @member {Uint8Array} hashSuffix
	 * @memberof PoWHashCashResponse
	 * @instance
	 */
	PoWHashCashResponse.prototype.hashSuffix = $util.newBuffer([]);

	/**
	 * Creates a new PoWHashCashResponse instance using the specified properties.
	 * @function create
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {IPoWHashCashResponse=} [properties] Properties to set
	 * @returns {PoWHashCashResponse} PoWHashCashResponse instance
	 */
	PoWHashCashResponse.create = function create(properties) {
		return new PoWHashCashResponse(properties);
	};

	/**
	 * Encodes the specified PoWHashCashResponse message. Does not implicitly {@link PoWHashCashResponse.verify|verify} messages.
	 * @function encode
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {IPoWHashCashResponse} message PoWHashCashResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PoWHashCashResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.hashSuffix);
		return writer;
	};

	/**
	 * Encodes the specified PoWHashCashResponse message, length delimited. Does not implicitly {@link PoWHashCashResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {IPoWHashCashResponse} message PoWHashCashResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	PoWHashCashResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a PoWHashCashResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {PoWHashCashResponse} PoWHashCashResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PoWHashCashResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.PoWHashCashResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.hashSuffix = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		if (!message.hasOwnProperty("hashSuffix")) throw $util.ProtocolError("missing required 'hashSuffix'", { instance: message });
		return message;
	};

	/**
	 * Decodes a PoWHashCashResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {PoWHashCashResponse} PoWHashCashResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	PoWHashCashResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a PoWHashCashResponse message.
	 * @function verify
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	PoWHashCashResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (!((message.hashSuffix && typeof message.hashSuffix.length === "number") || $util.isString(message.hashSuffix)))
			return "hashSuffix: buffer expected";
		return null;
	};

	/**
	 * Creates a PoWHashCashResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {PoWHashCashResponse} PoWHashCashResponse
	 */
	PoWHashCashResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.PoWHashCashResponse) return object;
		var message = new $root.PoWHashCashResponse();
		if (object.hashSuffix != null)
			if (typeof object.hashSuffix === "string")
				$util.base64.decode(object.hashSuffix, (message.hashSuffix = $util.newBuffer($util.base64.length(object.hashSuffix))), 0);
			else if (object.hashSuffix.length >= 0) message.hashSuffix = object.hashSuffix;
		return message;
	};

	/**
	 * Creates a plain object from a PoWHashCashResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {PoWHashCashResponse} message PoWHashCashResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	PoWHashCashResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.hashSuffix = "";
			else {
				object.hashSuffix = [];
				if (options.bytes !== Array) object.hashSuffix = $util.newBuffer(object.hashSuffix);
			}
		if (message.hashSuffix != null && message.hasOwnProperty("hashSuffix"))
			object.hashSuffix =
				options.bytes === String
					? $util.base64.encode(message.hashSuffix, 0, message.hashSuffix.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.hashSuffix)
					: message.hashSuffix;
		return object;
	};

	/**
	 * Converts this PoWHashCashResponse to JSON.
	 * @function toJSON
	 * @memberof PoWHashCashResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	PoWHashCashResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for PoWHashCashResponse
	 * @function getTypeUrl
	 * @memberof PoWHashCashResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	PoWHashCashResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/PoWHashCashResponse";
	};

	return PoWHashCashResponse;
})();

$root.CryptoResponseUnion = (function () {
	/**
	 * Properties of a CryptoResponseUnion.
	 * @exports ICryptoResponseUnion
	 * @interface ICryptoResponseUnion
	 * @property {ICryptoShannonResponse|null} [shannon] CryptoResponseUnion shannon
	 * @property {ICryptoRc4Sha1HmacResponse|null} [rc4Sha1Hmac] CryptoResponseUnion rc4Sha1Hmac
	 */

	/**
	 * Constructs a new CryptoResponseUnion.
	 * @exports CryptoResponseUnion
	 * @classdesc Represents a CryptoResponseUnion.
	 * @implements ICryptoResponseUnion
	 * @constructor
	 * @param {ICryptoResponseUnion=} [properties] Properties to set
	 */
	function CryptoResponseUnion(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * CryptoResponseUnion shannon.
	 * @member {ICryptoShannonResponse|null|undefined} shannon
	 * @memberof CryptoResponseUnion
	 * @instance
	 */
	CryptoResponseUnion.prototype.shannon = null;

	/**
	 * CryptoResponseUnion rc4Sha1Hmac.
	 * @member {ICryptoRc4Sha1HmacResponse|null|undefined} rc4Sha1Hmac
	 * @memberof CryptoResponseUnion
	 * @instance
	 */
	CryptoResponseUnion.prototype.rc4Sha1Hmac = null;

	/**
	 * Creates a new CryptoResponseUnion instance using the specified properties.
	 * @function create
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {ICryptoResponseUnion=} [properties] Properties to set
	 * @returns {CryptoResponseUnion} CryptoResponseUnion instance
	 */
	CryptoResponseUnion.create = function create(properties) {
		return new CryptoResponseUnion(properties);
	};

	/**
	 * Encodes the specified CryptoResponseUnion message. Does not implicitly {@link CryptoResponseUnion.verify|verify} messages.
	 * @function encode
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {ICryptoResponseUnion} message CryptoResponseUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoResponseUnion.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.shannon != null && Object.hasOwnProperty.call(message, "shannon"))
			$root.CryptoShannonResponse.encode(message.shannon, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.rc4Sha1Hmac != null && Object.hasOwnProperty.call(message, "rc4Sha1Hmac"))
			$root.CryptoRc4Sha1HmacResponse.encode(message.rc4Sha1Hmac, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified CryptoResponseUnion message, length delimited. Does not implicitly {@link CryptoResponseUnion.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {ICryptoResponseUnion} message CryptoResponseUnion message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoResponseUnion.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a CryptoResponseUnion message from the specified reader or buffer.
	 * @function decode
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {CryptoResponseUnion} CryptoResponseUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoResponseUnion.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.CryptoResponseUnion();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 10: {
					message.shannon = $root.CryptoShannonResponse.decode(reader, reader.uint32());
					break;
				}
				case 20: {
					message.rc4Sha1Hmac = $root.CryptoRc4Sha1HmacResponse.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a CryptoResponseUnion message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {CryptoResponseUnion} CryptoResponseUnion
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoResponseUnion.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a CryptoResponseUnion message.
	 * @function verify
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	CryptoResponseUnion.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.shannon != null && message.hasOwnProperty("shannon")) {
			var error = $root.CryptoShannonResponse.verify(message.shannon);
			if (error) return "shannon." + error;
		}
		if (message.rc4Sha1Hmac != null && message.hasOwnProperty("rc4Sha1Hmac")) {
			var error = $root.CryptoRc4Sha1HmacResponse.verify(message.rc4Sha1Hmac);
			if (error) return "rc4Sha1Hmac." + error;
		}
		return null;
	};

	/**
	 * Creates a CryptoResponseUnion message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {CryptoResponseUnion} CryptoResponseUnion
	 */
	CryptoResponseUnion.fromObject = function fromObject(object) {
		if (object instanceof $root.CryptoResponseUnion) return object;
		var message = new $root.CryptoResponseUnion();
		if (object.shannon != null) {
			if (typeof object.shannon !== "object") throw TypeError(".CryptoResponseUnion.shannon: object expected");
			message.shannon = $root.CryptoShannonResponse.fromObject(object.shannon);
		}
		if (object.rc4Sha1Hmac != null) {
			if (typeof object.rc4Sha1Hmac !== "object") throw TypeError(".CryptoResponseUnion.rc4Sha1Hmac: object expected");
			message.rc4Sha1Hmac = $root.CryptoRc4Sha1HmacResponse.fromObject(object.rc4Sha1Hmac);
		}
		return message;
	};

	/**
	 * Creates a plain object from a CryptoResponseUnion message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {CryptoResponseUnion} message CryptoResponseUnion
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	CryptoResponseUnion.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.shannon = null;
			object.rc4Sha1Hmac = null;
		}
		if (message.shannon != null && message.hasOwnProperty("shannon"))
			object.shannon = $root.CryptoShannonResponse.toObject(message.shannon, options);
		if (message.rc4Sha1Hmac != null && message.hasOwnProperty("rc4Sha1Hmac"))
			object.rc4Sha1Hmac = $root.CryptoRc4Sha1HmacResponse.toObject(message.rc4Sha1Hmac, options);
		return object;
	};

	/**
	 * Converts this CryptoResponseUnion to JSON.
	 * @function toJSON
	 * @memberof CryptoResponseUnion
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	CryptoResponseUnion.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for CryptoResponseUnion
	 * @function getTypeUrl
	 * @memberof CryptoResponseUnion
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	CryptoResponseUnion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/CryptoResponseUnion";
	};

	return CryptoResponseUnion;
})();

$root.CryptoShannonResponse = (function () {
	/**
	 * Properties of a CryptoShannonResponse.
	 * @exports ICryptoShannonResponse
	 * @interface ICryptoShannonResponse
	 * @property {number|null} [dummy] CryptoShannonResponse dummy
	 */

	/**
	 * Constructs a new CryptoShannonResponse.
	 * @exports CryptoShannonResponse
	 * @classdesc Represents a CryptoShannonResponse.
	 * @implements ICryptoShannonResponse
	 * @constructor
	 * @param {ICryptoShannonResponse=} [properties] Properties to set
	 */
	function CryptoShannonResponse(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * CryptoShannonResponse dummy.
	 * @member {number} dummy
	 * @memberof CryptoShannonResponse
	 * @instance
	 */
	CryptoShannonResponse.prototype.dummy = 0;

	/**
	 * Creates a new CryptoShannonResponse instance using the specified properties.
	 * @function create
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {ICryptoShannonResponse=} [properties] Properties to set
	 * @returns {CryptoShannonResponse} CryptoShannonResponse instance
	 */
	CryptoShannonResponse.create = function create(properties) {
		return new CryptoShannonResponse(properties);
	};

	/**
	 * Encodes the specified CryptoShannonResponse message. Does not implicitly {@link CryptoShannonResponse.verify|verify} messages.
	 * @function encode
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {ICryptoShannonResponse} message CryptoShannonResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoShannonResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.dummy != null && Object.hasOwnProperty.call(message, "dummy"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.dummy);
		return writer;
	};

	/**
	 * Encodes the specified CryptoShannonResponse message, length delimited. Does not implicitly {@link CryptoShannonResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {ICryptoShannonResponse} message CryptoShannonResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoShannonResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a CryptoShannonResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {CryptoShannonResponse} CryptoShannonResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoShannonResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.CryptoShannonResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.dummy = reader.int32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a CryptoShannonResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {CryptoShannonResponse} CryptoShannonResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoShannonResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a CryptoShannonResponse message.
	 * @function verify
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	CryptoShannonResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.dummy != null && message.hasOwnProperty("dummy")) if (!$util.isInteger(message.dummy)) return "dummy: integer expected";
		return null;
	};

	/**
	 * Creates a CryptoShannonResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {CryptoShannonResponse} CryptoShannonResponse
	 */
	CryptoShannonResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.CryptoShannonResponse) return object;
		var message = new $root.CryptoShannonResponse();
		if (object.dummy != null) message.dummy = object.dummy | 0;
		return message;
	};

	/**
	 * Creates a plain object from a CryptoShannonResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {CryptoShannonResponse} message CryptoShannonResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	CryptoShannonResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.dummy = 0;
		if (message.dummy != null && message.hasOwnProperty("dummy")) object.dummy = message.dummy;
		return object;
	};

	/**
	 * Converts this CryptoShannonResponse to JSON.
	 * @function toJSON
	 * @memberof CryptoShannonResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	CryptoShannonResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for CryptoShannonResponse
	 * @function getTypeUrl
	 * @memberof CryptoShannonResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	CryptoShannonResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/CryptoShannonResponse";
	};

	return CryptoShannonResponse;
})();

$root.CryptoRc4Sha1HmacResponse = (function () {
	/**
	 * Properties of a CryptoRc4Sha1HmacResponse.
	 * @exports ICryptoRc4Sha1HmacResponse
	 * @interface ICryptoRc4Sha1HmacResponse
	 * @property {number|null} [dummy] CryptoRc4Sha1HmacResponse dummy
	 */

	/**
	 * Constructs a new CryptoRc4Sha1HmacResponse.
	 * @exports CryptoRc4Sha1HmacResponse
	 * @classdesc Represents a CryptoRc4Sha1HmacResponse.
	 * @implements ICryptoRc4Sha1HmacResponse
	 * @constructor
	 * @param {ICryptoRc4Sha1HmacResponse=} [properties] Properties to set
	 */
	function CryptoRc4Sha1HmacResponse(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * CryptoRc4Sha1HmacResponse dummy.
	 * @member {number} dummy
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @instance
	 */
	CryptoRc4Sha1HmacResponse.prototype.dummy = 0;

	/**
	 * Creates a new CryptoRc4Sha1HmacResponse instance using the specified properties.
	 * @function create
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {ICryptoRc4Sha1HmacResponse=} [properties] Properties to set
	 * @returns {CryptoRc4Sha1HmacResponse} CryptoRc4Sha1HmacResponse instance
	 */
	CryptoRc4Sha1HmacResponse.create = function create(properties) {
		return new CryptoRc4Sha1HmacResponse(properties);
	};

	/**
	 * Encodes the specified CryptoRc4Sha1HmacResponse message. Does not implicitly {@link CryptoRc4Sha1HmacResponse.verify|verify} messages.
	 * @function encode
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {ICryptoRc4Sha1HmacResponse} message CryptoRc4Sha1HmacResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoRc4Sha1HmacResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.dummy != null && Object.hasOwnProperty.call(message, "dummy"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.dummy);
		return writer;
	};

	/**
	 * Encodes the specified CryptoRc4Sha1HmacResponse message, length delimited. Does not implicitly {@link CryptoRc4Sha1HmacResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {ICryptoRc4Sha1HmacResponse} message CryptoRc4Sha1HmacResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	CryptoRc4Sha1HmacResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a CryptoRc4Sha1HmacResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {CryptoRc4Sha1HmacResponse} CryptoRc4Sha1HmacResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoRc4Sha1HmacResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.CryptoRc4Sha1HmacResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.dummy = reader.int32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a CryptoRc4Sha1HmacResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {CryptoRc4Sha1HmacResponse} CryptoRc4Sha1HmacResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	CryptoRc4Sha1HmacResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a CryptoRc4Sha1HmacResponse message.
	 * @function verify
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	CryptoRc4Sha1HmacResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.dummy != null && message.hasOwnProperty("dummy")) if (!$util.isInteger(message.dummy)) return "dummy: integer expected";
		return null;
	};

	/**
	 * Creates a CryptoRc4Sha1HmacResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {CryptoRc4Sha1HmacResponse} CryptoRc4Sha1HmacResponse
	 */
	CryptoRc4Sha1HmacResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.CryptoRc4Sha1HmacResponse) return object;
		var message = new $root.CryptoRc4Sha1HmacResponse();
		if (object.dummy != null) message.dummy = object.dummy | 0;
		return message;
	};

	/**
	 * Creates a plain object from a CryptoRc4Sha1HmacResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {CryptoRc4Sha1HmacResponse} message CryptoRc4Sha1HmacResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	CryptoRc4Sha1HmacResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) object.dummy = 0;
		if (message.dummy != null && message.hasOwnProperty("dummy")) object.dummy = message.dummy;
		return object;
	};

	/**
	 * Converts this CryptoRc4Sha1HmacResponse to JSON.
	 * @function toJSON
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	CryptoRc4Sha1HmacResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for CryptoRc4Sha1HmacResponse
	 * @function getTypeUrl
	 * @memberof CryptoRc4Sha1HmacResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	CryptoRc4Sha1HmacResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/CryptoRc4Sha1HmacResponse";
	};

	return CryptoRc4Sha1HmacResponse;
})();

$root.MercuryMultiGetRequest = (function () {
	/**
	 * Properties of a MercuryMultiGetRequest.
	 * @exports IMercuryMultiGetRequest
	 * @interface IMercuryMultiGetRequest
	 * @property {Array.<IMercuryRequest>|null} [request] MercuryMultiGetRequest request
	 */

	/**
	 * Constructs a new MercuryMultiGetRequest.
	 * @exports MercuryMultiGetRequest
	 * @classdesc Represents a MercuryMultiGetRequest.
	 * @implements IMercuryMultiGetRequest
	 * @constructor
	 * @param {IMercuryMultiGetRequest=} [properties] Properties to set
	 */
	function MercuryMultiGetRequest(properties) {
		this.request = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * MercuryMultiGetRequest request.
	 * @member {Array.<IMercuryRequest>} request
	 * @memberof MercuryMultiGetRequest
	 * @instance
	 */
	MercuryMultiGetRequest.prototype.request = $util.emptyArray;

	/**
	 * Creates a new MercuryMultiGetRequest instance using the specified properties.
	 * @function create
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {IMercuryMultiGetRequest=} [properties] Properties to set
	 * @returns {MercuryMultiGetRequest} MercuryMultiGetRequest instance
	 */
	MercuryMultiGetRequest.create = function create(properties) {
		return new MercuryMultiGetRequest(properties);
	};

	/**
	 * Encodes the specified MercuryMultiGetRequest message. Does not implicitly {@link MercuryMultiGetRequest.verify|verify} messages.
	 * @function encode
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {IMercuryMultiGetRequest} message MercuryMultiGetRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	MercuryMultiGetRequest.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.request != null && message.request.length)
			for (var i = 0; i < message.request.length; ++i)
				$root.MercuryRequest.encode(message.request[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified MercuryMultiGetRequest message, length delimited. Does not implicitly {@link MercuryMultiGetRequest.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {IMercuryMultiGetRequest} message MercuryMultiGetRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	MercuryMultiGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a MercuryMultiGetRequest message from the specified reader or buffer.
	 * @function decode
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {MercuryMultiGetRequest} MercuryMultiGetRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	MercuryMultiGetRequest.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.MercuryMultiGetRequest();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (!(message.request && message.request.length)) message.request = [];
					message.request.push($root.MercuryRequest.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a MercuryMultiGetRequest message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {MercuryMultiGetRequest} MercuryMultiGetRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	MercuryMultiGetRequest.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a MercuryMultiGetRequest message.
	 * @function verify
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	MercuryMultiGetRequest.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.request != null && message.hasOwnProperty("request")) {
			if (!Array.isArray(message.request)) return "request: array expected";
			for (var i = 0; i < message.request.length; ++i) {
				var error = $root.MercuryRequest.verify(message.request[i]);
				if (error) return "request." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a MercuryMultiGetRequest message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {MercuryMultiGetRequest} MercuryMultiGetRequest
	 */
	MercuryMultiGetRequest.fromObject = function fromObject(object) {
		if (object instanceof $root.MercuryMultiGetRequest) return object;
		var message = new $root.MercuryMultiGetRequest();
		if (object.request) {
			if (!Array.isArray(object.request)) throw TypeError(".MercuryMultiGetRequest.request: array expected");
			message.request = [];
			for (var i = 0; i < object.request.length; ++i) {
				if (typeof object.request[i] !== "object") throw TypeError(".MercuryMultiGetRequest.request: object expected");
				message.request[i] = $root.MercuryRequest.fromObject(object.request[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a MercuryMultiGetRequest message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {MercuryMultiGetRequest} message MercuryMultiGetRequest
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	MercuryMultiGetRequest.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.request = [];
		if (message.request && message.request.length) {
			object.request = [];
			for (var j = 0; j < message.request.length; ++j) object.request[j] = $root.MercuryRequest.toObject(message.request[j], options);
		}
		return object;
	};

	/**
	 * Converts this MercuryMultiGetRequest to JSON.
	 * @function toJSON
	 * @memberof MercuryMultiGetRequest
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	MercuryMultiGetRequest.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for MercuryMultiGetRequest
	 * @function getTypeUrl
	 * @memberof MercuryMultiGetRequest
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	MercuryMultiGetRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/MercuryMultiGetRequest";
	};

	return MercuryMultiGetRequest;
})();

$root.MercuryMultiGetReply = (function () {
	/**
	 * Properties of a MercuryMultiGetReply.
	 * @exports IMercuryMultiGetReply
	 * @interface IMercuryMultiGetReply
	 * @property {Array.<IMercuryReply>|null} [reply] MercuryMultiGetReply reply
	 */

	/**
	 * Constructs a new MercuryMultiGetReply.
	 * @exports MercuryMultiGetReply
	 * @classdesc Represents a MercuryMultiGetReply.
	 * @implements IMercuryMultiGetReply
	 * @constructor
	 * @param {IMercuryMultiGetReply=} [properties] Properties to set
	 */
	function MercuryMultiGetReply(properties) {
		this.reply = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * MercuryMultiGetReply reply.
	 * @member {Array.<IMercuryReply>} reply
	 * @memberof MercuryMultiGetReply
	 * @instance
	 */
	MercuryMultiGetReply.prototype.reply = $util.emptyArray;

	/**
	 * Creates a new MercuryMultiGetReply instance using the specified properties.
	 * @function create
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {IMercuryMultiGetReply=} [properties] Properties to set
	 * @returns {MercuryMultiGetReply} MercuryMultiGetReply instance
	 */
	MercuryMultiGetReply.create = function create(properties) {
		return new MercuryMultiGetReply(properties);
	};

	/**
	 * Encodes the specified MercuryMultiGetReply message. Does not implicitly {@link MercuryMultiGetReply.verify|verify} messages.
	 * @function encode
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {IMercuryMultiGetReply} message MercuryMultiGetReply message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	MercuryMultiGetReply.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.reply != null && message.reply.length)
			for (var i = 0; i < message.reply.length; ++i)
				$root.MercuryReply.encode(message.reply[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified MercuryMultiGetReply message, length delimited. Does not implicitly {@link MercuryMultiGetReply.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {IMercuryMultiGetReply} message MercuryMultiGetReply message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	MercuryMultiGetReply.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a MercuryMultiGetReply message from the specified reader or buffer.
	 * @function decode
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {MercuryMultiGetReply} MercuryMultiGetReply
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	MercuryMultiGetReply.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.MercuryMultiGetReply();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (!(message.reply && message.reply.length)) message.reply = [];
					message.reply.push($root.MercuryReply.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a MercuryMultiGetReply message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {MercuryMultiGetReply} MercuryMultiGetReply
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	MercuryMultiGetReply.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a MercuryMultiGetReply message.
	 * @function verify
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	MercuryMultiGetReply.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.reply != null && message.hasOwnProperty("reply")) {
			if (!Array.isArray(message.reply)) return "reply: array expected";
			for (var i = 0; i < message.reply.length; ++i) {
				var error = $root.MercuryReply.verify(message.reply[i]);
				if (error) return "reply." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a MercuryMultiGetReply message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {MercuryMultiGetReply} MercuryMultiGetReply
	 */
	MercuryMultiGetReply.fromObject = function fromObject(object) {
		if (object instanceof $root.MercuryMultiGetReply) return object;
		var message = new $root.MercuryMultiGetReply();
		if (object.reply) {
			if (!Array.isArray(object.reply)) throw TypeError(".MercuryMultiGetReply.reply: array expected");
			message.reply = [];
			for (var i = 0; i < object.reply.length; ++i) {
				if (typeof object.reply[i] !== "object") throw TypeError(".MercuryMultiGetReply.reply: object expected");
				message.reply[i] = $root.MercuryReply.fromObject(object.reply[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a MercuryMultiGetReply message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {MercuryMultiGetReply} message MercuryMultiGetReply
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	MercuryMultiGetReply.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.reply = [];
		if (message.reply && message.reply.length) {
			object.reply = [];
			for (var j = 0; j < message.reply.length; ++j) object.reply[j] = $root.MercuryReply.toObject(message.reply[j], options);
		}
		return object;
	};

	/**
	 * Converts this MercuryMultiGetReply to JSON.
	 * @function toJSON
	 * @memberof MercuryMultiGetReply
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	MercuryMultiGetReply.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for MercuryMultiGetReply
	 * @function getTypeUrl
	 * @memberof MercuryMultiGetReply
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	MercuryMultiGetReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/MercuryMultiGetReply";
	};

	return MercuryMultiGetReply;
})();

$root.MercuryRequest = (function () {
	/**
	 * Properties of a MercuryRequest.
	 * @exports IMercuryRequest
	 * @interface IMercuryRequest
	 * @property {string|null} [uri] MercuryRequest uri
	 * @property {string|null} [contentType] MercuryRequest contentType
	 * @property {Uint8Array|null} [body] MercuryRequest body
	 * @property {Uint8Array|null} [etag] MercuryRequest etag
	 */

	/**
	 * Constructs a new MercuryRequest.
	 * @exports MercuryRequest
	 * @classdesc Represents a MercuryRequest.
	 * @implements IMercuryRequest
	 * @constructor
	 * @param {IMercuryRequest=} [properties] Properties to set
	 */
	function MercuryRequest(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * MercuryRequest uri.
	 * @member {string} uri
	 * @memberof MercuryRequest
	 * @instance
	 */
	MercuryRequest.prototype.uri = "";

	/**
	 * MercuryRequest contentType.
	 * @member {string} contentType
	 * @memberof MercuryRequest
	 * @instance
	 */
	MercuryRequest.prototype.contentType = "";

	/**
	 * MercuryRequest body.
	 * @member {Uint8Array} body
	 * @memberof MercuryRequest
	 * @instance
	 */
	MercuryRequest.prototype.body = $util.newBuffer([]);

	/**
	 * MercuryRequest etag.
	 * @member {Uint8Array} etag
	 * @memberof MercuryRequest
	 * @instance
	 */
	MercuryRequest.prototype.etag = $util.newBuffer([]);

	/**
	 * Creates a new MercuryRequest instance using the specified properties.
	 * @function create
	 * @memberof MercuryRequest
	 * @static
	 * @param {IMercuryRequest=} [properties] Properties to set
	 * @returns {MercuryRequest} MercuryRequest instance
	 */
	MercuryRequest.create = function create(properties) {
		return new MercuryRequest(properties);
	};

	/**
	 * Encodes the specified MercuryRequest message. Does not implicitly {@link MercuryRequest.verify|verify} messages.
	 * @function encode
	 * @memberof MercuryRequest
	 * @static
	 * @param {IMercuryRequest} message MercuryRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	MercuryRequest.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.uri);
		if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.contentType);
		if (message.body != null && Object.hasOwnProperty.call(message, "body"))
			writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.body);
		if (message.etag != null && Object.hasOwnProperty.call(message, "etag"))
			writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.etag);
		return writer;
	};

	/**
	 * Encodes the specified MercuryRequest message, length delimited. Does not implicitly {@link MercuryRequest.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof MercuryRequest
	 * @static
	 * @param {IMercuryRequest} message MercuryRequest message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	MercuryRequest.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a MercuryRequest message from the specified reader or buffer.
	 * @function decode
	 * @memberof MercuryRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {MercuryRequest} MercuryRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	MercuryRequest.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.MercuryRequest();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.uri = reader.string();
					break;
				}
				case 2: {
					message.contentType = reader.string();
					break;
				}
				case 3: {
					message.body = reader.bytes();
					break;
				}
				case 4: {
					message.etag = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a MercuryRequest message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof MercuryRequest
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {MercuryRequest} MercuryRequest
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	MercuryRequest.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a MercuryRequest message.
	 * @function verify
	 * @memberof MercuryRequest
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	MercuryRequest.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.uri != null && message.hasOwnProperty("uri")) if (!$util.isString(message.uri)) return "uri: string expected";
		if (message.contentType != null && message.hasOwnProperty("contentType"))
			if (!$util.isString(message.contentType)) return "contentType: string expected";
		if (message.body != null && message.hasOwnProperty("body"))
			if (!((message.body && typeof message.body.length === "number") || $util.isString(message.body)))
				return "body: buffer expected";
		if (message.etag != null && message.hasOwnProperty("etag"))
			if (!((message.etag && typeof message.etag.length === "number") || $util.isString(message.etag)))
				return "etag: buffer expected";
		return null;
	};

	/**
	 * Creates a MercuryRequest message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof MercuryRequest
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {MercuryRequest} MercuryRequest
	 */
	MercuryRequest.fromObject = function fromObject(object) {
		if (object instanceof $root.MercuryRequest) return object;
		var message = new $root.MercuryRequest();
		if (object.uri != null) message.uri = String(object.uri);
		if (object.contentType != null) message.contentType = String(object.contentType);
		if (object.body != null)
			if (typeof object.body === "string")
				$util.base64.decode(object.body, (message.body = $util.newBuffer($util.base64.length(object.body))), 0);
			else if (object.body.length >= 0) message.body = object.body;
		if (object.etag != null)
			if (typeof object.etag === "string")
				$util.base64.decode(object.etag, (message.etag = $util.newBuffer($util.base64.length(object.etag))), 0);
			else if (object.etag.length >= 0) message.etag = object.etag;
		return message;
	};

	/**
	 * Creates a plain object from a MercuryRequest message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof MercuryRequest
	 * @static
	 * @param {MercuryRequest} message MercuryRequest
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	MercuryRequest.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.uri = "";
			object.contentType = "";
			if (options.bytes === String) object.body = "";
			else {
				object.body = [];
				if (options.bytes !== Array) object.body = $util.newBuffer(object.body);
			}
			if (options.bytes === String) object.etag = "";
			else {
				object.etag = [];
				if (options.bytes !== Array) object.etag = $util.newBuffer(object.etag);
			}
		}
		if (message.uri != null && message.hasOwnProperty("uri")) object.uri = message.uri;
		if (message.contentType != null && message.hasOwnProperty("contentType")) object.contentType = message.contentType;
		if (message.body != null && message.hasOwnProperty("body"))
			object.body =
				options.bytes === String
					? $util.base64.encode(message.body, 0, message.body.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.body)
					: message.body;
		if (message.etag != null && message.hasOwnProperty("etag"))
			object.etag =
				options.bytes === String
					? $util.base64.encode(message.etag, 0, message.etag.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.etag)
					: message.etag;
		return object;
	};

	/**
	 * Converts this MercuryRequest to JSON.
	 * @function toJSON
	 * @memberof MercuryRequest
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	MercuryRequest.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for MercuryRequest
	 * @function getTypeUrl
	 * @memberof MercuryRequest
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	MercuryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/MercuryRequest";
	};

	return MercuryRequest;
})();

$root.MercuryReply = (function () {
	/**
	 * Properties of a MercuryReply.
	 * @exports IMercuryReply
	 * @interface IMercuryReply
	 * @property {number|null} [statusCode] MercuryReply statusCode
	 * @property {string|null} [statusMessage] MercuryReply statusMessage
	 * @property {MercuryReply.CachePolicy|null} [cachePolicy] MercuryReply cachePolicy
	 * @property {number|null} [ttl] MercuryReply ttl
	 * @property {Uint8Array|null} [etag] MercuryReply etag
	 * @property {string|null} [contentType] MercuryReply contentType
	 * @property {Uint8Array|null} [body] MercuryReply body
	 */

	/**
	 * Constructs a new MercuryReply.
	 * @exports MercuryReply
	 * @classdesc Represents a MercuryReply.
	 * @implements IMercuryReply
	 * @constructor
	 * @param {IMercuryReply=} [properties] Properties to set
	 */
	function MercuryReply(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * MercuryReply statusCode.
	 * @member {number} statusCode
	 * @memberof MercuryReply
	 * @instance
	 */
	MercuryReply.prototype.statusCode = 0;

	/**
	 * MercuryReply statusMessage.
	 * @member {string} statusMessage
	 * @memberof MercuryReply
	 * @instance
	 */
	MercuryReply.prototype.statusMessage = "";

	/**
	 * MercuryReply cachePolicy.
	 * @member {MercuryReply.CachePolicy} cachePolicy
	 * @memberof MercuryReply
	 * @instance
	 */
	MercuryReply.prototype.cachePolicy = 1;

	/**
	 * MercuryReply ttl.
	 * @member {number} ttl
	 * @memberof MercuryReply
	 * @instance
	 */
	MercuryReply.prototype.ttl = 0;

	/**
	 * MercuryReply etag.
	 * @member {Uint8Array} etag
	 * @memberof MercuryReply
	 * @instance
	 */
	MercuryReply.prototype.etag = $util.newBuffer([]);

	/**
	 * MercuryReply contentType.
	 * @member {string} contentType
	 * @memberof MercuryReply
	 * @instance
	 */
	MercuryReply.prototype.contentType = "";

	/**
	 * MercuryReply body.
	 * @member {Uint8Array} body
	 * @memberof MercuryReply
	 * @instance
	 */
	MercuryReply.prototype.body = $util.newBuffer([]);

	/**
	 * Creates a new MercuryReply instance using the specified properties.
	 * @function create
	 * @memberof MercuryReply
	 * @static
	 * @param {IMercuryReply=} [properties] Properties to set
	 * @returns {MercuryReply} MercuryReply instance
	 */
	MercuryReply.create = function create(properties) {
		return new MercuryReply(properties);
	};

	/**
	 * Encodes the specified MercuryReply message. Does not implicitly {@link MercuryReply.verify|verify} messages.
	 * @function encode
	 * @memberof MercuryReply
	 * @static
	 * @param {IMercuryReply} message MercuryReply message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	MercuryReply.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.statusCode);
		if (message.statusMessage != null && Object.hasOwnProperty.call(message, "statusMessage"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.statusMessage);
		if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
			writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.cachePolicy);
		if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
			writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.ttl);
		if (message.etag != null && Object.hasOwnProperty.call(message, "etag"))
			writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.etag);
		if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
			writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.contentType);
		if (message.body != null && Object.hasOwnProperty.call(message, "body"))
			writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.body);
		return writer;
	};

	/**
	 * Encodes the specified MercuryReply message, length delimited. Does not implicitly {@link MercuryReply.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof MercuryReply
	 * @static
	 * @param {IMercuryReply} message MercuryReply message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	MercuryReply.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a MercuryReply message from the specified reader or buffer.
	 * @function decode
	 * @memberof MercuryReply
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {MercuryReply} MercuryReply
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	MercuryReply.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.MercuryReply();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.statusCode = reader.sint32();
					break;
				}
				case 2: {
					message.statusMessage = reader.string();
					break;
				}
				case 3: {
					message.cachePolicy = reader.int32();
					break;
				}
				case 4: {
					message.ttl = reader.sint32();
					break;
				}
				case 5: {
					message.etag = reader.bytes();
					break;
				}
				case 6: {
					message.contentType = reader.string();
					break;
				}
				case 7: {
					message.body = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a MercuryReply message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof MercuryReply
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {MercuryReply} MercuryReply
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	MercuryReply.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a MercuryReply message.
	 * @function verify
	 * @memberof MercuryReply
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	MercuryReply.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.statusCode != null && message.hasOwnProperty("statusCode"))
			if (!$util.isInteger(message.statusCode)) return "statusCode: integer expected";
		if (message.statusMessage != null && message.hasOwnProperty("statusMessage"))
			if (!$util.isString(message.statusMessage)) return "statusMessage: string expected";
		if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
			switch (message.cachePolicy) {
				default:
					return "cachePolicy: enum value expected";
				case 1:
				case 2:
				case 3:
					break;
			}
		if (message.ttl != null && message.hasOwnProperty("ttl")) if (!$util.isInteger(message.ttl)) return "ttl: integer expected";
		if (message.etag != null && message.hasOwnProperty("etag"))
			if (!((message.etag && typeof message.etag.length === "number") || $util.isString(message.etag)))
				return "etag: buffer expected";
		if (message.contentType != null && message.hasOwnProperty("contentType"))
			if (!$util.isString(message.contentType)) return "contentType: string expected";
		if (message.body != null && message.hasOwnProperty("body"))
			if (!((message.body && typeof message.body.length === "number") || $util.isString(message.body)))
				return "body: buffer expected";
		return null;
	};

	/**
	 * Creates a MercuryReply message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof MercuryReply
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {MercuryReply} MercuryReply
	 */
	MercuryReply.fromObject = function fromObject(object) {
		if (object instanceof $root.MercuryReply) return object;
		var message = new $root.MercuryReply();
		if (object.statusCode != null) message.statusCode = object.statusCode | 0;
		if (object.statusMessage != null) message.statusMessage = String(object.statusMessage);
		switch (object.cachePolicy) {
			default:
				if (typeof object.cachePolicy === "number") {
					message.cachePolicy = object.cachePolicy;
					break;
				}
				break;
			case "CACHE_NO":
			case 1:
				message.cachePolicy = 1;
				break;
			case "CACHE_PRIVATE":
			case 2:
				message.cachePolicy = 2;
				break;
			case "CACHE_PUBLIC":
			case 3:
				message.cachePolicy = 3;
				break;
		}
		if (object.ttl != null) message.ttl = object.ttl | 0;
		if (object.etag != null)
			if (typeof object.etag === "string")
				$util.base64.decode(object.etag, (message.etag = $util.newBuffer($util.base64.length(object.etag))), 0);
			else if (object.etag.length >= 0) message.etag = object.etag;
		if (object.contentType != null) message.contentType = String(object.contentType);
		if (object.body != null)
			if (typeof object.body === "string")
				$util.base64.decode(object.body, (message.body = $util.newBuffer($util.base64.length(object.body))), 0);
			else if (object.body.length >= 0) message.body = object.body;
		return message;
	};

	/**
	 * Creates a plain object from a MercuryReply message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof MercuryReply
	 * @static
	 * @param {MercuryReply} message MercuryReply
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	MercuryReply.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.statusCode = 0;
			object.statusMessage = "";
			object.cachePolicy = options.enums === String ? "CACHE_NO" : 1;
			object.ttl = 0;
			if (options.bytes === String) object.etag = "";
			else {
				object.etag = [];
				if (options.bytes !== Array) object.etag = $util.newBuffer(object.etag);
			}
			object.contentType = "";
			if (options.bytes === String) object.body = "";
			else {
				object.body = [];
				if (options.bytes !== Array) object.body = $util.newBuffer(object.body);
			}
		}
		if (message.statusCode != null && message.hasOwnProperty("statusCode")) object.statusCode = message.statusCode;
		if (message.statusMessage != null && message.hasOwnProperty("statusMessage")) object.statusMessage = message.statusMessage;
		if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
			object.cachePolicy =
				options.enums === String
					? $root.MercuryReply.CachePolicy[message.cachePolicy] === undefined
						? message.cachePolicy
						: $root.MercuryReply.CachePolicy[message.cachePolicy]
					: message.cachePolicy;
		if (message.ttl != null && message.hasOwnProperty("ttl")) object.ttl = message.ttl;
		if (message.etag != null && message.hasOwnProperty("etag"))
			object.etag =
				options.bytes === String
					? $util.base64.encode(message.etag, 0, message.etag.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.etag)
					: message.etag;
		if (message.contentType != null && message.hasOwnProperty("contentType")) object.contentType = message.contentType;
		if (message.body != null && message.hasOwnProperty("body"))
			object.body =
				options.bytes === String
					? $util.base64.encode(message.body, 0, message.body.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.body)
					: message.body;
		return object;
	};

	/**
	 * Converts this MercuryReply to JSON.
	 * @function toJSON
	 * @memberof MercuryReply
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	MercuryReply.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for MercuryReply
	 * @function getTypeUrl
	 * @memberof MercuryReply
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	MercuryReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/MercuryReply";
	};

	/**
	 * CachePolicy enum.
	 * @name MercuryReply.CachePolicy
	 * @enum {number}
	 * @property {number} CACHE_NO=1 CACHE_NO value
	 * @property {number} CACHE_PRIVATE=2 CACHE_PRIVATE value
	 * @property {number} CACHE_PUBLIC=3 CACHE_PUBLIC value
	 */
	MercuryReply.CachePolicy = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[1] = "CACHE_NO")] = 1;
		values[(valuesById[2] = "CACHE_PRIVATE")] = 2;
		values[(valuesById[3] = "CACHE_PUBLIC")] = 3;
		return values;
	})();

	return MercuryReply;
})();

$root.Header = (function () {
	/**
	 * Properties of a Header.
	 * @exports IHeader
	 * @interface IHeader
	 * @property {string|null} [uri] Header uri
	 * @property {string|null} [contentType] Header contentType
	 * @property {string|null} [method] Header method
	 * @property {number|null} [statusCode] Header statusCode
	 * @property {Array.<IUserField>|null} [userFields] Header userFields
	 */

	/**
	 * Constructs a new Header.
	 * @exports Header
	 * @classdesc Represents a Header.
	 * @implements IHeader
	 * @constructor
	 * @param {IHeader=} [properties] Properties to set
	 */
	function Header(properties) {
		this.userFields = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Header uri.
	 * @member {string} uri
	 * @memberof Header
	 * @instance
	 */
	Header.prototype.uri = "";

	/**
	 * Header contentType.
	 * @member {string} contentType
	 * @memberof Header
	 * @instance
	 */
	Header.prototype.contentType = "";

	/**
	 * Header method.
	 * @member {string} method
	 * @memberof Header
	 * @instance
	 */
	Header.prototype.method = "";

	/**
	 * Header statusCode.
	 * @member {number} statusCode
	 * @memberof Header
	 * @instance
	 */
	Header.prototype.statusCode = 0;

	/**
	 * Header userFields.
	 * @member {Array.<IUserField>} userFields
	 * @memberof Header
	 * @instance
	 */
	Header.prototype.userFields = $util.emptyArray;

	/**
	 * Creates a new Header instance using the specified properties.
	 * @function create
	 * @memberof Header
	 * @static
	 * @param {IHeader=} [properties] Properties to set
	 * @returns {Header} Header instance
	 */
	Header.create = function create(properties) {
		return new Header(properties);
	};

	/**
	 * Encodes the specified Header message. Does not implicitly {@link Header.verify|verify} messages.
	 * @function encode
	 * @memberof Header
	 * @static
	 * @param {IHeader} message Header message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Header.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.uri);
		if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.contentType);
		if (message.method != null && Object.hasOwnProperty.call(message, "method"))
			writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.method);
		if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
			writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.statusCode);
		if (message.userFields != null && message.userFields.length)
			for (var i = 0; i < message.userFields.length; ++i)
				$root.UserField.encode(message.userFields[i], writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified Header message, length delimited. Does not implicitly {@link Header.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Header
	 * @static
	 * @param {IHeader} message Header message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Header.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Header message from the specified reader or buffer.
	 * @function decode
	 * @memberof Header
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Header} Header
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Header.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Header();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.uri = reader.string();
					break;
				}
				case 2: {
					message.contentType = reader.string();
					break;
				}
				case 3: {
					message.method = reader.string();
					break;
				}
				case 4: {
					message.statusCode = reader.sint32();
					break;
				}
				case 6: {
					if (!(message.userFields && message.userFields.length)) message.userFields = [];
					message.userFields.push($root.UserField.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Header message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Header
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Header} Header
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Header.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Header message.
	 * @function verify
	 * @memberof Header
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Header.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.uri != null && message.hasOwnProperty("uri")) if (!$util.isString(message.uri)) return "uri: string expected";
		if (message.contentType != null && message.hasOwnProperty("contentType"))
			if (!$util.isString(message.contentType)) return "contentType: string expected";
		if (message.method != null && message.hasOwnProperty("method"))
			if (!$util.isString(message.method)) return "method: string expected";
		if (message.statusCode != null && message.hasOwnProperty("statusCode"))
			if (!$util.isInteger(message.statusCode)) return "statusCode: integer expected";
		if (message.userFields != null && message.hasOwnProperty("userFields")) {
			if (!Array.isArray(message.userFields)) return "userFields: array expected";
			for (var i = 0; i < message.userFields.length; ++i) {
				var error = $root.UserField.verify(message.userFields[i]);
				if (error) return "userFields." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a Header message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Header
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Header} Header
	 */
	Header.fromObject = function fromObject(object) {
		if (object instanceof $root.Header) return object;
		var message = new $root.Header();
		if (object.uri != null) message.uri = String(object.uri);
		if (object.contentType != null) message.contentType = String(object.contentType);
		if (object.method != null) message.method = String(object.method);
		if (object.statusCode != null) message.statusCode = object.statusCode | 0;
		if (object.userFields) {
			if (!Array.isArray(object.userFields)) throw TypeError(".Header.userFields: array expected");
			message.userFields = [];
			for (var i = 0; i < object.userFields.length; ++i) {
				if (typeof object.userFields[i] !== "object") throw TypeError(".Header.userFields: object expected");
				message.userFields[i] = $root.UserField.fromObject(object.userFields[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a Header message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Header
	 * @static
	 * @param {Header} message Header
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Header.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.userFields = [];
		if (options.defaults) {
			object.uri = "";
			object.contentType = "";
			object.method = "";
			object.statusCode = 0;
		}
		if (message.uri != null && message.hasOwnProperty("uri")) object.uri = message.uri;
		if (message.contentType != null && message.hasOwnProperty("contentType")) object.contentType = message.contentType;
		if (message.method != null && message.hasOwnProperty("method")) object.method = message.method;
		if (message.statusCode != null && message.hasOwnProperty("statusCode")) object.statusCode = message.statusCode;
		if (message.userFields && message.userFields.length) {
			object.userFields = [];
			for (var j = 0; j < message.userFields.length; ++j)
				object.userFields[j] = $root.UserField.toObject(message.userFields[j], options);
		}
		return object;
	};

	/**
	 * Converts this Header to JSON.
	 * @function toJSON
	 * @memberof Header
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Header.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Header
	 * @function getTypeUrl
	 * @memberof Header
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Header.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Header";
	};

	return Header;
})();

$root.UserField = (function () {
	/**
	 * Properties of a UserField.
	 * @exports IUserField
	 * @interface IUserField
	 * @property {string|null} [key] UserField key
	 * @property {Uint8Array|null} [value] UserField value
	 */

	/**
	 * Constructs a new UserField.
	 * @exports UserField
	 * @classdesc Represents a UserField.
	 * @implements IUserField
	 * @constructor
	 * @param {IUserField=} [properties] Properties to set
	 */
	function UserField(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * UserField key.
	 * @member {string} key
	 * @memberof UserField
	 * @instance
	 */
	UserField.prototype.key = "";

	/**
	 * UserField value.
	 * @member {Uint8Array} value
	 * @memberof UserField
	 * @instance
	 */
	UserField.prototype.value = $util.newBuffer([]);

	/**
	 * Creates a new UserField instance using the specified properties.
	 * @function create
	 * @memberof UserField
	 * @static
	 * @param {IUserField=} [properties] Properties to set
	 * @returns {UserField} UserField instance
	 */
	UserField.create = function create(properties) {
		return new UserField(properties);
	};

	/**
	 * Encodes the specified UserField message. Does not implicitly {@link UserField.verify|verify} messages.
	 * @function encode
	 * @memberof UserField
	 * @static
	 * @param {IUserField} message UserField message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	UserField.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.key != null && Object.hasOwnProperty.call(message, "key"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
		if (message.value != null && Object.hasOwnProperty.call(message, "value"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.value);
		return writer;
	};

	/**
	 * Encodes the specified UserField message, length delimited. Does not implicitly {@link UserField.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof UserField
	 * @static
	 * @param {IUserField} message UserField message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	UserField.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a UserField message from the specified reader or buffer.
	 * @function decode
	 * @memberof UserField
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {UserField} UserField
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	UserField.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.UserField();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.key = reader.string();
					break;
				}
				case 2: {
					message.value = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a UserField message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof UserField
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {UserField} UserField
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	UserField.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a UserField message.
	 * @function verify
	 * @memberof UserField
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	UserField.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.key != null && message.hasOwnProperty("key")) if (!$util.isString(message.key)) return "key: string expected";
		if (message.value != null && message.hasOwnProperty("value"))
			if (!((message.value && typeof message.value.length === "number") || $util.isString(message.value)))
				return "value: buffer expected";
		return null;
	};

	/**
	 * Creates a UserField message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof UserField
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {UserField} UserField
	 */
	UserField.fromObject = function fromObject(object) {
		if (object instanceof $root.UserField) return object;
		var message = new $root.UserField();
		if (object.key != null) message.key = String(object.key);
		if (object.value != null)
			if (typeof object.value === "string")
				$util.base64.decode(object.value, (message.value = $util.newBuffer($util.base64.length(object.value))), 0);
			else if (object.value.length >= 0) message.value = object.value;
		return message;
	};

	/**
	 * Creates a plain object from a UserField message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof UserField
	 * @static
	 * @param {UserField} message UserField
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	UserField.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.key = "";
			if (options.bytes === String) object.value = "";
			else {
				object.value = [];
				if (options.bytes !== Array) object.value = $util.newBuffer(object.value);
			}
		}
		if (message.key != null && message.hasOwnProperty("key")) object.key = message.key;
		if (message.value != null && message.hasOwnProperty("value"))
			object.value =
				options.bytes === String
					? $util.base64.encode(message.value, 0, message.value.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.value)
					: message.value;
		return object;
	};

	/**
	 * Converts this UserField to JSON.
	 * @function toJSON
	 * @memberof UserField
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	UserField.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for UserField
	 * @function getTypeUrl
	 * @memberof UserField
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	UserField.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/UserField";
	};

	return UserField;
})();

$root.Artist = (function () {
	/**
	 * Properties of an Artist.
	 * @exports IArtist
	 * @interface IArtist
	 * @property {Uint8Array|null} [gid] Artist gid
	 * @property {string|null} [name] Artist name
	 * @property {number|null} [popularity] Artist popularity
	 * @property {Array.<ITopTracks>|null} [topTrack] Artist topTrack
	 * @property {Array.<IAlbumGroup>|null} [albumGroup] Artist albumGroup
	 * @property {Array.<IAlbumGroup>|null} [singleGroup] Artist singleGroup
	 * @property {Array.<IAlbumGroup>|null} [compilationGroup] Artist compilationGroup
	 * @property {Array.<IAlbumGroup>|null} [appearsOnGroup] Artist appearsOnGroup
	 * @property {Array.<string>|null} [genre] Artist genre
	 * @property {Array.<IExternalId>|null} [externalId] Artist externalId
	 * @property {Array.<IImage>|null} [portrait] Artist portrait
	 * @property {Array.<IBiography>|null} [biography] Artist biography
	 * @property {Array.<IActivityPeriod>|null} [activityPeriod] Artist activityPeriod
	 * @property {Array.<IRestriction>|null} [restriction] Artist restriction
	 * @property {Array.<IArtist>|null} [related] Artist related
	 * @property {boolean|null} [isPortraitAlbumCover] Artist isPortraitAlbumCover
	 * @property {IImageGroup|null} [portraitGroup] Artist portraitGroup
	 * @property {Array.<ISalePeriod>|null} [salePeriod] Artist salePeriod
	 * @property {Array.<IAvailability>|null} [availability] Artist availability
	 */

	/**
	 * Constructs a new Artist.
	 * @exports Artist
	 * @classdesc Represents an Artist.
	 * @implements IArtist
	 * @constructor
	 * @param {IArtist=} [properties] Properties to set
	 */
	function Artist(properties) {
		this.topTrack = [];
		this.albumGroup = [];
		this.singleGroup = [];
		this.compilationGroup = [];
		this.appearsOnGroup = [];
		this.genre = [];
		this.externalId = [];
		this.portrait = [];
		this.biography = [];
		this.activityPeriod = [];
		this.restriction = [];
		this.related = [];
		this.salePeriod = [];
		this.availability = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Artist gid.
	 * @member {Uint8Array} gid
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.gid = $util.newBuffer([]);

	/**
	 * Artist name.
	 * @member {string} name
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.name = "";

	/**
	 * Artist popularity.
	 * @member {number} popularity
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.popularity = 0;

	/**
	 * Artist topTrack.
	 * @member {Array.<ITopTracks>} topTrack
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.topTrack = $util.emptyArray;

	/**
	 * Artist albumGroup.
	 * @member {Array.<IAlbumGroup>} albumGroup
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.albumGroup = $util.emptyArray;

	/**
	 * Artist singleGroup.
	 * @member {Array.<IAlbumGroup>} singleGroup
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.singleGroup = $util.emptyArray;

	/**
	 * Artist compilationGroup.
	 * @member {Array.<IAlbumGroup>} compilationGroup
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.compilationGroup = $util.emptyArray;

	/**
	 * Artist appearsOnGroup.
	 * @member {Array.<IAlbumGroup>} appearsOnGroup
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.appearsOnGroup = $util.emptyArray;

	/**
	 * Artist genre.
	 * @member {Array.<string>} genre
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.genre = $util.emptyArray;

	/**
	 * Artist externalId.
	 * @member {Array.<IExternalId>} externalId
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.externalId = $util.emptyArray;

	/**
	 * Artist portrait.
	 * @member {Array.<IImage>} portrait
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.portrait = $util.emptyArray;

	/**
	 * Artist biography.
	 * @member {Array.<IBiography>} biography
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.biography = $util.emptyArray;

	/**
	 * Artist activityPeriod.
	 * @member {Array.<IActivityPeriod>} activityPeriod
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.activityPeriod = $util.emptyArray;

	/**
	 * Artist restriction.
	 * @member {Array.<IRestriction>} restriction
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.restriction = $util.emptyArray;

	/**
	 * Artist related.
	 * @member {Array.<IArtist>} related
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.related = $util.emptyArray;

	/**
	 * Artist isPortraitAlbumCover.
	 * @member {boolean} isPortraitAlbumCover
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.isPortraitAlbumCover = false;

	/**
	 * Artist portraitGroup.
	 * @member {IImageGroup|null|undefined} portraitGroup
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.portraitGroup = null;

	/**
	 * Artist salePeriod.
	 * @member {Array.<ISalePeriod>} salePeriod
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.salePeriod = $util.emptyArray;

	/**
	 * Artist availability.
	 * @member {Array.<IAvailability>} availability
	 * @memberof Artist
	 * @instance
	 */
	Artist.prototype.availability = $util.emptyArray;

	/**
	 * Creates a new Artist instance using the specified properties.
	 * @function create
	 * @memberof Artist
	 * @static
	 * @param {IArtist=} [properties] Properties to set
	 * @returns {Artist} Artist instance
	 */
	Artist.create = function create(properties) {
		return new Artist(properties);
	};

	/**
	 * Encodes the specified Artist message. Does not implicitly {@link Artist.verify|verify} messages.
	 * @function encode
	 * @memberof Artist
	 * @static
	 * @param {IArtist} message Artist message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Artist.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.gid != null && Object.hasOwnProperty.call(message, "gid")) writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.gid);
		if (message.name != null && Object.hasOwnProperty.call(message, "name"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
		if (message.popularity != null && Object.hasOwnProperty.call(message, "popularity"))
			writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.popularity);
		if (message.topTrack != null && message.topTrack.length)
			for (var i = 0; i < message.topTrack.length; ++i)
				$root.TopTracks.encode(message.topTrack[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
		if (message.albumGroup != null && message.albumGroup.length)
			for (var i = 0; i < message.albumGroup.length; ++i)
				$root.AlbumGroup.encode(message.albumGroup[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
		if (message.singleGroup != null && message.singleGroup.length)
			for (var i = 0; i < message.singleGroup.length; ++i)
				$root.AlbumGroup.encode(message.singleGroup[i], writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
		if (message.compilationGroup != null && message.compilationGroup.length)
			for (var i = 0; i < message.compilationGroup.length; ++i)
				$root.AlbumGroup.encode(message.compilationGroup[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
		if (message.appearsOnGroup != null && message.appearsOnGroup.length)
			for (var i = 0; i < message.appearsOnGroup.length; ++i)
				$root.AlbumGroup.encode(message.appearsOnGroup[i], writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
		if (message.genre != null && message.genre.length)
			for (var i = 0; i < message.genre.length; ++i) writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.genre[i]);
		if (message.externalId != null && message.externalId.length)
			for (var i = 0; i < message.externalId.length; ++i)
				$root.ExternalId.encode(message.externalId[i], writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.portrait != null && message.portrait.length)
			for (var i = 0; i < message.portrait.length; ++i)
				$root.Image.encode(message.portrait[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
		if (message.biography != null && message.biography.length)
			for (var i = 0; i < message.biography.length; ++i)
				$root.Biography.encode(message.biography[i], writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
		if (message.activityPeriod != null && message.activityPeriod.length)
			for (var i = 0; i < message.activityPeriod.length; ++i)
				$root.ActivityPeriod.encode(message.activityPeriod[i], writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
		if (message.restriction != null && message.restriction.length)
			for (var i = 0; i < message.restriction.length; ++i)
				$root.Restriction.encode(message.restriction[i], writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
		if (message.related != null && message.related.length)
			for (var i = 0; i < message.related.length; ++i)
				$root.Artist.encode(message.related[i], writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
		if (message.isPortraitAlbumCover != null && Object.hasOwnProperty.call(message, "isPortraitAlbumCover"))
			writer.uint32(/* id 16, wireType 0 =*/ 128).bool(message.isPortraitAlbumCover);
		if (message.portraitGroup != null && Object.hasOwnProperty.call(message, "portraitGroup"))
			$root.ImageGroup.encode(message.portraitGroup, writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
		if (message.salePeriod != null && message.salePeriod.length)
			for (var i = 0; i < message.salePeriod.length; ++i)
				$root.SalePeriod.encode(message.salePeriod[i], writer.uint32(/* id 18, wireType 2 =*/ 146).fork()).ldelim();
		if (message.availability != null && message.availability.length)
			for (var i = 0; i < message.availability.length; ++i)
				$root.Availability.encode(message.availability[i], writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified Artist message, length delimited. Does not implicitly {@link Artist.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Artist
	 * @static
	 * @param {IArtist} message Artist message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Artist.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an Artist message from the specified reader or buffer.
	 * @function decode
	 * @memberof Artist
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Artist} Artist
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Artist.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Artist();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.gid = reader.bytes();
					break;
				}
				case 2: {
					message.name = reader.string();
					break;
				}
				case 3: {
					message.popularity = reader.sint32();
					break;
				}
				case 4: {
					if (!(message.topTrack && message.topTrack.length)) message.topTrack = [];
					message.topTrack.push($root.TopTracks.decode(reader, reader.uint32()));
					break;
				}
				case 5: {
					if (!(message.albumGroup && message.albumGroup.length)) message.albumGroup = [];
					message.albumGroup.push($root.AlbumGroup.decode(reader, reader.uint32()));
					break;
				}
				case 6: {
					if (!(message.singleGroup && message.singleGroup.length)) message.singleGroup = [];
					message.singleGroup.push($root.AlbumGroup.decode(reader, reader.uint32()));
					break;
				}
				case 7: {
					if (!(message.compilationGroup && message.compilationGroup.length)) message.compilationGroup = [];
					message.compilationGroup.push($root.AlbumGroup.decode(reader, reader.uint32()));
					break;
				}
				case 8: {
					if (!(message.appearsOnGroup && message.appearsOnGroup.length)) message.appearsOnGroup = [];
					message.appearsOnGroup.push($root.AlbumGroup.decode(reader, reader.uint32()));
					break;
				}
				case 9: {
					if (!(message.genre && message.genre.length)) message.genre = [];
					message.genre.push(reader.string());
					break;
				}
				case 10: {
					if (!(message.externalId && message.externalId.length)) message.externalId = [];
					message.externalId.push($root.ExternalId.decode(reader, reader.uint32()));
					break;
				}
				case 11: {
					if (!(message.portrait && message.portrait.length)) message.portrait = [];
					message.portrait.push($root.Image.decode(reader, reader.uint32()));
					break;
				}
				case 12: {
					if (!(message.biography && message.biography.length)) message.biography = [];
					message.biography.push($root.Biography.decode(reader, reader.uint32()));
					break;
				}
				case 13: {
					if (!(message.activityPeriod && message.activityPeriod.length)) message.activityPeriod = [];
					message.activityPeriod.push($root.ActivityPeriod.decode(reader, reader.uint32()));
					break;
				}
				case 14: {
					if (!(message.restriction && message.restriction.length)) message.restriction = [];
					message.restriction.push($root.Restriction.decode(reader, reader.uint32()));
					break;
				}
				case 15: {
					if (!(message.related && message.related.length)) message.related = [];
					message.related.push($root.Artist.decode(reader, reader.uint32()));
					break;
				}
				case 16: {
					message.isPortraitAlbumCover = reader.bool();
					break;
				}
				case 17: {
					message.portraitGroup = $root.ImageGroup.decode(reader, reader.uint32());
					break;
				}
				case 18: {
					if (!(message.salePeriod && message.salePeriod.length)) message.salePeriod = [];
					message.salePeriod.push($root.SalePeriod.decode(reader, reader.uint32()));
					break;
				}
				case 20: {
					if (!(message.availability && message.availability.length)) message.availability = [];
					message.availability.push($root.Availability.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an Artist message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Artist
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Artist} Artist
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Artist.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an Artist message.
	 * @function verify
	 * @memberof Artist
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Artist.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.gid != null && message.hasOwnProperty("gid"))
			if (!((message.gid && typeof message.gid.length === "number") || $util.isString(message.gid))) return "gid: buffer expected";
		if (message.name != null && message.hasOwnProperty("name")) if (!$util.isString(message.name)) return "name: string expected";
		if (message.popularity != null && message.hasOwnProperty("popularity"))
			if (!$util.isInteger(message.popularity)) return "popularity: integer expected";
		if (message.topTrack != null && message.hasOwnProperty("topTrack")) {
			if (!Array.isArray(message.topTrack)) return "topTrack: array expected";
			for (var i = 0; i < message.topTrack.length; ++i) {
				var error = $root.TopTracks.verify(message.topTrack[i]);
				if (error) return "topTrack." + error;
			}
		}
		if (message.albumGroup != null && message.hasOwnProperty("albumGroup")) {
			if (!Array.isArray(message.albumGroup)) return "albumGroup: array expected";
			for (var i = 0; i < message.albumGroup.length; ++i) {
				var error = $root.AlbumGroup.verify(message.albumGroup[i]);
				if (error) return "albumGroup." + error;
			}
		}
		if (message.singleGroup != null && message.hasOwnProperty("singleGroup")) {
			if (!Array.isArray(message.singleGroup)) return "singleGroup: array expected";
			for (var i = 0; i < message.singleGroup.length; ++i) {
				var error = $root.AlbumGroup.verify(message.singleGroup[i]);
				if (error) return "singleGroup." + error;
			}
		}
		if (message.compilationGroup != null && message.hasOwnProperty("compilationGroup")) {
			if (!Array.isArray(message.compilationGroup)) return "compilationGroup: array expected";
			for (var i = 0; i < message.compilationGroup.length; ++i) {
				var error = $root.AlbumGroup.verify(message.compilationGroup[i]);
				if (error) return "compilationGroup." + error;
			}
		}
		if (message.appearsOnGroup != null && message.hasOwnProperty("appearsOnGroup")) {
			if (!Array.isArray(message.appearsOnGroup)) return "appearsOnGroup: array expected";
			for (var i = 0; i < message.appearsOnGroup.length; ++i) {
				var error = $root.AlbumGroup.verify(message.appearsOnGroup[i]);
				if (error) return "appearsOnGroup." + error;
			}
		}
		if (message.genre != null && message.hasOwnProperty("genre")) {
			if (!Array.isArray(message.genre)) return "genre: array expected";
			for (var i = 0; i < message.genre.length; ++i) if (!$util.isString(message.genre[i])) return "genre: string[] expected";
		}
		if (message.externalId != null && message.hasOwnProperty("externalId")) {
			if (!Array.isArray(message.externalId)) return "externalId: array expected";
			for (var i = 0; i < message.externalId.length; ++i) {
				var error = $root.ExternalId.verify(message.externalId[i]);
				if (error) return "externalId." + error;
			}
		}
		if (message.portrait != null && message.hasOwnProperty("portrait")) {
			if (!Array.isArray(message.portrait)) return "portrait: array expected";
			for (var i = 0; i < message.portrait.length; ++i) {
				var error = $root.Image.verify(message.portrait[i]);
				if (error) return "portrait." + error;
			}
		}
		if (message.biography != null && message.hasOwnProperty("biography")) {
			if (!Array.isArray(message.biography)) return "biography: array expected";
			for (var i = 0; i < message.biography.length; ++i) {
				var error = $root.Biography.verify(message.biography[i]);
				if (error) return "biography." + error;
			}
		}
		if (message.activityPeriod != null && message.hasOwnProperty("activityPeriod")) {
			if (!Array.isArray(message.activityPeriod)) return "activityPeriod: array expected";
			for (var i = 0; i < message.activityPeriod.length; ++i) {
				var error = $root.ActivityPeriod.verify(message.activityPeriod[i]);
				if (error) return "activityPeriod." + error;
			}
		}
		if (message.restriction != null && message.hasOwnProperty("restriction")) {
			if (!Array.isArray(message.restriction)) return "restriction: array expected";
			for (var i = 0; i < message.restriction.length; ++i) {
				var error = $root.Restriction.verify(message.restriction[i]);
				if (error) return "restriction." + error;
			}
		}
		if (message.related != null && message.hasOwnProperty("related")) {
			if (!Array.isArray(message.related)) return "related: array expected";
			for (var i = 0; i < message.related.length; ++i) {
				var error = $root.Artist.verify(message.related[i]);
				if (error) return "related." + error;
			}
		}
		if (message.isPortraitAlbumCover != null && message.hasOwnProperty("isPortraitAlbumCover"))
			if (typeof message.isPortraitAlbumCover !== "boolean") return "isPortraitAlbumCover: boolean expected";
		if (message.portraitGroup != null && message.hasOwnProperty("portraitGroup")) {
			var error = $root.ImageGroup.verify(message.portraitGroup);
			if (error) return "portraitGroup." + error;
		}
		if (message.salePeriod != null && message.hasOwnProperty("salePeriod")) {
			if (!Array.isArray(message.salePeriod)) return "salePeriod: array expected";
			for (var i = 0; i < message.salePeriod.length; ++i) {
				var error = $root.SalePeriod.verify(message.salePeriod[i]);
				if (error) return "salePeriod." + error;
			}
		}
		if (message.availability != null && message.hasOwnProperty("availability")) {
			if (!Array.isArray(message.availability)) return "availability: array expected";
			for (var i = 0; i < message.availability.length; ++i) {
				var error = $root.Availability.verify(message.availability[i]);
				if (error) return "availability." + error;
			}
		}
		return null;
	};

	/**
	 * Creates an Artist message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Artist
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Artist} Artist
	 */
	Artist.fromObject = function fromObject(object) {
		if (object instanceof $root.Artist) return object;
		var message = new $root.Artist();
		if (object.gid != null)
			if (typeof object.gid === "string")
				$util.base64.decode(object.gid, (message.gid = $util.newBuffer($util.base64.length(object.gid))), 0);
			else if (object.gid.length >= 0) message.gid = object.gid;
		if (object.name != null) message.name = String(object.name);
		if (object.popularity != null) message.popularity = object.popularity | 0;
		if (object.topTrack) {
			if (!Array.isArray(object.topTrack)) throw TypeError(".Artist.topTrack: array expected");
			message.topTrack = [];
			for (var i = 0; i < object.topTrack.length; ++i) {
				if (typeof object.topTrack[i] !== "object") throw TypeError(".Artist.topTrack: object expected");
				message.topTrack[i] = $root.TopTracks.fromObject(object.topTrack[i]);
			}
		}
		if (object.albumGroup) {
			if (!Array.isArray(object.albumGroup)) throw TypeError(".Artist.albumGroup: array expected");
			message.albumGroup = [];
			for (var i = 0; i < object.albumGroup.length; ++i) {
				if (typeof object.albumGroup[i] !== "object") throw TypeError(".Artist.albumGroup: object expected");
				message.albumGroup[i] = $root.AlbumGroup.fromObject(object.albumGroup[i]);
			}
		}
		if (object.singleGroup) {
			if (!Array.isArray(object.singleGroup)) throw TypeError(".Artist.singleGroup: array expected");
			message.singleGroup = [];
			for (var i = 0; i < object.singleGroup.length; ++i) {
				if (typeof object.singleGroup[i] !== "object") throw TypeError(".Artist.singleGroup: object expected");
				message.singleGroup[i] = $root.AlbumGroup.fromObject(object.singleGroup[i]);
			}
		}
		if (object.compilationGroup) {
			if (!Array.isArray(object.compilationGroup)) throw TypeError(".Artist.compilationGroup: array expected");
			message.compilationGroup = [];
			for (var i = 0; i < object.compilationGroup.length; ++i) {
				if (typeof object.compilationGroup[i] !== "object") throw TypeError(".Artist.compilationGroup: object expected");
				message.compilationGroup[i] = $root.AlbumGroup.fromObject(object.compilationGroup[i]);
			}
		}
		if (object.appearsOnGroup) {
			if (!Array.isArray(object.appearsOnGroup)) throw TypeError(".Artist.appearsOnGroup: array expected");
			message.appearsOnGroup = [];
			for (var i = 0; i < object.appearsOnGroup.length; ++i) {
				if (typeof object.appearsOnGroup[i] !== "object") throw TypeError(".Artist.appearsOnGroup: object expected");
				message.appearsOnGroup[i] = $root.AlbumGroup.fromObject(object.appearsOnGroup[i]);
			}
		}
		if (object.genre) {
			if (!Array.isArray(object.genre)) throw TypeError(".Artist.genre: array expected");
			message.genre = [];
			for (var i = 0; i < object.genre.length; ++i) message.genre[i] = String(object.genre[i]);
		}
		if (object.externalId) {
			if (!Array.isArray(object.externalId)) throw TypeError(".Artist.externalId: array expected");
			message.externalId = [];
			for (var i = 0; i < object.externalId.length; ++i) {
				if (typeof object.externalId[i] !== "object") throw TypeError(".Artist.externalId: object expected");
				message.externalId[i] = $root.ExternalId.fromObject(object.externalId[i]);
			}
		}
		if (object.portrait) {
			if (!Array.isArray(object.portrait)) throw TypeError(".Artist.portrait: array expected");
			message.portrait = [];
			for (var i = 0; i < object.portrait.length; ++i) {
				if (typeof object.portrait[i] !== "object") throw TypeError(".Artist.portrait: object expected");
				message.portrait[i] = $root.Image.fromObject(object.portrait[i]);
			}
		}
		if (object.biography) {
			if (!Array.isArray(object.biography)) throw TypeError(".Artist.biography: array expected");
			message.biography = [];
			for (var i = 0; i < object.biography.length; ++i) {
				if (typeof object.biography[i] !== "object") throw TypeError(".Artist.biography: object expected");
				message.biography[i] = $root.Biography.fromObject(object.biography[i]);
			}
		}
		if (object.activityPeriod) {
			if (!Array.isArray(object.activityPeriod)) throw TypeError(".Artist.activityPeriod: array expected");
			message.activityPeriod = [];
			for (var i = 0; i < object.activityPeriod.length; ++i) {
				if (typeof object.activityPeriod[i] !== "object") throw TypeError(".Artist.activityPeriod: object expected");
				message.activityPeriod[i] = $root.ActivityPeriod.fromObject(object.activityPeriod[i]);
			}
		}
		if (object.restriction) {
			if (!Array.isArray(object.restriction)) throw TypeError(".Artist.restriction: array expected");
			message.restriction = [];
			for (var i = 0; i < object.restriction.length; ++i) {
				if (typeof object.restriction[i] !== "object") throw TypeError(".Artist.restriction: object expected");
				message.restriction[i] = $root.Restriction.fromObject(object.restriction[i]);
			}
		}
		if (object.related) {
			if (!Array.isArray(object.related)) throw TypeError(".Artist.related: array expected");
			message.related = [];
			for (var i = 0; i < object.related.length; ++i) {
				if (typeof object.related[i] !== "object") throw TypeError(".Artist.related: object expected");
				message.related[i] = $root.Artist.fromObject(object.related[i]);
			}
		}
		if (object.isPortraitAlbumCover != null) message.isPortraitAlbumCover = Boolean(object.isPortraitAlbumCover);
		if (object.portraitGroup != null) {
			if (typeof object.portraitGroup !== "object") throw TypeError(".Artist.portraitGroup: object expected");
			message.portraitGroup = $root.ImageGroup.fromObject(object.portraitGroup);
		}
		if (object.salePeriod) {
			if (!Array.isArray(object.salePeriod)) throw TypeError(".Artist.salePeriod: array expected");
			message.salePeriod = [];
			for (var i = 0; i < object.salePeriod.length; ++i) {
				if (typeof object.salePeriod[i] !== "object") throw TypeError(".Artist.salePeriod: object expected");
				message.salePeriod[i] = $root.SalePeriod.fromObject(object.salePeriod[i]);
			}
		}
		if (object.availability) {
			if (!Array.isArray(object.availability)) throw TypeError(".Artist.availability: array expected");
			message.availability = [];
			for (var i = 0; i < object.availability.length; ++i) {
				if (typeof object.availability[i] !== "object") throw TypeError(".Artist.availability: object expected");
				message.availability[i] = $root.Availability.fromObject(object.availability[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from an Artist message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Artist
	 * @static
	 * @param {Artist} message Artist
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Artist.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) {
			object.topTrack = [];
			object.albumGroup = [];
			object.singleGroup = [];
			object.compilationGroup = [];
			object.appearsOnGroup = [];
			object.genre = [];
			object.externalId = [];
			object.portrait = [];
			object.biography = [];
			object.activityPeriod = [];
			object.restriction = [];
			object.related = [];
			object.salePeriod = [];
			object.availability = [];
		}
		if (options.defaults) {
			if (options.bytes === String) object.gid = "";
			else {
				object.gid = [];
				if (options.bytes !== Array) object.gid = $util.newBuffer(object.gid);
			}
			object.name = "";
			object.popularity = 0;
			object.isPortraitAlbumCover = false;
			object.portraitGroup = null;
		}
		if (message.gid != null && message.hasOwnProperty("gid"))
			object.gid =
				options.bytes === String
					? $util.base64.encode(message.gid, 0, message.gid.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.gid)
					: message.gid;
		if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
		if (message.popularity != null && message.hasOwnProperty("popularity")) object.popularity = message.popularity;
		if (message.topTrack && message.topTrack.length) {
			object.topTrack = [];
			for (var j = 0; j < message.topTrack.length; ++j) object.topTrack[j] = $root.TopTracks.toObject(message.topTrack[j], options);
		}
		if (message.albumGroup && message.albumGroup.length) {
			object.albumGroup = [];
			for (var j = 0; j < message.albumGroup.length; ++j)
				object.albumGroup[j] = $root.AlbumGroup.toObject(message.albumGroup[j], options);
		}
		if (message.singleGroup && message.singleGroup.length) {
			object.singleGroup = [];
			for (var j = 0; j < message.singleGroup.length; ++j)
				object.singleGroup[j] = $root.AlbumGroup.toObject(message.singleGroup[j], options);
		}
		if (message.compilationGroup && message.compilationGroup.length) {
			object.compilationGroup = [];
			for (var j = 0; j < message.compilationGroup.length; ++j)
				object.compilationGroup[j] = $root.AlbumGroup.toObject(message.compilationGroup[j], options);
		}
		if (message.appearsOnGroup && message.appearsOnGroup.length) {
			object.appearsOnGroup = [];
			for (var j = 0; j < message.appearsOnGroup.length; ++j)
				object.appearsOnGroup[j] = $root.AlbumGroup.toObject(message.appearsOnGroup[j], options);
		}
		if (message.genre && message.genre.length) {
			object.genre = [];
			for (var j = 0; j < message.genre.length; ++j) object.genre[j] = message.genre[j];
		}
		if (message.externalId && message.externalId.length) {
			object.externalId = [];
			for (var j = 0; j < message.externalId.length; ++j)
				object.externalId[j] = $root.ExternalId.toObject(message.externalId[j], options);
		}
		if (message.portrait && message.portrait.length) {
			object.portrait = [];
			for (var j = 0; j < message.portrait.length; ++j) object.portrait[j] = $root.Image.toObject(message.portrait[j], options);
		}
		if (message.biography && message.biography.length) {
			object.biography = [];
			for (var j = 0; j < message.biography.length; ++j)
				object.biography[j] = $root.Biography.toObject(message.biography[j], options);
		}
		if (message.activityPeriod && message.activityPeriod.length) {
			object.activityPeriod = [];
			for (var j = 0; j < message.activityPeriod.length; ++j)
				object.activityPeriod[j] = $root.ActivityPeriod.toObject(message.activityPeriod[j], options);
		}
		if (message.restriction && message.restriction.length) {
			object.restriction = [];
			for (var j = 0; j < message.restriction.length; ++j)
				object.restriction[j] = $root.Restriction.toObject(message.restriction[j], options);
		}
		if (message.related && message.related.length) {
			object.related = [];
			for (var j = 0; j < message.related.length; ++j) object.related[j] = $root.Artist.toObject(message.related[j], options);
		}
		if (message.isPortraitAlbumCover != null && message.hasOwnProperty("isPortraitAlbumCover"))
			object.isPortraitAlbumCover = message.isPortraitAlbumCover;
		if (message.portraitGroup != null && message.hasOwnProperty("portraitGroup"))
			object.portraitGroup = $root.ImageGroup.toObject(message.portraitGroup, options);
		if (message.salePeriod && message.salePeriod.length) {
			object.salePeriod = [];
			for (var j = 0; j < message.salePeriod.length; ++j)
				object.salePeriod[j] = $root.SalePeriod.toObject(message.salePeriod[j], options);
		}
		if (message.availability && message.availability.length) {
			object.availability = [];
			for (var j = 0; j < message.availability.length; ++j)
				object.availability[j] = $root.Availability.toObject(message.availability[j], options);
		}
		return object;
	};

	/**
	 * Converts this Artist to JSON.
	 * @function toJSON
	 * @memberof Artist
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Artist.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Artist
	 * @function getTypeUrl
	 * @memberof Artist
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Artist.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Artist";
	};

	return Artist;
})();

$root.Album = (function () {
	/**
	 * Properties of an Album.
	 * @exports IAlbum
	 * @interface IAlbum
	 * @property {Uint8Array|null} [gid] Album gid
	 * @property {string|null} [name] Album name
	 * @property {Array.<IArtist>|null} [artist] Album artist
	 * @property {Album.Type|null} [type] Album type
	 * @property {string|null} [label] Album label
	 * @property {IDate|null} [date] Album date
	 * @property {number|null} [popularity] Album popularity
	 * @property {Array.<string>|null} [genre] Album genre
	 * @property {Array.<IImage>|null} [cover] Album cover
	 * @property {Array.<IExternalId>|null} [externalId] Album externalId
	 * @property {Array.<IDisc>|null} [disc] Album disc
	 * @property {Array.<string>|null} [review] Album review
	 * @property {Array.<ICopyright>|null} [copyright] Album copyright
	 * @property {Array.<IRestriction>|null} [restriction] Album restriction
	 * @property {Array.<IAlbum>|null} [related] Album related
	 * @property {Array.<ISalePeriod>|null} [salePeriod] Album salePeriod
	 * @property {IImageGroup|null} [coverGroup] Album coverGroup
	 * @property {string|null} [originalTitle] Album originalTitle
	 * @property {string|null} [versionTitle] Album versionTitle
	 * @property {string|null} [typeStr] Album typeStr
	 * @property {Array.<IAvailability>|null} [availability] Album availability
	 */

	/**
	 * Constructs a new Album.
	 * @exports Album
	 * @classdesc Represents an Album.
	 * @implements IAlbum
	 * @constructor
	 * @param {IAlbum=} [properties] Properties to set
	 */
	function Album(properties) {
		this.artist = [];
		this.genre = [];
		this.cover = [];
		this.externalId = [];
		this.disc = [];
		this.review = [];
		this.copyright = [];
		this.restriction = [];
		this.related = [];
		this.salePeriod = [];
		this.availability = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Album gid.
	 * @member {Uint8Array} gid
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.gid = $util.newBuffer([]);

	/**
	 * Album name.
	 * @member {string} name
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.name = "";

	/**
	 * Album artist.
	 * @member {Array.<IArtist>} artist
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.artist = $util.emptyArray;

	/**
	 * Album type.
	 * @member {Album.Type} type
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.type = 1;

	/**
	 * Album label.
	 * @member {string} label
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.label = "";

	/**
	 * Album date.
	 * @member {IDate|null|undefined} date
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.date = null;

	/**
	 * Album popularity.
	 * @member {number} popularity
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.popularity = 0;

	/**
	 * Album genre.
	 * @member {Array.<string>} genre
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.genre = $util.emptyArray;

	/**
	 * Album cover.
	 * @member {Array.<IImage>} cover
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.cover = $util.emptyArray;

	/**
	 * Album externalId.
	 * @member {Array.<IExternalId>} externalId
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.externalId = $util.emptyArray;

	/**
	 * Album disc.
	 * @member {Array.<IDisc>} disc
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.disc = $util.emptyArray;

	/**
	 * Album review.
	 * @member {Array.<string>} review
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.review = $util.emptyArray;

	/**
	 * Album copyright.
	 * @member {Array.<ICopyright>} copyright
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.copyright = $util.emptyArray;

	/**
	 * Album restriction.
	 * @member {Array.<IRestriction>} restriction
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.restriction = $util.emptyArray;

	/**
	 * Album related.
	 * @member {Array.<IAlbum>} related
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.related = $util.emptyArray;

	/**
	 * Album salePeriod.
	 * @member {Array.<ISalePeriod>} salePeriod
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.salePeriod = $util.emptyArray;

	/**
	 * Album coverGroup.
	 * @member {IImageGroup|null|undefined} coverGroup
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.coverGroup = null;

	/**
	 * Album originalTitle.
	 * @member {string} originalTitle
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.originalTitle = "";

	/**
	 * Album versionTitle.
	 * @member {string} versionTitle
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.versionTitle = "";

	/**
	 * Album typeStr.
	 * @member {string} typeStr
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.typeStr = "";

	/**
	 * Album availability.
	 * @member {Array.<IAvailability>} availability
	 * @memberof Album
	 * @instance
	 */
	Album.prototype.availability = $util.emptyArray;

	/**
	 * Creates a new Album instance using the specified properties.
	 * @function create
	 * @memberof Album
	 * @static
	 * @param {IAlbum=} [properties] Properties to set
	 * @returns {Album} Album instance
	 */
	Album.create = function create(properties) {
		return new Album(properties);
	};

	/**
	 * Encodes the specified Album message. Does not implicitly {@link Album.verify|verify} messages.
	 * @function encode
	 * @memberof Album
	 * @static
	 * @param {IAlbum} message Album message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Album.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.gid != null && Object.hasOwnProperty.call(message, "gid")) writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.gid);
		if (message.name != null && Object.hasOwnProperty.call(message, "name"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
		if (message.artist != null && message.artist.length)
			for (var i = 0; i < message.artist.length; ++i)
				$root.Artist.encode(message.artist[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		if (message.type != null && Object.hasOwnProperty.call(message, "type"))
			writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.type);
		if (message.label != null && Object.hasOwnProperty.call(message, "label"))
			writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.label);
		if (message.date != null && Object.hasOwnProperty.call(message, "date"))
			$root.Date.encode(message.date, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
		if (message.popularity != null && Object.hasOwnProperty.call(message, "popularity"))
			writer.uint32(/* id 7, wireType 0 =*/ 56).sint32(message.popularity);
		if (message.genre != null && message.genre.length)
			for (var i = 0; i < message.genre.length; ++i) writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.genre[i]);
		if (message.cover != null && message.cover.length)
			for (var i = 0; i < message.cover.length; ++i)
				$root.Image.encode(message.cover[i], writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
		if (message.externalId != null && message.externalId.length)
			for (var i = 0; i < message.externalId.length; ++i)
				$root.ExternalId.encode(message.externalId[i], writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.disc != null && message.disc.length)
			for (var i = 0; i < message.disc.length; ++i)
				$root.Disc.encode(message.disc[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
		if (message.review != null && message.review.length)
			for (var i = 0; i < message.review.length; ++i) writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.review[i]);
		if (message.copyright != null && message.copyright.length)
			for (var i = 0; i < message.copyright.length; ++i)
				$root.Copyright.encode(message.copyright[i], writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
		if (message.restriction != null && message.restriction.length)
			for (var i = 0; i < message.restriction.length; ++i)
				$root.Restriction.encode(message.restriction[i], writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
		if (message.related != null && message.related.length)
			for (var i = 0; i < message.related.length; ++i)
				$root.Album.encode(message.related[i], writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
		if (message.salePeriod != null && message.salePeriod.length)
			for (var i = 0; i < message.salePeriod.length; ++i)
				$root.SalePeriod.encode(message.salePeriod[i], writer.uint32(/* id 16, wireType 2 =*/ 130).fork()).ldelim();
		if (message.coverGroup != null && Object.hasOwnProperty.call(message, "coverGroup"))
			$root.ImageGroup.encode(message.coverGroup, writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
		if (message.originalTitle != null && Object.hasOwnProperty.call(message, "originalTitle"))
			writer.uint32(/* id 18, wireType 2 =*/ 146).string(message.originalTitle);
		if (message.versionTitle != null && Object.hasOwnProperty.call(message, "versionTitle"))
			writer.uint32(/* id 19, wireType 2 =*/ 154).string(message.versionTitle);
		if (message.typeStr != null && Object.hasOwnProperty.call(message, "typeStr"))
			writer.uint32(/* id 20, wireType 2 =*/ 162).string(message.typeStr);
		if (message.availability != null && message.availability.length)
			for (var i = 0; i < message.availability.length; ++i)
				$root.Availability.encode(message.availability[i], writer.uint32(/* id 23, wireType 2 =*/ 186).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified Album message, length delimited. Does not implicitly {@link Album.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Album
	 * @static
	 * @param {IAlbum} message Album message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Album.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an Album message from the specified reader or buffer.
	 * @function decode
	 * @memberof Album
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Album} Album
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Album.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Album();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.gid = reader.bytes();
					break;
				}
				case 2: {
					message.name = reader.string();
					break;
				}
				case 3: {
					if (!(message.artist && message.artist.length)) message.artist = [];
					message.artist.push($root.Artist.decode(reader, reader.uint32()));
					break;
				}
				case 4: {
					message.type = reader.int32();
					break;
				}
				case 5: {
					message.label = reader.string();
					break;
				}
				case 6: {
					message.date = $root.Date.decode(reader, reader.uint32());
					break;
				}
				case 7: {
					message.popularity = reader.sint32();
					break;
				}
				case 8: {
					if (!(message.genre && message.genre.length)) message.genre = [];
					message.genre.push(reader.string());
					break;
				}
				case 9: {
					if (!(message.cover && message.cover.length)) message.cover = [];
					message.cover.push($root.Image.decode(reader, reader.uint32()));
					break;
				}
				case 10: {
					if (!(message.externalId && message.externalId.length)) message.externalId = [];
					message.externalId.push($root.ExternalId.decode(reader, reader.uint32()));
					break;
				}
				case 11: {
					if (!(message.disc && message.disc.length)) message.disc = [];
					message.disc.push($root.Disc.decode(reader, reader.uint32()));
					break;
				}
				case 12: {
					if (!(message.review && message.review.length)) message.review = [];
					message.review.push(reader.string());
					break;
				}
				case 13: {
					if (!(message.copyright && message.copyright.length)) message.copyright = [];
					message.copyright.push($root.Copyright.decode(reader, reader.uint32()));
					break;
				}
				case 14: {
					if (!(message.restriction && message.restriction.length)) message.restriction = [];
					message.restriction.push($root.Restriction.decode(reader, reader.uint32()));
					break;
				}
				case 15: {
					if (!(message.related && message.related.length)) message.related = [];
					message.related.push($root.Album.decode(reader, reader.uint32()));
					break;
				}
				case 16: {
					if (!(message.salePeriod && message.salePeriod.length)) message.salePeriod = [];
					message.salePeriod.push($root.SalePeriod.decode(reader, reader.uint32()));
					break;
				}
				case 17: {
					message.coverGroup = $root.ImageGroup.decode(reader, reader.uint32());
					break;
				}
				case 18: {
					message.originalTitle = reader.string();
					break;
				}
				case 19: {
					message.versionTitle = reader.string();
					break;
				}
				case 20: {
					message.typeStr = reader.string();
					break;
				}
				case 23: {
					if (!(message.availability && message.availability.length)) message.availability = [];
					message.availability.push($root.Availability.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an Album message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Album
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Album} Album
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Album.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an Album message.
	 * @function verify
	 * @memberof Album
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Album.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.gid != null && message.hasOwnProperty("gid"))
			if (!((message.gid && typeof message.gid.length === "number") || $util.isString(message.gid))) return "gid: buffer expected";
		if (message.name != null && message.hasOwnProperty("name")) if (!$util.isString(message.name)) return "name: string expected";
		if (message.artist != null && message.hasOwnProperty("artist")) {
			if (!Array.isArray(message.artist)) return "artist: array expected";
			for (var i = 0; i < message.artist.length; ++i) {
				var error = $root.Artist.verify(message.artist[i]);
				if (error) return "artist." + error;
			}
		}
		if (message.type != null && message.hasOwnProperty("type"))
			switch (message.type) {
				default:
					return "type: enum value expected";
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
					break;
			}
		if (message.label != null && message.hasOwnProperty("label")) if (!$util.isString(message.label)) return "label: string expected";
		if (message.date != null && message.hasOwnProperty("date")) {
			var error = $root.Date.verify(message.date);
			if (error) return "date." + error;
		}
		if (message.popularity != null && message.hasOwnProperty("popularity"))
			if (!$util.isInteger(message.popularity)) return "popularity: integer expected";
		if (message.genre != null && message.hasOwnProperty("genre")) {
			if (!Array.isArray(message.genre)) return "genre: array expected";
			for (var i = 0; i < message.genre.length; ++i) if (!$util.isString(message.genre[i])) return "genre: string[] expected";
		}
		if (message.cover != null && message.hasOwnProperty("cover")) {
			if (!Array.isArray(message.cover)) return "cover: array expected";
			for (var i = 0; i < message.cover.length; ++i) {
				var error = $root.Image.verify(message.cover[i]);
				if (error) return "cover." + error;
			}
		}
		if (message.externalId != null && message.hasOwnProperty("externalId")) {
			if (!Array.isArray(message.externalId)) return "externalId: array expected";
			for (var i = 0; i < message.externalId.length; ++i) {
				var error = $root.ExternalId.verify(message.externalId[i]);
				if (error) return "externalId." + error;
			}
		}
		if (message.disc != null && message.hasOwnProperty("disc")) {
			if (!Array.isArray(message.disc)) return "disc: array expected";
			for (var i = 0; i < message.disc.length; ++i) {
				var error = $root.Disc.verify(message.disc[i]);
				if (error) return "disc." + error;
			}
		}
		if (message.review != null && message.hasOwnProperty("review")) {
			if (!Array.isArray(message.review)) return "review: array expected";
			for (var i = 0; i < message.review.length; ++i) if (!$util.isString(message.review[i])) return "review: string[] expected";
		}
		if (message.copyright != null && message.hasOwnProperty("copyright")) {
			if (!Array.isArray(message.copyright)) return "copyright: array expected";
			for (var i = 0; i < message.copyright.length; ++i) {
				var error = $root.Copyright.verify(message.copyright[i]);
				if (error) return "copyright." + error;
			}
		}
		if (message.restriction != null && message.hasOwnProperty("restriction")) {
			if (!Array.isArray(message.restriction)) return "restriction: array expected";
			for (var i = 0; i < message.restriction.length; ++i) {
				var error = $root.Restriction.verify(message.restriction[i]);
				if (error) return "restriction." + error;
			}
		}
		if (message.related != null && message.hasOwnProperty("related")) {
			if (!Array.isArray(message.related)) return "related: array expected";
			for (var i = 0; i < message.related.length; ++i) {
				var error = $root.Album.verify(message.related[i]);
				if (error) return "related." + error;
			}
		}
		if (message.salePeriod != null && message.hasOwnProperty("salePeriod")) {
			if (!Array.isArray(message.salePeriod)) return "salePeriod: array expected";
			for (var i = 0; i < message.salePeriod.length; ++i) {
				var error = $root.SalePeriod.verify(message.salePeriod[i]);
				if (error) return "salePeriod." + error;
			}
		}
		if (message.coverGroup != null && message.hasOwnProperty("coverGroup")) {
			var error = $root.ImageGroup.verify(message.coverGroup);
			if (error) return "coverGroup." + error;
		}
		if (message.originalTitle != null && message.hasOwnProperty("originalTitle"))
			if (!$util.isString(message.originalTitle)) return "originalTitle: string expected";
		if (message.versionTitle != null && message.hasOwnProperty("versionTitle"))
			if (!$util.isString(message.versionTitle)) return "versionTitle: string expected";
		if (message.typeStr != null && message.hasOwnProperty("typeStr"))
			if (!$util.isString(message.typeStr)) return "typeStr: string expected";
		if (message.availability != null && message.hasOwnProperty("availability")) {
			if (!Array.isArray(message.availability)) return "availability: array expected";
			for (var i = 0; i < message.availability.length; ++i) {
				var error = $root.Availability.verify(message.availability[i]);
				if (error) return "availability." + error;
			}
		}
		return null;
	};

	/**
	 * Creates an Album message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Album
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Album} Album
	 */
	Album.fromObject = function fromObject(object) {
		if (object instanceof $root.Album) return object;
		var message = new $root.Album();
		if (object.gid != null)
			if (typeof object.gid === "string")
				$util.base64.decode(object.gid, (message.gid = $util.newBuffer($util.base64.length(object.gid))), 0);
			else if (object.gid.length >= 0) message.gid = object.gid;
		if (object.name != null) message.name = String(object.name);
		if (object.artist) {
			if (!Array.isArray(object.artist)) throw TypeError(".Album.artist: array expected");
			message.artist = [];
			for (var i = 0; i < object.artist.length; ++i) {
				if (typeof object.artist[i] !== "object") throw TypeError(".Album.artist: object expected");
				message.artist[i] = $root.Artist.fromObject(object.artist[i]);
			}
		}
		switch (object.type) {
			default:
				if (typeof object.type === "number") {
					message.type = object.type;
					break;
				}
				break;
			case "ALBUM":
			case 1:
				message.type = 1;
				break;
			case "SINGLE":
			case 2:
				message.type = 2;
				break;
			case "COMPILATION":
			case 3:
				message.type = 3;
				break;
			case "EP":
			case 4:
				message.type = 4;
				break;
			case "AUDIOBOOK":
			case 5:
				message.type = 5;
				break;
			case "PODCAST":
			case 6:
				message.type = 6;
				break;
		}
		if (object.label != null) message.label = String(object.label);
		if (object.date != null) {
			if (typeof object.date !== "object") throw TypeError(".Album.date: object expected");
			message.date = $root.Date.fromObject(object.date);
		}
		if (object.popularity != null) message.popularity = object.popularity | 0;
		if (object.genre) {
			if (!Array.isArray(object.genre)) throw TypeError(".Album.genre: array expected");
			message.genre = [];
			for (var i = 0; i < object.genre.length; ++i) message.genre[i] = String(object.genre[i]);
		}
		if (object.cover) {
			if (!Array.isArray(object.cover)) throw TypeError(".Album.cover: array expected");
			message.cover = [];
			for (var i = 0; i < object.cover.length; ++i) {
				if (typeof object.cover[i] !== "object") throw TypeError(".Album.cover: object expected");
				message.cover[i] = $root.Image.fromObject(object.cover[i]);
			}
		}
		if (object.externalId) {
			if (!Array.isArray(object.externalId)) throw TypeError(".Album.externalId: array expected");
			message.externalId = [];
			for (var i = 0; i < object.externalId.length; ++i) {
				if (typeof object.externalId[i] !== "object") throw TypeError(".Album.externalId: object expected");
				message.externalId[i] = $root.ExternalId.fromObject(object.externalId[i]);
			}
		}
		if (object.disc) {
			if (!Array.isArray(object.disc)) throw TypeError(".Album.disc: array expected");
			message.disc = [];
			for (var i = 0; i < object.disc.length; ++i) {
				if (typeof object.disc[i] !== "object") throw TypeError(".Album.disc: object expected");
				message.disc[i] = $root.Disc.fromObject(object.disc[i]);
			}
		}
		if (object.review) {
			if (!Array.isArray(object.review)) throw TypeError(".Album.review: array expected");
			message.review = [];
			for (var i = 0; i < object.review.length; ++i) message.review[i] = String(object.review[i]);
		}
		if (object.copyright) {
			if (!Array.isArray(object.copyright)) throw TypeError(".Album.copyright: array expected");
			message.copyright = [];
			for (var i = 0; i < object.copyright.length; ++i) {
				if (typeof object.copyright[i] !== "object") throw TypeError(".Album.copyright: object expected");
				message.copyright[i] = $root.Copyright.fromObject(object.copyright[i]);
			}
		}
		if (object.restriction) {
			if (!Array.isArray(object.restriction)) throw TypeError(".Album.restriction: array expected");
			message.restriction = [];
			for (var i = 0; i < object.restriction.length; ++i) {
				if (typeof object.restriction[i] !== "object") throw TypeError(".Album.restriction: object expected");
				message.restriction[i] = $root.Restriction.fromObject(object.restriction[i]);
			}
		}
		if (object.related) {
			if (!Array.isArray(object.related)) throw TypeError(".Album.related: array expected");
			message.related = [];
			for (var i = 0; i < object.related.length; ++i) {
				if (typeof object.related[i] !== "object") throw TypeError(".Album.related: object expected");
				message.related[i] = $root.Album.fromObject(object.related[i]);
			}
		}
		if (object.salePeriod) {
			if (!Array.isArray(object.salePeriod)) throw TypeError(".Album.salePeriod: array expected");
			message.salePeriod = [];
			for (var i = 0; i < object.salePeriod.length; ++i) {
				if (typeof object.salePeriod[i] !== "object") throw TypeError(".Album.salePeriod: object expected");
				message.salePeriod[i] = $root.SalePeriod.fromObject(object.salePeriod[i]);
			}
		}
		if (object.coverGroup != null) {
			if (typeof object.coverGroup !== "object") throw TypeError(".Album.coverGroup: object expected");
			message.coverGroup = $root.ImageGroup.fromObject(object.coverGroup);
		}
		if (object.originalTitle != null) message.originalTitle = String(object.originalTitle);
		if (object.versionTitle != null) message.versionTitle = String(object.versionTitle);
		if (object.typeStr != null) message.typeStr = String(object.typeStr);
		if (object.availability) {
			if (!Array.isArray(object.availability)) throw TypeError(".Album.availability: array expected");
			message.availability = [];
			for (var i = 0; i < object.availability.length; ++i) {
				if (typeof object.availability[i] !== "object") throw TypeError(".Album.availability: object expected");
				message.availability[i] = $root.Availability.fromObject(object.availability[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from an Album message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Album
	 * @static
	 * @param {Album} message Album
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Album.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) {
			object.artist = [];
			object.genre = [];
			object.cover = [];
			object.externalId = [];
			object.disc = [];
			object.review = [];
			object.copyright = [];
			object.restriction = [];
			object.related = [];
			object.salePeriod = [];
			object.availability = [];
		}
		if (options.defaults) {
			if (options.bytes === String) object.gid = "";
			else {
				object.gid = [];
				if (options.bytes !== Array) object.gid = $util.newBuffer(object.gid);
			}
			object.name = "";
			object.type = options.enums === String ? "ALBUM" : 1;
			object.label = "";
			object.date = null;
			object.popularity = 0;
			object.coverGroup = null;
			object.originalTitle = "";
			object.versionTitle = "";
			object.typeStr = "";
		}
		if (message.gid != null && message.hasOwnProperty("gid"))
			object.gid =
				options.bytes === String
					? $util.base64.encode(message.gid, 0, message.gid.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.gid)
					: message.gid;
		if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
		if (message.artist && message.artist.length) {
			object.artist = [];
			for (var j = 0; j < message.artist.length; ++j) object.artist[j] = $root.Artist.toObject(message.artist[j], options);
		}
		if (message.type != null && message.hasOwnProperty("type"))
			object.type =
				options.enums === String
					? $root.Album.Type[message.type] === undefined
						? message.type
						: $root.Album.Type[message.type]
					: message.type;
		if (message.label != null && message.hasOwnProperty("label")) object.label = message.label;
		if (message.date != null && message.hasOwnProperty("date")) object.date = $root.Date.toObject(message.date, options);
		if (message.popularity != null && message.hasOwnProperty("popularity")) object.popularity = message.popularity;
		if (message.genre && message.genre.length) {
			object.genre = [];
			for (var j = 0; j < message.genre.length; ++j) object.genre[j] = message.genre[j];
		}
		if (message.cover && message.cover.length) {
			object.cover = [];
			for (var j = 0; j < message.cover.length; ++j) object.cover[j] = $root.Image.toObject(message.cover[j], options);
		}
		if (message.externalId && message.externalId.length) {
			object.externalId = [];
			for (var j = 0; j < message.externalId.length; ++j)
				object.externalId[j] = $root.ExternalId.toObject(message.externalId[j], options);
		}
		if (message.disc && message.disc.length) {
			object.disc = [];
			for (var j = 0; j < message.disc.length; ++j) object.disc[j] = $root.Disc.toObject(message.disc[j], options);
		}
		if (message.review && message.review.length) {
			object.review = [];
			for (var j = 0; j < message.review.length; ++j) object.review[j] = message.review[j];
		}
		if (message.copyright && message.copyright.length) {
			object.copyright = [];
			for (var j = 0; j < message.copyright.length; ++j)
				object.copyright[j] = $root.Copyright.toObject(message.copyright[j], options);
		}
		if (message.restriction && message.restriction.length) {
			object.restriction = [];
			for (var j = 0; j < message.restriction.length; ++j)
				object.restriction[j] = $root.Restriction.toObject(message.restriction[j], options);
		}
		if (message.related && message.related.length) {
			object.related = [];
			for (var j = 0; j < message.related.length; ++j) object.related[j] = $root.Album.toObject(message.related[j], options);
		}
		if (message.salePeriod && message.salePeriod.length) {
			object.salePeriod = [];
			for (var j = 0; j < message.salePeriod.length; ++j)
				object.salePeriod[j] = $root.SalePeriod.toObject(message.salePeriod[j], options);
		}
		if (message.coverGroup != null && message.hasOwnProperty("coverGroup"))
			object.coverGroup = $root.ImageGroup.toObject(message.coverGroup, options);
		if (message.originalTitle != null && message.hasOwnProperty("originalTitle")) object.originalTitle = message.originalTitle;
		if (message.versionTitle != null && message.hasOwnProperty("versionTitle")) object.versionTitle = message.versionTitle;
		if (message.typeStr != null && message.hasOwnProperty("typeStr")) object.typeStr = message.typeStr;
		if (message.availability && message.availability.length) {
			object.availability = [];
			for (var j = 0; j < message.availability.length; ++j)
				object.availability[j] = $root.Availability.toObject(message.availability[j], options);
		}
		return object;
	};

	/**
	 * Converts this Album to JSON.
	 * @function toJSON
	 * @memberof Album
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Album.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Album
	 * @function getTypeUrl
	 * @memberof Album
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Album.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Album";
	};

	/**
	 * Type enum.
	 * @name Album.Type
	 * @enum {number}
	 * @property {number} ALBUM=1 ALBUM value
	 * @property {number} SINGLE=2 SINGLE value
	 * @property {number} COMPILATION=3 COMPILATION value
	 * @property {number} EP=4 EP value
	 * @property {number} AUDIOBOOK=5 AUDIOBOOK value
	 * @property {number} PODCAST=6 PODCAST value
	 */
	Album.Type = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[1] = "ALBUM")] = 1;
		values[(valuesById[2] = "SINGLE")] = 2;
		values[(valuesById[3] = "COMPILATION")] = 3;
		values[(valuesById[4] = "EP")] = 4;
		values[(valuesById[5] = "AUDIOBOOK")] = 5;
		values[(valuesById[6] = "PODCAST")] = 6;
		return values;
	})();

	return Album;
})();

$root.Track = (function () {
	/**
	 * Properties of a Track.
	 * @exports ITrack
	 * @interface ITrack
	 * @property {Uint8Array|null} [gid] Track gid
	 * @property {string|null} [name] Track name
	 * @property {IAlbum|null} [album] Track album
	 * @property {Array.<IArtist>|null} [artist] Track artist
	 * @property {number|null} [number] Track number
	 * @property {number|null} [discNumber] Track discNumber
	 * @property {number|null} [duration] Track duration
	 * @property {number|null} [popularity] Track popularity
	 * @property {boolean|null} [explicit] Track explicit
	 * @property {Array.<IExternalId>|null} [externalId] Track externalId
	 * @property {Array.<IRestriction>|null} [restriction] Track restriction
	 * @property {Array.<IAudioFile>|null} [file] Track file
	 * @property {Array.<ITrack>|null} [alternative] Track alternative
	 * @property {Array.<ISalePeriod>|null} [salePeriod] Track salePeriod
	 * @property {Array.<IAudioFile>|null} [preview] Track preview
	 * @property {Array.<string>|null} [tags] Track tags
	 * @property {number|Long|null} [earliestLiveTimestamp] Track earliestLiveTimestamp
	 * @property {boolean|null} [hasLyrics] Track hasLyrics
	 * @property {Array.<IAvailability>|null} [availability] Track availability
	 * @property {ILicensor|null} [licensor] Track licensor
	 * @property {Array.<string>|null} [languageOfPerformance] Track languageOfPerformance
	 * @property {Array.<IContentRating>|null} [contentRating] Track contentRating
	 * @property {string|null} [originalTitle] Track originalTitle
	 * @property {string|null} [versionTitle] Track versionTitle
	 * @property {Array.<IArtistWithRole>|null} [artistWithRole] Track artistWithRole
	 */

	/**
	 * Constructs a new Track.
	 * @exports Track
	 * @classdesc Represents a Track.
	 * @implements ITrack
	 * @constructor
	 * @param {ITrack=} [properties] Properties to set
	 */
	function Track(properties) {
		this.artist = [];
		this.externalId = [];
		this.restriction = [];
		this.file = [];
		this.alternative = [];
		this.salePeriod = [];
		this.preview = [];
		this.tags = [];
		this.availability = [];
		this.languageOfPerformance = [];
		this.contentRating = [];
		this.artistWithRole = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Track gid.
	 * @member {Uint8Array} gid
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.gid = $util.newBuffer([]);

	/**
	 * Track name.
	 * @member {string} name
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.name = "";

	/**
	 * Track album.
	 * @member {IAlbum|null|undefined} album
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.album = null;

	/**
	 * Track artist.
	 * @member {Array.<IArtist>} artist
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.artist = $util.emptyArray;

	/**
	 * Track number.
	 * @member {number} number
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.number = 0;

	/**
	 * Track discNumber.
	 * @member {number} discNumber
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.discNumber = 0;

	/**
	 * Track duration.
	 * @member {number} duration
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.duration = 0;

	/**
	 * Track popularity.
	 * @member {number} popularity
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.popularity = 0;

	/**
	 * Track explicit.
	 * @member {boolean} explicit
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.explicit = false;

	/**
	 * Track externalId.
	 * @member {Array.<IExternalId>} externalId
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.externalId = $util.emptyArray;

	/**
	 * Track restriction.
	 * @member {Array.<IRestriction>} restriction
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.restriction = $util.emptyArray;

	/**
	 * Track file.
	 * @member {Array.<IAudioFile>} file
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.file = $util.emptyArray;

	/**
	 * Track alternative.
	 * @member {Array.<ITrack>} alternative
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.alternative = $util.emptyArray;

	/**
	 * Track salePeriod.
	 * @member {Array.<ISalePeriod>} salePeriod
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.salePeriod = $util.emptyArray;

	/**
	 * Track preview.
	 * @member {Array.<IAudioFile>} preview
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.preview = $util.emptyArray;

	/**
	 * Track tags.
	 * @member {Array.<string>} tags
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.tags = $util.emptyArray;

	/**
	 * Track earliestLiveTimestamp.
	 * @member {number|Long} earliestLiveTimestamp
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.earliestLiveTimestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

	/**
	 * Track hasLyrics.
	 * @member {boolean} hasLyrics
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.hasLyrics = false;

	/**
	 * Track availability.
	 * @member {Array.<IAvailability>} availability
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.availability = $util.emptyArray;

	/**
	 * Track licensor.
	 * @member {ILicensor|null|undefined} licensor
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.licensor = null;

	/**
	 * Track languageOfPerformance.
	 * @member {Array.<string>} languageOfPerformance
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.languageOfPerformance = $util.emptyArray;

	/**
	 * Track contentRating.
	 * @member {Array.<IContentRating>} contentRating
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.contentRating = $util.emptyArray;

	/**
	 * Track originalTitle.
	 * @member {string} originalTitle
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.originalTitle = "";

	/**
	 * Track versionTitle.
	 * @member {string} versionTitle
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.versionTitle = "";

	/**
	 * Track artistWithRole.
	 * @member {Array.<IArtistWithRole>} artistWithRole
	 * @memberof Track
	 * @instance
	 */
	Track.prototype.artistWithRole = $util.emptyArray;

	/**
	 * Creates a new Track instance using the specified properties.
	 * @function create
	 * @memberof Track
	 * @static
	 * @param {ITrack=} [properties] Properties to set
	 * @returns {Track} Track instance
	 */
	Track.create = function create(properties) {
		return new Track(properties);
	};

	/**
	 * Encodes the specified Track message. Does not implicitly {@link Track.verify|verify} messages.
	 * @function encode
	 * @memberof Track
	 * @static
	 * @param {ITrack} message Track message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Track.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.gid != null && Object.hasOwnProperty.call(message, "gid")) writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.gid);
		if (message.name != null && Object.hasOwnProperty.call(message, "name"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
		if (message.album != null && Object.hasOwnProperty.call(message, "album"))
			$root.Album.encode(message.album, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		if (message.artist != null && message.artist.length)
			for (var i = 0; i < message.artist.length; ++i)
				$root.Artist.encode(message.artist[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
		if (message.number != null && Object.hasOwnProperty.call(message, "number"))
			writer.uint32(/* id 5, wireType 0 =*/ 40).sint32(message.number);
		if (message.discNumber != null && Object.hasOwnProperty.call(message, "discNumber"))
			writer.uint32(/* id 6, wireType 0 =*/ 48).sint32(message.discNumber);
		if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
			writer.uint32(/* id 7, wireType 0 =*/ 56).sint32(message.duration);
		if (message.popularity != null && Object.hasOwnProperty.call(message, "popularity"))
			writer.uint32(/* id 8, wireType 0 =*/ 64).sint32(message.popularity);
		if (message.explicit != null && Object.hasOwnProperty.call(message, "explicit"))
			writer.uint32(/* id 9, wireType 0 =*/ 72).bool(message.explicit);
		if (message.externalId != null && message.externalId.length)
			for (var i = 0; i < message.externalId.length; ++i)
				$root.ExternalId.encode(message.externalId[i], writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
		if (message.restriction != null && message.restriction.length)
			for (var i = 0; i < message.restriction.length; ++i)
				$root.Restriction.encode(message.restriction[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
		if (message.file != null && message.file.length)
			for (var i = 0; i < message.file.length; ++i)
				$root.AudioFile.encode(message.file[i], writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
		if (message.alternative != null && message.alternative.length)
			for (var i = 0; i < message.alternative.length; ++i)
				$root.Track.encode(message.alternative[i], writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
		if (message.salePeriod != null && message.salePeriod.length)
			for (var i = 0; i < message.salePeriod.length; ++i)
				$root.SalePeriod.encode(message.salePeriod[i], writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
		if (message.preview != null && message.preview.length)
			for (var i = 0; i < message.preview.length; ++i)
				$root.AudioFile.encode(message.preview[i], writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
		if (message.tags != null && message.tags.length)
			for (var i = 0; i < message.tags.length; ++i) writer.uint32(/* id 16, wireType 2 =*/ 130).string(message.tags[i]);
		if (message.earliestLiveTimestamp != null && Object.hasOwnProperty.call(message, "earliestLiveTimestamp"))
			writer.uint32(/* id 17, wireType 0 =*/ 136).int64(message.earliestLiveTimestamp);
		if (message.hasLyrics != null && Object.hasOwnProperty.call(message, "hasLyrics"))
			writer.uint32(/* id 18, wireType 0 =*/ 144).bool(message.hasLyrics);
		if (message.availability != null && message.availability.length)
			for (var i = 0; i < message.availability.length; ++i)
				$root.Availability.encode(message.availability[i], writer.uint32(/* id 19, wireType 2 =*/ 154).fork()).ldelim();
		if (message.licensor != null && Object.hasOwnProperty.call(message, "licensor"))
			$root.Licensor.encode(message.licensor, writer.uint32(/* id 21, wireType 2 =*/ 170).fork()).ldelim();
		if (message.languageOfPerformance != null && message.languageOfPerformance.length)
			for (var i = 0; i < message.languageOfPerformance.length; ++i)
				writer.uint32(/* id 22, wireType 2 =*/ 178).string(message.languageOfPerformance[i]);
		if (message.contentRating != null && message.contentRating.length)
			for (var i = 0; i < message.contentRating.length; ++i)
				$root.ContentRating.encode(message.contentRating[i], writer.uint32(/* id 25, wireType 2 =*/ 202).fork()).ldelim();
		if (message.originalTitle != null && Object.hasOwnProperty.call(message, "originalTitle"))
			writer.uint32(/* id 27, wireType 2 =*/ 218).string(message.originalTitle);
		if (message.versionTitle != null && Object.hasOwnProperty.call(message, "versionTitle"))
			writer.uint32(/* id 28, wireType 2 =*/ 226).string(message.versionTitle);
		if (message.artistWithRole != null && message.artistWithRole.length)
			for (var i = 0; i < message.artistWithRole.length; ++i)
				$root.ArtistWithRole.encode(message.artistWithRole[i], writer.uint32(/* id 32, wireType 2 =*/ 258).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified Track message, length delimited. Does not implicitly {@link Track.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Track
	 * @static
	 * @param {ITrack} message Track message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Track.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Track message from the specified reader or buffer.
	 * @function decode
	 * @memberof Track
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Track} Track
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Track.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Track();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.gid = reader.bytes();
					break;
				}
				case 2: {
					message.name = reader.string();
					break;
				}
				case 3: {
					message.album = $root.Album.decode(reader, reader.uint32());
					break;
				}
				case 4: {
					if (!(message.artist && message.artist.length)) message.artist = [];
					message.artist.push($root.Artist.decode(reader, reader.uint32()));
					break;
				}
				case 5: {
					message.number = reader.sint32();
					break;
				}
				case 6: {
					message.discNumber = reader.sint32();
					break;
				}
				case 7: {
					message.duration = reader.sint32();
					break;
				}
				case 8: {
					message.popularity = reader.sint32();
					break;
				}
				case 9: {
					message.explicit = reader.bool();
					break;
				}
				case 10: {
					if (!(message.externalId && message.externalId.length)) message.externalId = [];
					message.externalId.push($root.ExternalId.decode(reader, reader.uint32()));
					break;
				}
				case 11: {
					if (!(message.restriction && message.restriction.length)) message.restriction = [];
					message.restriction.push($root.Restriction.decode(reader, reader.uint32()));
					break;
				}
				case 12: {
					if (!(message.file && message.file.length)) message.file = [];
					message.file.push($root.AudioFile.decode(reader, reader.uint32()));
					break;
				}
				case 13: {
					if (!(message.alternative && message.alternative.length)) message.alternative = [];
					message.alternative.push($root.Track.decode(reader, reader.uint32()));
					break;
				}
				case 14: {
					if (!(message.salePeriod && message.salePeriod.length)) message.salePeriod = [];
					message.salePeriod.push($root.SalePeriod.decode(reader, reader.uint32()));
					break;
				}
				case 15: {
					if (!(message.preview && message.preview.length)) message.preview = [];
					message.preview.push($root.AudioFile.decode(reader, reader.uint32()));
					break;
				}
				case 16: {
					if (!(message.tags && message.tags.length)) message.tags = [];
					message.tags.push(reader.string());
					break;
				}
				case 17: {
					message.earliestLiveTimestamp = reader.int64();
					break;
				}
				case 18: {
					message.hasLyrics = reader.bool();
					break;
				}
				case 19: {
					if (!(message.availability && message.availability.length)) message.availability = [];
					message.availability.push($root.Availability.decode(reader, reader.uint32()));
					break;
				}
				case 21: {
					message.licensor = $root.Licensor.decode(reader, reader.uint32());
					break;
				}
				case 22: {
					if (!(message.languageOfPerformance && message.languageOfPerformance.length)) message.languageOfPerformance = [];
					message.languageOfPerformance.push(reader.string());
					break;
				}
				case 25: {
					if (!(message.contentRating && message.contentRating.length)) message.contentRating = [];
					message.contentRating.push($root.ContentRating.decode(reader, reader.uint32()));
					break;
				}
				case 27: {
					message.originalTitle = reader.string();
					break;
				}
				case 28: {
					message.versionTitle = reader.string();
					break;
				}
				case 32: {
					if (!(message.artistWithRole && message.artistWithRole.length)) message.artistWithRole = [];
					message.artistWithRole.push($root.ArtistWithRole.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Track message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Track
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Track} Track
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Track.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Track message.
	 * @function verify
	 * @memberof Track
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Track.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.gid != null && message.hasOwnProperty("gid"))
			if (!((message.gid && typeof message.gid.length === "number") || $util.isString(message.gid))) return "gid: buffer expected";
		if (message.name != null && message.hasOwnProperty("name")) if (!$util.isString(message.name)) return "name: string expected";
		if (message.album != null && message.hasOwnProperty("album")) {
			var error = $root.Album.verify(message.album);
			if (error) return "album." + error;
		}
		if (message.artist != null && message.hasOwnProperty("artist")) {
			if (!Array.isArray(message.artist)) return "artist: array expected";
			for (var i = 0; i < message.artist.length; ++i) {
				var error = $root.Artist.verify(message.artist[i]);
				if (error) return "artist." + error;
			}
		}
		if (message.number != null && message.hasOwnProperty("number"))
			if (!$util.isInteger(message.number)) return "number: integer expected";
		if (message.discNumber != null && message.hasOwnProperty("discNumber"))
			if (!$util.isInteger(message.discNumber)) return "discNumber: integer expected";
		if (message.duration != null && message.hasOwnProperty("duration"))
			if (!$util.isInteger(message.duration)) return "duration: integer expected";
		if (message.popularity != null && message.hasOwnProperty("popularity"))
			if (!$util.isInteger(message.popularity)) return "popularity: integer expected";
		if (message.explicit != null && message.hasOwnProperty("explicit"))
			if (typeof message.explicit !== "boolean") return "explicit: boolean expected";
		if (message.externalId != null && message.hasOwnProperty("externalId")) {
			if (!Array.isArray(message.externalId)) return "externalId: array expected";
			for (var i = 0; i < message.externalId.length; ++i) {
				var error = $root.ExternalId.verify(message.externalId[i]);
				if (error) return "externalId." + error;
			}
		}
		if (message.restriction != null && message.hasOwnProperty("restriction")) {
			if (!Array.isArray(message.restriction)) return "restriction: array expected";
			for (var i = 0; i < message.restriction.length; ++i) {
				var error = $root.Restriction.verify(message.restriction[i]);
				if (error) return "restriction." + error;
			}
		}
		if (message.file != null && message.hasOwnProperty("file")) {
			if (!Array.isArray(message.file)) return "file: array expected";
			for (var i = 0; i < message.file.length; ++i) {
				var error = $root.AudioFile.verify(message.file[i]);
				if (error) return "file." + error;
			}
		}
		if (message.alternative != null && message.hasOwnProperty("alternative")) {
			if (!Array.isArray(message.alternative)) return "alternative: array expected";
			for (var i = 0; i < message.alternative.length; ++i) {
				var error = $root.Track.verify(message.alternative[i]);
				if (error) return "alternative." + error;
			}
		}
		if (message.salePeriod != null && message.hasOwnProperty("salePeriod")) {
			if (!Array.isArray(message.salePeriod)) return "salePeriod: array expected";
			for (var i = 0; i < message.salePeriod.length; ++i) {
				var error = $root.SalePeriod.verify(message.salePeriod[i]);
				if (error) return "salePeriod." + error;
			}
		}
		if (message.preview != null && message.hasOwnProperty("preview")) {
			if (!Array.isArray(message.preview)) return "preview: array expected";
			for (var i = 0; i < message.preview.length; ++i) {
				var error = $root.AudioFile.verify(message.preview[i]);
				if (error) return "preview." + error;
			}
		}
		if (message.tags != null && message.hasOwnProperty("tags")) {
			if (!Array.isArray(message.tags)) return "tags: array expected";
			for (var i = 0; i < message.tags.length; ++i) if (!$util.isString(message.tags[i])) return "tags: string[] expected";
		}
		if (message.earliestLiveTimestamp != null && message.hasOwnProperty("earliestLiveTimestamp"))
			if (
				!$util.isInteger(message.earliestLiveTimestamp) &&
				!(
					message.earliestLiveTimestamp &&
					$util.isInteger(message.earliestLiveTimestamp.low) &&
					$util.isInteger(message.earliestLiveTimestamp.high)
				)
			)
				return "earliestLiveTimestamp: integer|Long expected";
		if (message.hasLyrics != null && message.hasOwnProperty("hasLyrics"))
			if (typeof message.hasLyrics !== "boolean") return "hasLyrics: boolean expected";
		if (message.availability != null && message.hasOwnProperty("availability")) {
			if (!Array.isArray(message.availability)) return "availability: array expected";
			for (var i = 0; i < message.availability.length; ++i) {
				var error = $root.Availability.verify(message.availability[i]);
				if (error) return "availability." + error;
			}
		}
		if (message.licensor != null && message.hasOwnProperty("licensor")) {
			var error = $root.Licensor.verify(message.licensor);
			if (error) return "licensor." + error;
		}
		if (message.languageOfPerformance != null && message.hasOwnProperty("languageOfPerformance")) {
			if (!Array.isArray(message.languageOfPerformance)) return "languageOfPerformance: array expected";
			for (var i = 0; i < message.languageOfPerformance.length; ++i)
				if (!$util.isString(message.languageOfPerformance[i])) return "languageOfPerformance: string[] expected";
		}
		if (message.contentRating != null && message.hasOwnProperty("contentRating")) {
			if (!Array.isArray(message.contentRating)) return "contentRating: array expected";
			for (var i = 0; i < message.contentRating.length; ++i) {
				var error = $root.ContentRating.verify(message.contentRating[i]);
				if (error) return "contentRating." + error;
			}
		}
		if (message.originalTitle != null && message.hasOwnProperty("originalTitle"))
			if (!$util.isString(message.originalTitle)) return "originalTitle: string expected";
		if (message.versionTitle != null && message.hasOwnProperty("versionTitle"))
			if (!$util.isString(message.versionTitle)) return "versionTitle: string expected";
		if (message.artistWithRole != null && message.hasOwnProperty("artistWithRole")) {
			if (!Array.isArray(message.artistWithRole)) return "artistWithRole: array expected";
			for (var i = 0; i < message.artistWithRole.length; ++i) {
				var error = $root.ArtistWithRole.verify(message.artistWithRole[i]);
				if (error) return "artistWithRole." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a Track message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Track
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Track} Track
	 */
	Track.fromObject = function fromObject(object) {
		if (object instanceof $root.Track) return object;
		var message = new $root.Track();
		if (object.gid != null)
			if (typeof object.gid === "string")
				$util.base64.decode(object.gid, (message.gid = $util.newBuffer($util.base64.length(object.gid))), 0);
			else if (object.gid.length >= 0) message.gid = object.gid;
		if (object.name != null) message.name = String(object.name);
		if (object.album != null) {
			if (typeof object.album !== "object") throw TypeError(".Track.album: object expected");
			message.album = $root.Album.fromObject(object.album);
		}
		if (object.artist) {
			if (!Array.isArray(object.artist)) throw TypeError(".Track.artist: array expected");
			message.artist = [];
			for (var i = 0; i < object.artist.length; ++i) {
				if (typeof object.artist[i] !== "object") throw TypeError(".Track.artist: object expected");
				message.artist[i] = $root.Artist.fromObject(object.artist[i]);
			}
		}
		if (object.number != null) message.number = object.number | 0;
		if (object.discNumber != null) message.discNumber = object.discNumber | 0;
		if (object.duration != null) message.duration = object.duration | 0;
		if (object.popularity != null) message.popularity = object.popularity | 0;
		if (object.explicit != null) message.explicit = Boolean(object.explicit);
		if (object.externalId) {
			if (!Array.isArray(object.externalId)) throw TypeError(".Track.externalId: array expected");
			message.externalId = [];
			for (var i = 0; i < object.externalId.length; ++i) {
				if (typeof object.externalId[i] !== "object") throw TypeError(".Track.externalId: object expected");
				message.externalId[i] = $root.ExternalId.fromObject(object.externalId[i]);
			}
		}
		if (object.restriction) {
			if (!Array.isArray(object.restriction)) throw TypeError(".Track.restriction: array expected");
			message.restriction = [];
			for (var i = 0; i < object.restriction.length; ++i) {
				if (typeof object.restriction[i] !== "object") throw TypeError(".Track.restriction: object expected");
				message.restriction[i] = $root.Restriction.fromObject(object.restriction[i]);
			}
		}
		if (object.file) {
			if (!Array.isArray(object.file)) throw TypeError(".Track.file: array expected");
			message.file = [];
			for (var i = 0; i < object.file.length; ++i) {
				if (typeof object.file[i] !== "object") throw TypeError(".Track.file: object expected");
				message.file[i] = $root.AudioFile.fromObject(object.file[i]);
			}
		}
		if (object.alternative) {
			if (!Array.isArray(object.alternative)) throw TypeError(".Track.alternative: array expected");
			message.alternative = [];
			for (var i = 0; i < object.alternative.length; ++i) {
				if (typeof object.alternative[i] !== "object") throw TypeError(".Track.alternative: object expected");
				message.alternative[i] = $root.Track.fromObject(object.alternative[i]);
			}
		}
		if (object.salePeriod) {
			if (!Array.isArray(object.salePeriod)) throw TypeError(".Track.salePeriod: array expected");
			message.salePeriod = [];
			for (var i = 0; i < object.salePeriod.length; ++i) {
				if (typeof object.salePeriod[i] !== "object") throw TypeError(".Track.salePeriod: object expected");
				message.salePeriod[i] = $root.SalePeriod.fromObject(object.salePeriod[i]);
			}
		}
		if (object.preview) {
			if (!Array.isArray(object.preview)) throw TypeError(".Track.preview: array expected");
			message.preview = [];
			for (var i = 0; i < object.preview.length; ++i) {
				if (typeof object.preview[i] !== "object") throw TypeError(".Track.preview: object expected");
				message.preview[i] = $root.AudioFile.fromObject(object.preview[i]);
			}
		}
		if (object.tags) {
			if (!Array.isArray(object.tags)) throw TypeError(".Track.tags: array expected");
			message.tags = [];
			for (var i = 0; i < object.tags.length; ++i) message.tags[i] = String(object.tags[i]);
		}
		if (object.earliestLiveTimestamp != null)
			if ($util.Long) (message.earliestLiveTimestamp = $util.Long.fromValue(object.earliestLiveTimestamp)).unsigned = false;
			else if (typeof object.earliestLiveTimestamp === "string")
				message.earliestLiveTimestamp = parseInt(object.earliestLiveTimestamp, 10);
			else if (typeof object.earliestLiveTimestamp === "number") message.earliestLiveTimestamp = object.earliestLiveTimestamp;
			else if (typeof object.earliestLiveTimestamp === "object")
				message.earliestLiveTimestamp = new $util.LongBits(
					object.earliestLiveTimestamp.low >>> 0,
					object.earliestLiveTimestamp.high >>> 0,
				).toNumber();
		if (object.hasLyrics != null) message.hasLyrics = Boolean(object.hasLyrics);
		if (object.availability) {
			if (!Array.isArray(object.availability)) throw TypeError(".Track.availability: array expected");
			message.availability = [];
			for (var i = 0; i < object.availability.length; ++i) {
				if (typeof object.availability[i] !== "object") throw TypeError(".Track.availability: object expected");
				message.availability[i] = $root.Availability.fromObject(object.availability[i]);
			}
		}
		if (object.licensor != null) {
			if (typeof object.licensor !== "object") throw TypeError(".Track.licensor: object expected");
			message.licensor = $root.Licensor.fromObject(object.licensor);
		}
		if (object.languageOfPerformance) {
			if (!Array.isArray(object.languageOfPerformance)) throw TypeError(".Track.languageOfPerformance: array expected");
			message.languageOfPerformance = [];
			for (var i = 0; i < object.languageOfPerformance.length; ++i)
				message.languageOfPerformance[i] = String(object.languageOfPerformance[i]);
		}
		if (object.contentRating) {
			if (!Array.isArray(object.contentRating)) throw TypeError(".Track.contentRating: array expected");
			message.contentRating = [];
			for (var i = 0; i < object.contentRating.length; ++i) {
				if (typeof object.contentRating[i] !== "object") throw TypeError(".Track.contentRating: object expected");
				message.contentRating[i] = $root.ContentRating.fromObject(object.contentRating[i]);
			}
		}
		if (object.originalTitle != null) message.originalTitle = String(object.originalTitle);
		if (object.versionTitle != null) message.versionTitle = String(object.versionTitle);
		if (object.artistWithRole) {
			if (!Array.isArray(object.artistWithRole)) throw TypeError(".Track.artistWithRole: array expected");
			message.artistWithRole = [];
			for (var i = 0; i < object.artistWithRole.length; ++i) {
				if (typeof object.artistWithRole[i] !== "object") throw TypeError(".Track.artistWithRole: object expected");
				message.artistWithRole[i] = $root.ArtistWithRole.fromObject(object.artistWithRole[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a Track message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Track
	 * @static
	 * @param {Track} message Track
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Track.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) {
			object.artist = [];
			object.externalId = [];
			object.restriction = [];
			object.file = [];
			object.alternative = [];
			object.salePeriod = [];
			object.preview = [];
			object.tags = [];
			object.availability = [];
			object.languageOfPerformance = [];
			object.contentRating = [];
			object.artistWithRole = [];
		}
		if (options.defaults) {
			if (options.bytes === String) object.gid = "";
			else {
				object.gid = [];
				if (options.bytes !== Array) object.gid = $util.newBuffer(object.gid);
			}
			object.name = "";
			object.album = null;
			object.number = 0;
			object.discNumber = 0;
			object.duration = 0;
			object.popularity = 0;
			object.explicit = false;
			if ($util.Long) {
				var long = new $util.Long(0, 0, false);
				object.earliestLiveTimestamp =
					options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
			} else object.earliestLiveTimestamp = options.longs === String ? "0" : 0;
			object.hasLyrics = false;
			object.licensor = null;
			object.originalTitle = "";
			object.versionTitle = "";
		}
		if (message.gid != null && message.hasOwnProperty("gid"))
			object.gid =
				options.bytes === String
					? $util.base64.encode(message.gid, 0, message.gid.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.gid)
					: message.gid;
		if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
		if (message.album != null && message.hasOwnProperty("album")) object.album = $root.Album.toObject(message.album, options);
		if (message.artist && message.artist.length) {
			object.artist = [];
			for (var j = 0; j < message.artist.length; ++j) object.artist[j] = $root.Artist.toObject(message.artist[j], options);
		}
		if (message.number != null && message.hasOwnProperty("number")) object.number = message.number;
		if (message.discNumber != null && message.hasOwnProperty("discNumber")) object.discNumber = message.discNumber;
		if (message.duration != null && message.hasOwnProperty("duration")) object.duration = message.duration;
		if (message.popularity != null && message.hasOwnProperty("popularity")) object.popularity = message.popularity;
		if (message.explicit != null && message.hasOwnProperty("explicit")) object.explicit = message.explicit;
		if (message.externalId && message.externalId.length) {
			object.externalId = [];
			for (var j = 0; j < message.externalId.length; ++j)
				object.externalId[j] = $root.ExternalId.toObject(message.externalId[j], options);
		}
		if (message.restriction && message.restriction.length) {
			object.restriction = [];
			for (var j = 0; j < message.restriction.length; ++j)
				object.restriction[j] = $root.Restriction.toObject(message.restriction[j], options);
		}
		if (message.file && message.file.length) {
			object.file = [];
			for (var j = 0; j < message.file.length; ++j) object.file[j] = $root.AudioFile.toObject(message.file[j], options);
		}
		if (message.alternative && message.alternative.length) {
			object.alternative = [];
			for (var j = 0; j < message.alternative.length; ++j)
				object.alternative[j] = $root.Track.toObject(message.alternative[j], options);
		}
		if (message.salePeriod && message.salePeriod.length) {
			object.salePeriod = [];
			for (var j = 0; j < message.salePeriod.length; ++j)
				object.salePeriod[j] = $root.SalePeriod.toObject(message.salePeriod[j], options);
		}
		if (message.preview && message.preview.length) {
			object.preview = [];
			for (var j = 0; j < message.preview.length; ++j) object.preview[j] = $root.AudioFile.toObject(message.preview[j], options);
		}
		if (message.tags && message.tags.length) {
			object.tags = [];
			for (var j = 0; j < message.tags.length; ++j) object.tags[j] = message.tags[j];
		}
		if (message.earliestLiveTimestamp != null && message.hasOwnProperty("earliestLiveTimestamp"))
			if (typeof message.earliestLiveTimestamp === "number")
				object.earliestLiveTimestamp =
					options.longs === String ? String(message.earliestLiveTimestamp) : message.earliestLiveTimestamp;
			else
				object.earliestLiveTimestamp =
					options.longs === String
						? $util.Long.prototype.toString.call(message.earliestLiveTimestamp)
						: options.longs === Number
						? new $util.LongBits(message.earliestLiveTimestamp.low >>> 0, message.earliestLiveTimestamp.high >>> 0).toNumber()
						: message.earliestLiveTimestamp;
		if (message.hasLyrics != null && message.hasOwnProperty("hasLyrics")) object.hasLyrics = message.hasLyrics;
		if (message.availability && message.availability.length) {
			object.availability = [];
			for (var j = 0; j < message.availability.length; ++j)
				object.availability[j] = $root.Availability.toObject(message.availability[j], options);
		}
		if (message.licensor != null && message.hasOwnProperty("licensor"))
			object.licensor = $root.Licensor.toObject(message.licensor, options);
		if (message.languageOfPerformance && message.languageOfPerformance.length) {
			object.languageOfPerformance = [];
			for (var j = 0; j < message.languageOfPerformance.length; ++j)
				object.languageOfPerformance[j] = message.languageOfPerformance[j];
		}
		if (message.contentRating && message.contentRating.length) {
			object.contentRating = [];
			for (var j = 0; j < message.contentRating.length; ++j)
				object.contentRating[j] = $root.ContentRating.toObject(message.contentRating[j], options);
		}
		if (message.originalTitle != null && message.hasOwnProperty("originalTitle")) object.originalTitle = message.originalTitle;
		if (message.versionTitle != null && message.hasOwnProperty("versionTitle")) object.versionTitle = message.versionTitle;
		if (message.artistWithRole && message.artistWithRole.length) {
			object.artistWithRole = [];
			for (var j = 0; j < message.artistWithRole.length; ++j)
				object.artistWithRole[j] = $root.ArtistWithRole.toObject(message.artistWithRole[j], options);
		}
		return object;
	};

	/**
	 * Converts this Track to JSON.
	 * @function toJSON
	 * @memberof Track
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Track.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Track
	 * @function getTypeUrl
	 * @memberof Track
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Track.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Track";
	};

	return Track;
})();

$root.ArtistWithRole = (function () {
	/**
	 * Properties of an ArtistWithRole.
	 * @exports IArtistWithRole
	 * @interface IArtistWithRole
	 * @property {Uint8Array|null} [artistGid] ArtistWithRole artistGid
	 * @property {string|null} [artistName] ArtistWithRole artistName
	 * @property {ArtistWithRole.ArtistRole|null} [role] ArtistWithRole role
	 */

	/**
	 * Constructs a new ArtistWithRole.
	 * @exports ArtistWithRole
	 * @classdesc Represents an ArtistWithRole.
	 * @implements IArtistWithRole
	 * @constructor
	 * @param {IArtistWithRole=} [properties] Properties to set
	 */
	function ArtistWithRole(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ArtistWithRole artistGid.
	 * @member {Uint8Array} artistGid
	 * @memberof ArtistWithRole
	 * @instance
	 */
	ArtistWithRole.prototype.artistGid = $util.newBuffer([]);

	/**
	 * ArtistWithRole artistName.
	 * @member {string} artistName
	 * @memberof ArtistWithRole
	 * @instance
	 */
	ArtistWithRole.prototype.artistName = "";

	/**
	 * ArtistWithRole role.
	 * @member {ArtistWithRole.ArtistRole} role
	 * @memberof ArtistWithRole
	 * @instance
	 */
	ArtistWithRole.prototype.role = 0;

	/**
	 * Creates a new ArtistWithRole instance using the specified properties.
	 * @function create
	 * @memberof ArtistWithRole
	 * @static
	 * @param {IArtistWithRole=} [properties] Properties to set
	 * @returns {ArtistWithRole} ArtistWithRole instance
	 */
	ArtistWithRole.create = function create(properties) {
		return new ArtistWithRole(properties);
	};

	/**
	 * Encodes the specified ArtistWithRole message. Does not implicitly {@link ArtistWithRole.verify|verify} messages.
	 * @function encode
	 * @memberof ArtistWithRole
	 * @static
	 * @param {IArtistWithRole} message ArtistWithRole message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ArtistWithRole.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.artistGid != null && Object.hasOwnProperty.call(message, "artistGid"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.artistGid);
		if (message.artistName != null && Object.hasOwnProperty.call(message, "artistName"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.artistName);
		if (message.role != null && Object.hasOwnProperty.call(message, "role"))
			writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.role);
		return writer;
	};

	/**
	 * Encodes the specified ArtistWithRole message, length delimited. Does not implicitly {@link ArtistWithRole.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ArtistWithRole
	 * @static
	 * @param {IArtistWithRole} message ArtistWithRole message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ArtistWithRole.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an ArtistWithRole message from the specified reader or buffer.
	 * @function decode
	 * @memberof ArtistWithRole
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ArtistWithRole} ArtistWithRole
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ArtistWithRole.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ArtistWithRole();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.artistGid = reader.bytes();
					break;
				}
				case 2: {
					message.artistName = reader.string();
					break;
				}
				case 3: {
					message.role = reader.int32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an ArtistWithRole message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ArtistWithRole
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ArtistWithRole} ArtistWithRole
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ArtistWithRole.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an ArtistWithRole message.
	 * @function verify
	 * @memberof ArtistWithRole
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ArtistWithRole.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.artistGid != null && message.hasOwnProperty("artistGid"))
			if (!((message.artistGid && typeof message.artistGid.length === "number") || $util.isString(message.artistGid)))
				return "artistGid: buffer expected";
		if (message.artistName != null && message.hasOwnProperty("artistName"))
			if (!$util.isString(message.artistName)) return "artistName: string expected";
		if (message.role != null && message.hasOwnProperty("role"))
			switch (message.role) {
				default:
					return "role: enum value expected";
				case 0:
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
					break;
			}
		return null;
	};

	/**
	 * Creates an ArtistWithRole message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ArtistWithRole
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ArtistWithRole} ArtistWithRole
	 */
	ArtistWithRole.fromObject = function fromObject(object) {
		if (object instanceof $root.ArtistWithRole) return object;
		var message = new $root.ArtistWithRole();
		if (object.artistGid != null)
			if (typeof object.artistGid === "string")
				$util.base64.decode(object.artistGid, (message.artistGid = $util.newBuffer($util.base64.length(object.artistGid))), 0);
			else if (object.artistGid.length >= 0) message.artistGid = object.artistGid;
		if (object.artistName != null) message.artistName = String(object.artistName);
		switch (object.role) {
			default:
				if (typeof object.role === "number") {
					message.role = object.role;
					break;
				}
				break;
			case "ARTIST_ROLE_UNKNOWN":
			case 0:
				message.role = 0;
				break;
			case "ARTIST_ROLE_MAIN_ARTIST":
			case 1:
				message.role = 1;
				break;
			case "ARTIST_ROLE_FEATURED_ARTIST":
			case 2:
				message.role = 2;
				break;
			case "ARTIST_ROLE_REMIXER":
			case 3:
				message.role = 3;
				break;
			case "ARTIST_ROLE_ACTOR":
			case 4:
				message.role = 4;
				break;
			case "ARTIST_ROLE_COMPOSER":
			case 5:
				message.role = 5;
				break;
			case "ARTIST_ROLE_CONDUCTOR":
			case 6:
				message.role = 6;
				break;
			case "ARTIST_ROLE_ORCHESTRA":
			case 7:
				message.role = 7;
				break;
		}
		return message;
	};

	/**
	 * Creates a plain object from an ArtistWithRole message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ArtistWithRole
	 * @static
	 * @param {ArtistWithRole} message ArtistWithRole
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ArtistWithRole.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			if (options.bytes === String) object.artistGid = "";
			else {
				object.artistGid = [];
				if (options.bytes !== Array) object.artistGid = $util.newBuffer(object.artistGid);
			}
			object.artistName = "";
			object.role = options.enums === String ? "ARTIST_ROLE_UNKNOWN" : 0;
		}
		if (message.artistGid != null && message.hasOwnProperty("artistGid"))
			object.artistGid =
				options.bytes === String
					? $util.base64.encode(message.artistGid, 0, message.artistGid.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.artistGid)
					: message.artistGid;
		if (message.artistName != null && message.hasOwnProperty("artistName")) object.artistName = message.artistName;
		if (message.role != null && message.hasOwnProperty("role"))
			object.role =
				options.enums === String
					? $root.ArtistWithRole.ArtistRole[message.role] === undefined
						? message.role
						: $root.ArtistWithRole.ArtistRole[message.role]
					: message.role;
		return object;
	};

	/**
	 * Converts this ArtistWithRole to JSON.
	 * @function toJSON
	 * @memberof ArtistWithRole
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ArtistWithRole.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ArtistWithRole
	 * @function getTypeUrl
	 * @memberof ArtistWithRole
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ArtistWithRole.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ArtistWithRole";
	};

	/**
	 * ArtistRole enum.
	 * @name ArtistWithRole.ArtistRole
	 * @enum {number}
	 * @property {number} ARTIST_ROLE_UNKNOWN=0 ARTIST_ROLE_UNKNOWN value
	 * @property {number} ARTIST_ROLE_MAIN_ARTIST=1 ARTIST_ROLE_MAIN_ARTIST value
	 * @property {number} ARTIST_ROLE_FEATURED_ARTIST=2 ARTIST_ROLE_FEATURED_ARTIST value
	 * @property {number} ARTIST_ROLE_REMIXER=3 ARTIST_ROLE_REMIXER value
	 * @property {number} ARTIST_ROLE_ACTOR=4 ARTIST_ROLE_ACTOR value
	 * @property {number} ARTIST_ROLE_COMPOSER=5 ARTIST_ROLE_COMPOSER value
	 * @property {number} ARTIST_ROLE_CONDUCTOR=6 ARTIST_ROLE_CONDUCTOR value
	 * @property {number} ARTIST_ROLE_ORCHESTRA=7 ARTIST_ROLE_ORCHESTRA value
	 */
	ArtistWithRole.ArtistRole = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "ARTIST_ROLE_UNKNOWN")] = 0;
		values[(valuesById[1] = "ARTIST_ROLE_MAIN_ARTIST")] = 1;
		values[(valuesById[2] = "ARTIST_ROLE_FEATURED_ARTIST")] = 2;
		values[(valuesById[3] = "ARTIST_ROLE_REMIXER")] = 3;
		values[(valuesById[4] = "ARTIST_ROLE_ACTOR")] = 4;
		values[(valuesById[5] = "ARTIST_ROLE_COMPOSER")] = 5;
		values[(valuesById[6] = "ARTIST_ROLE_CONDUCTOR")] = 6;
		values[(valuesById[7] = "ARTIST_ROLE_ORCHESTRA")] = 7;
		return values;
	})();

	return ArtistWithRole;
})();

$root.Show = (function () {
	/**
	 * Properties of a Show.
	 * @exports IShow
	 * @interface IShow
	 * @property {Uint8Array|null} [gid] Show gid
	 * @property {string|null} [name] Show name
	 * @property {string|null} [description] Show description
	 * @property {number|null} [deprecatedPopularity] Show deprecatedPopularity
	 * @property {string|null} [publisher] Show publisher
	 * @property {string|null} [language] Show language
	 * @property {boolean|null} [explicit] Show explicit
	 * @property {IImageGroup|null} [coverImage] Show coverImage
	 * @property {Array.<IEpisode>|null} [episode] Show episode
	 * @property {Array.<ICopyright>|null} [copyright] Show copyright
	 * @property {Array.<IRestriction>|null} [restriction] Show restriction
	 * @property {Array.<string>|null} [keyword] Show keyword
	 * @property {Show.MediaType|null} [mediaType] Show mediaType
	 * @property {Show.ConsumptionOrder|null} [consumptionOrder] Show consumptionOrder
	 * @property {Array.<IAvailability>|null} [availability] Show availability
	 * @property {string|null} [trailerUri] Show trailerUri
	 * @property {boolean|null} [musicAndTalk] Show musicAndTalk
	 * @property {boolean|null} [isAudiobook] Show isAudiobook
	 */

	/**
	 * Constructs a new Show.
	 * @exports Show
	 * @classdesc Represents a Show.
	 * @implements IShow
	 * @constructor
	 * @param {IShow=} [properties] Properties to set
	 */
	function Show(properties) {
		this.episode = [];
		this.copyright = [];
		this.restriction = [];
		this.keyword = [];
		this.availability = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Show gid.
	 * @member {Uint8Array} gid
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.gid = $util.newBuffer([]);

	/**
	 * Show name.
	 * @member {string} name
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.name = "";

	/**
	 * Show description.
	 * @member {string} description
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.description = "";

	/**
	 * Show deprecatedPopularity.
	 * @member {number} deprecatedPopularity
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.deprecatedPopularity = 0;

	/**
	 * Show publisher.
	 * @member {string} publisher
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.publisher = "";

	/**
	 * Show language.
	 * @member {string} language
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.language = "";

	/**
	 * Show explicit.
	 * @member {boolean} explicit
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.explicit = false;

	/**
	 * Show coverImage.
	 * @member {IImageGroup|null|undefined} coverImage
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.coverImage = null;

	/**
	 * Show episode.
	 * @member {Array.<IEpisode>} episode
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.episode = $util.emptyArray;

	/**
	 * Show copyright.
	 * @member {Array.<ICopyright>} copyright
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.copyright = $util.emptyArray;

	/**
	 * Show restriction.
	 * @member {Array.<IRestriction>} restriction
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.restriction = $util.emptyArray;

	/**
	 * Show keyword.
	 * @member {Array.<string>} keyword
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.keyword = $util.emptyArray;

	/**
	 * Show mediaType.
	 * @member {Show.MediaType} mediaType
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.mediaType = 0;

	/**
	 * Show consumptionOrder.
	 * @member {Show.ConsumptionOrder} consumptionOrder
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.consumptionOrder = 1;

	/**
	 * Show availability.
	 * @member {Array.<IAvailability>} availability
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.availability = $util.emptyArray;

	/**
	 * Show trailerUri.
	 * @member {string} trailerUri
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.trailerUri = "";

	/**
	 * Show musicAndTalk.
	 * @member {boolean} musicAndTalk
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.musicAndTalk = false;

	/**
	 * Show isAudiobook.
	 * @member {boolean} isAudiobook
	 * @memberof Show
	 * @instance
	 */
	Show.prototype.isAudiobook = false;

	/**
	 * Creates a new Show instance using the specified properties.
	 * @function create
	 * @memberof Show
	 * @static
	 * @param {IShow=} [properties] Properties to set
	 * @returns {Show} Show instance
	 */
	Show.create = function create(properties) {
		return new Show(properties);
	};

	/**
	 * Encodes the specified Show message. Does not implicitly {@link Show.verify|verify} messages.
	 * @function encode
	 * @memberof Show
	 * @static
	 * @param {IShow} message Show message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Show.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.gid != null && Object.hasOwnProperty.call(message, "gid")) writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.gid);
		if (message.name != null && Object.hasOwnProperty.call(message, "name"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
		if (message.description != null && Object.hasOwnProperty.call(message, "description"))
			writer.uint32(/* id 64, wireType 2 =*/ 514).string(message.description);
		if (message.deprecatedPopularity != null && Object.hasOwnProperty.call(message, "deprecatedPopularity"))
			writer.uint32(/* id 65, wireType 0 =*/ 520).sint32(message.deprecatedPopularity);
		if (message.publisher != null && Object.hasOwnProperty.call(message, "publisher"))
			writer.uint32(/* id 66, wireType 2 =*/ 530).string(message.publisher);
		if (message.language != null && Object.hasOwnProperty.call(message, "language"))
			writer.uint32(/* id 67, wireType 2 =*/ 538).string(message.language);
		if (message.explicit != null && Object.hasOwnProperty.call(message, "explicit"))
			writer.uint32(/* id 68, wireType 0 =*/ 544).bool(message.explicit);
		if (message.coverImage != null && Object.hasOwnProperty.call(message, "coverImage"))
			$root.ImageGroup.encode(message.coverImage, writer.uint32(/* id 69, wireType 2 =*/ 554).fork()).ldelim();
		if (message.episode != null && message.episode.length)
			for (var i = 0; i < message.episode.length; ++i)
				$root.Episode.encode(message.episode[i], writer.uint32(/* id 70, wireType 2 =*/ 562).fork()).ldelim();
		if (message.copyright != null && message.copyright.length)
			for (var i = 0; i < message.copyright.length; ++i)
				$root.Copyright.encode(message.copyright[i], writer.uint32(/* id 71, wireType 2 =*/ 570).fork()).ldelim();
		if (message.restriction != null && message.restriction.length)
			for (var i = 0; i < message.restriction.length; ++i)
				$root.Restriction.encode(message.restriction[i], writer.uint32(/* id 72, wireType 2 =*/ 578).fork()).ldelim();
		if (message.keyword != null && message.keyword.length)
			for (var i = 0; i < message.keyword.length; ++i) writer.uint32(/* id 73, wireType 2 =*/ 586).string(message.keyword[i]);
		if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
			writer.uint32(/* id 74, wireType 0 =*/ 592).int32(message.mediaType);
		if (message.consumptionOrder != null && Object.hasOwnProperty.call(message, "consumptionOrder"))
			writer.uint32(/* id 75, wireType 0 =*/ 600).int32(message.consumptionOrder);
		if (message.availability != null && message.availability.length)
			for (var i = 0; i < message.availability.length; ++i)
				$root.Availability.encode(message.availability[i], writer.uint32(/* id 78, wireType 2 =*/ 626).fork()).ldelim();
		if (message.trailerUri != null && Object.hasOwnProperty.call(message, "trailerUri"))
			writer.uint32(/* id 83, wireType 2 =*/ 666).string(message.trailerUri);
		if (message.musicAndTalk != null && Object.hasOwnProperty.call(message, "musicAndTalk"))
			writer.uint32(/* id 85, wireType 0 =*/ 680).bool(message.musicAndTalk);
		if (message.isAudiobook != null && Object.hasOwnProperty.call(message, "isAudiobook"))
			writer.uint32(/* id 89, wireType 0 =*/ 712).bool(message.isAudiobook);
		return writer;
	};

	/**
	 * Encodes the specified Show message, length delimited. Does not implicitly {@link Show.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Show
	 * @static
	 * @param {IShow} message Show message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Show.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Show message from the specified reader or buffer.
	 * @function decode
	 * @memberof Show
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Show} Show
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Show.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Show();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.gid = reader.bytes();
					break;
				}
				case 2: {
					message.name = reader.string();
					break;
				}
				case 64: {
					message.description = reader.string();
					break;
				}
				case 65: {
					message.deprecatedPopularity = reader.sint32();
					break;
				}
				case 66: {
					message.publisher = reader.string();
					break;
				}
				case 67: {
					message.language = reader.string();
					break;
				}
				case 68: {
					message.explicit = reader.bool();
					break;
				}
				case 69: {
					message.coverImage = $root.ImageGroup.decode(reader, reader.uint32());
					break;
				}
				case 70: {
					if (!(message.episode && message.episode.length)) message.episode = [];
					message.episode.push($root.Episode.decode(reader, reader.uint32()));
					break;
				}
				case 71: {
					if (!(message.copyright && message.copyright.length)) message.copyright = [];
					message.copyright.push($root.Copyright.decode(reader, reader.uint32()));
					break;
				}
				case 72: {
					if (!(message.restriction && message.restriction.length)) message.restriction = [];
					message.restriction.push($root.Restriction.decode(reader, reader.uint32()));
					break;
				}
				case 73: {
					if (!(message.keyword && message.keyword.length)) message.keyword = [];
					message.keyword.push(reader.string());
					break;
				}
				case 74: {
					message.mediaType = reader.int32();
					break;
				}
				case 75: {
					message.consumptionOrder = reader.int32();
					break;
				}
				case 78: {
					if (!(message.availability && message.availability.length)) message.availability = [];
					message.availability.push($root.Availability.decode(reader, reader.uint32()));
					break;
				}
				case 83: {
					message.trailerUri = reader.string();
					break;
				}
				case 85: {
					message.musicAndTalk = reader.bool();
					break;
				}
				case 89: {
					message.isAudiobook = reader.bool();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Show message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Show
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Show} Show
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Show.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Show message.
	 * @function verify
	 * @memberof Show
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Show.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.gid != null && message.hasOwnProperty("gid"))
			if (!((message.gid && typeof message.gid.length === "number") || $util.isString(message.gid))) return "gid: buffer expected";
		if (message.name != null && message.hasOwnProperty("name")) if (!$util.isString(message.name)) return "name: string expected";
		if (message.description != null && message.hasOwnProperty("description"))
			if (!$util.isString(message.description)) return "description: string expected";
		if (message.deprecatedPopularity != null && message.hasOwnProperty("deprecatedPopularity"))
			if (!$util.isInteger(message.deprecatedPopularity)) return "deprecatedPopularity: integer expected";
		if (message.publisher != null && message.hasOwnProperty("publisher"))
			if (!$util.isString(message.publisher)) return "publisher: string expected";
		if (message.language != null && message.hasOwnProperty("language"))
			if (!$util.isString(message.language)) return "language: string expected";
		if (message.explicit != null && message.hasOwnProperty("explicit"))
			if (typeof message.explicit !== "boolean") return "explicit: boolean expected";
		if (message.coverImage != null && message.hasOwnProperty("coverImage")) {
			var error = $root.ImageGroup.verify(message.coverImage);
			if (error) return "coverImage." + error;
		}
		if (message.episode != null && message.hasOwnProperty("episode")) {
			if (!Array.isArray(message.episode)) return "episode: array expected";
			for (var i = 0; i < message.episode.length; ++i) {
				var error = $root.Episode.verify(message.episode[i]);
				if (error) return "episode." + error;
			}
		}
		if (message.copyright != null && message.hasOwnProperty("copyright")) {
			if (!Array.isArray(message.copyright)) return "copyright: array expected";
			for (var i = 0; i < message.copyright.length; ++i) {
				var error = $root.Copyright.verify(message.copyright[i]);
				if (error) return "copyright." + error;
			}
		}
		if (message.restriction != null && message.hasOwnProperty("restriction")) {
			if (!Array.isArray(message.restriction)) return "restriction: array expected";
			for (var i = 0; i < message.restriction.length; ++i) {
				var error = $root.Restriction.verify(message.restriction[i]);
				if (error) return "restriction." + error;
			}
		}
		if (message.keyword != null && message.hasOwnProperty("keyword")) {
			if (!Array.isArray(message.keyword)) return "keyword: array expected";
			for (var i = 0; i < message.keyword.length; ++i) if (!$util.isString(message.keyword[i])) return "keyword: string[] expected";
		}
		if (message.mediaType != null && message.hasOwnProperty("mediaType"))
			switch (message.mediaType) {
				default:
					return "mediaType: enum value expected";
				case 0:
				case 1:
				case 2:
					break;
			}
		if (message.consumptionOrder != null && message.hasOwnProperty("consumptionOrder"))
			switch (message.consumptionOrder) {
				default:
					return "consumptionOrder: enum value expected";
				case 1:
				case 2:
				case 3:
					break;
			}
		if (message.availability != null && message.hasOwnProperty("availability")) {
			if (!Array.isArray(message.availability)) return "availability: array expected";
			for (var i = 0; i < message.availability.length; ++i) {
				var error = $root.Availability.verify(message.availability[i]);
				if (error) return "availability." + error;
			}
		}
		if (message.trailerUri != null && message.hasOwnProperty("trailerUri"))
			if (!$util.isString(message.trailerUri)) return "trailerUri: string expected";
		if (message.musicAndTalk != null && message.hasOwnProperty("musicAndTalk"))
			if (typeof message.musicAndTalk !== "boolean") return "musicAndTalk: boolean expected";
		if (message.isAudiobook != null && message.hasOwnProperty("isAudiobook"))
			if (typeof message.isAudiobook !== "boolean") return "isAudiobook: boolean expected";
		return null;
	};

	/**
	 * Creates a Show message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Show
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Show} Show
	 */
	Show.fromObject = function fromObject(object) {
		if (object instanceof $root.Show) return object;
		var message = new $root.Show();
		if (object.gid != null)
			if (typeof object.gid === "string")
				$util.base64.decode(object.gid, (message.gid = $util.newBuffer($util.base64.length(object.gid))), 0);
			else if (object.gid.length >= 0) message.gid = object.gid;
		if (object.name != null) message.name = String(object.name);
		if (object.description != null) message.description = String(object.description);
		if (object.deprecatedPopularity != null) message.deprecatedPopularity = object.deprecatedPopularity | 0;
		if (object.publisher != null) message.publisher = String(object.publisher);
		if (object.language != null) message.language = String(object.language);
		if (object.explicit != null) message.explicit = Boolean(object.explicit);
		if (object.coverImage != null) {
			if (typeof object.coverImage !== "object") throw TypeError(".Show.coverImage: object expected");
			message.coverImage = $root.ImageGroup.fromObject(object.coverImage);
		}
		if (object.episode) {
			if (!Array.isArray(object.episode)) throw TypeError(".Show.episode: array expected");
			message.episode = [];
			for (var i = 0; i < object.episode.length; ++i) {
				if (typeof object.episode[i] !== "object") throw TypeError(".Show.episode: object expected");
				message.episode[i] = $root.Episode.fromObject(object.episode[i]);
			}
		}
		if (object.copyright) {
			if (!Array.isArray(object.copyright)) throw TypeError(".Show.copyright: array expected");
			message.copyright = [];
			for (var i = 0; i < object.copyright.length; ++i) {
				if (typeof object.copyright[i] !== "object") throw TypeError(".Show.copyright: object expected");
				message.copyright[i] = $root.Copyright.fromObject(object.copyright[i]);
			}
		}
		if (object.restriction) {
			if (!Array.isArray(object.restriction)) throw TypeError(".Show.restriction: array expected");
			message.restriction = [];
			for (var i = 0; i < object.restriction.length; ++i) {
				if (typeof object.restriction[i] !== "object") throw TypeError(".Show.restriction: object expected");
				message.restriction[i] = $root.Restriction.fromObject(object.restriction[i]);
			}
		}
		if (object.keyword) {
			if (!Array.isArray(object.keyword)) throw TypeError(".Show.keyword: array expected");
			message.keyword = [];
			for (var i = 0; i < object.keyword.length; ++i) message.keyword[i] = String(object.keyword[i]);
		}
		switch (object.mediaType) {
			default:
				if (typeof object.mediaType === "number") {
					message.mediaType = object.mediaType;
					break;
				}
				break;
			case "MIXED":
			case 0:
				message.mediaType = 0;
				break;
			case "AUDIO":
			case 1:
				message.mediaType = 1;
				break;
			case "VIDEO":
			case 2:
				message.mediaType = 2;
				break;
		}
		switch (object.consumptionOrder) {
			default:
				if (typeof object.consumptionOrder === "number") {
					message.consumptionOrder = object.consumptionOrder;
					break;
				}
				break;
			case "SEQUENTIAL":
			case 1:
				message.consumptionOrder = 1;
				break;
			case "EPISODIC":
			case 2:
				message.consumptionOrder = 2;
				break;
			case "RECENT":
			case 3:
				message.consumptionOrder = 3;
				break;
		}
		if (object.availability) {
			if (!Array.isArray(object.availability)) throw TypeError(".Show.availability: array expected");
			message.availability = [];
			for (var i = 0; i < object.availability.length; ++i) {
				if (typeof object.availability[i] !== "object") throw TypeError(".Show.availability: object expected");
				message.availability[i] = $root.Availability.fromObject(object.availability[i]);
			}
		}
		if (object.trailerUri != null) message.trailerUri = String(object.trailerUri);
		if (object.musicAndTalk != null) message.musicAndTalk = Boolean(object.musicAndTalk);
		if (object.isAudiobook != null) message.isAudiobook = Boolean(object.isAudiobook);
		return message;
	};

	/**
	 * Creates a plain object from a Show message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Show
	 * @static
	 * @param {Show} message Show
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Show.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) {
			object.episode = [];
			object.copyright = [];
			object.restriction = [];
			object.keyword = [];
			object.availability = [];
		}
		if (options.defaults) {
			if (options.bytes === String) object.gid = "";
			else {
				object.gid = [];
				if (options.bytes !== Array) object.gid = $util.newBuffer(object.gid);
			}
			object.name = "";
			object.description = "";
			object.deprecatedPopularity = 0;
			object.publisher = "";
			object.language = "";
			object.explicit = false;
			object.coverImage = null;
			object.mediaType = options.enums === String ? "MIXED" : 0;
			object.consumptionOrder = options.enums === String ? "SEQUENTIAL" : 1;
			object.trailerUri = "";
			object.musicAndTalk = false;
			object.isAudiobook = false;
		}
		if (message.gid != null && message.hasOwnProperty("gid"))
			object.gid =
				options.bytes === String
					? $util.base64.encode(message.gid, 0, message.gid.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.gid)
					: message.gid;
		if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
		if (message.description != null && message.hasOwnProperty("description")) object.description = message.description;
		if (message.deprecatedPopularity != null && message.hasOwnProperty("deprecatedPopularity"))
			object.deprecatedPopularity = message.deprecatedPopularity;
		if (message.publisher != null && message.hasOwnProperty("publisher")) object.publisher = message.publisher;
		if (message.language != null && message.hasOwnProperty("language")) object.language = message.language;
		if (message.explicit != null && message.hasOwnProperty("explicit")) object.explicit = message.explicit;
		if (message.coverImage != null && message.hasOwnProperty("coverImage"))
			object.coverImage = $root.ImageGroup.toObject(message.coverImage, options);
		if (message.episode && message.episode.length) {
			object.episode = [];
			for (var j = 0; j < message.episode.length; ++j) object.episode[j] = $root.Episode.toObject(message.episode[j], options);
		}
		if (message.copyright && message.copyright.length) {
			object.copyright = [];
			for (var j = 0; j < message.copyright.length; ++j)
				object.copyright[j] = $root.Copyright.toObject(message.copyright[j], options);
		}
		if (message.restriction && message.restriction.length) {
			object.restriction = [];
			for (var j = 0; j < message.restriction.length; ++j)
				object.restriction[j] = $root.Restriction.toObject(message.restriction[j], options);
		}
		if (message.keyword && message.keyword.length) {
			object.keyword = [];
			for (var j = 0; j < message.keyword.length; ++j) object.keyword[j] = message.keyword[j];
		}
		if (message.mediaType != null && message.hasOwnProperty("mediaType"))
			object.mediaType =
				options.enums === String
					? $root.Show.MediaType[message.mediaType] === undefined
						? message.mediaType
						: $root.Show.MediaType[message.mediaType]
					: message.mediaType;
		if (message.consumptionOrder != null && message.hasOwnProperty("consumptionOrder"))
			object.consumptionOrder =
				options.enums === String
					? $root.Show.ConsumptionOrder[message.consumptionOrder] === undefined
						? message.consumptionOrder
						: $root.Show.ConsumptionOrder[message.consumptionOrder]
					: message.consumptionOrder;
		if (message.availability && message.availability.length) {
			object.availability = [];
			for (var j = 0; j < message.availability.length; ++j)
				object.availability[j] = $root.Availability.toObject(message.availability[j], options);
		}
		if (message.trailerUri != null && message.hasOwnProperty("trailerUri")) object.trailerUri = message.trailerUri;
		if (message.musicAndTalk != null && message.hasOwnProperty("musicAndTalk")) object.musicAndTalk = message.musicAndTalk;
		if (message.isAudiobook != null && message.hasOwnProperty("isAudiobook")) object.isAudiobook = message.isAudiobook;
		return object;
	};

	/**
	 * Converts this Show to JSON.
	 * @function toJSON
	 * @memberof Show
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Show.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Show
	 * @function getTypeUrl
	 * @memberof Show
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Show.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Show";
	};

	/**
	 * MediaType enum.
	 * @name Show.MediaType
	 * @enum {number}
	 * @property {number} MIXED=0 MIXED value
	 * @property {number} AUDIO=1 AUDIO value
	 * @property {number} VIDEO=2 VIDEO value
	 */
	Show.MediaType = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "MIXED")] = 0;
		values[(valuesById[1] = "AUDIO")] = 1;
		values[(valuesById[2] = "VIDEO")] = 2;
		return values;
	})();

	/**
	 * ConsumptionOrder enum.
	 * @name Show.ConsumptionOrder
	 * @enum {number}
	 * @property {number} SEQUENTIAL=1 SEQUENTIAL value
	 * @property {number} EPISODIC=2 EPISODIC value
	 * @property {number} RECENT=3 RECENT value
	 */
	Show.ConsumptionOrder = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[1] = "SEQUENTIAL")] = 1;
		values[(valuesById[2] = "EPISODIC")] = 2;
		values[(valuesById[3] = "RECENT")] = 3;
		return values;
	})();

	return Show;
})();

$root.Episode = (function () {
	/**
	 * Properties of an Episode.
	 * @exports IEpisode
	 * @interface IEpisode
	 * @property {Uint8Array|null} [gid] Episode gid
	 * @property {string|null} [name] Episode name
	 * @property {number|null} [duration] Episode duration
	 * @property {Array.<IAudioFile>|null} [audio] Episode audio
	 * @property {string|null} [description] Episode description
	 * @property {number|null} [number] Episode number
	 * @property {IDate|null} [publishTime] Episode publishTime
	 * @property {number|null} [deprecatedPopularity] Episode deprecatedPopularity
	 * @property {IImageGroup|null} [coverImage] Episode coverImage
	 * @property {string|null} [language] Episode language
	 * @property {boolean|null} [explicit] Episode explicit
	 * @property {IShow|null} [show] Episode show
	 * @property {Array.<IVideoFile>|null} [video] Episode video
	 * @property {Array.<IVideoFile>|null} [videoPreview] Episode videoPreview
	 * @property {Array.<IAudioFile>|null} [audioPreview] Episode audioPreview
	 * @property {Array.<IRestriction>|null} [restriction] Episode restriction
	 * @property {IImageGroup|null} [freezeFrame] Episode freezeFrame
	 * @property {Array.<string>|null} [keyword] Episode keyword
	 * @property {boolean|null} [allowBackgroundPlayback] Episode allowBackgroundPlayback
	 * @property {Array.<IAvailability>|null} [availability] Episode availability
	 * @property {string|null} [externalUrl] Episode externalUrl
	 * @property {Episode.EpisodeType|null} [type] Episode type
	 * @property {boolean|null} [musicAndTalk] Episode musicAndTalk
	 * @property {Array.<IContentRating>|null} [contentRating] Episode contentRating
	 * @property {boolean|null} [isAudiobookChapter] Episode isAudiobookChapter
	 */

	/**
	 * Constructs a new Episode.
	 * @exports Episode
	 * @classdesc Represents an Episode.
	 * @implements IEpisode
	 * @constructor
	 * @param {IEpisode=} [properties] Properties to set
	 */
	function Episode(properties) {
		this.audio = [];
		this.video = [];
		this.videoPreview = [];
		this.audioPreview = [];
		this.restriction = [];
		this.keyword = [];
		this.availability = [];
		this.contentRating = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Episode gid.
	 * @member {Uint8Array} gid
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.gid = $util.newBuffer([]);

	/**
	 * Episode name.
	 * @member {string} name
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.name = "";

	/**
	 * Episode duration.
	 * @member {number} duration
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.duration = 0;

	/**
	 * Episode audio.
	 * @member {Array.<IAudioFile>} audio
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.audio = $util.emptyArray;

	/**
	 * Episode description.
	 * @member {string} description
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.description = "";

	/**
	 * Episode number.
	 * @member {number} number
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.number = 0;

	/**
	 * Episode publishTime.
	 * @member {IDate|null|undefined} publishTime
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.publishTime = null;

	/**
	 * Episode deprecatedPopularity.
	 * @member {number} deprecatedPopularity
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.deprecatedPopularity = 0;

	/**
	 * Episode coverImage.
	 * @member {IImageGroup|null|undefined} coverImage
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.coverImage = null;

	/**
	 * Episode language.
	 * @member {string} language
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.language = "";

	/**
	 * Episode explicit.
	 * @member {boolean} explicit
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.explicit = false;

	/**
	 * Episode show.
	 * @member {IShow|null|undefined} show
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.show = null;

	/**
	 * Episode video.
	 * @member {Array.<IVideoFile>} video
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.video = $util.emptyArray;

	/**
	 * Episode videoPreview.
	 * @member {Array.<IVideoFile>} videoPreview
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.videoPreview = $util.emptyArray;

	/**
	 * Episode audioPreview.
	 * @member {Array.<IAudioFile>} audioPreview
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.audioPreview = $util.emptyArray;

	/**
	 * Episode restriction.
	 * @member {Array.<IRestriction>} restriction
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.restriction = $util.emptyArray;

	/**
	 * Episode freezeFrame.
	 * @member {IImageGroup|null|undefined} freezeFrame
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.freezeFrame = null;

	/**
	 * Episode keyword.
	 * @member {Array.<string>} keyword
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.keyword = $util.emptyArray;

	/**
	 * Episode allowBackgroundPlayback.
	 * @member {boolean} allowBackgroundPlayback
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.allowBackgroundPlayback = false;

	/**
	 * Episode availability.
	 * @member {Array.<IAvailability>} availability
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.availability = $util.emptyArray;

	/**
	 * Episode externalUrl.
	 * @member {string} externalUrl
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.externalUrl = "";

	/**
	 * Episode type.
	 * @member {Episode.EpisodeType} type
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.type = 0;

	/**
	 * Episode musicAndTalk.
	 * @member {boolean} musicAndTalk
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.musicAndTalk = false;

	/**
	 * Episode contentRating.
	 * @member {Array.<IContentRating>} contentRating
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.contentRating = $util.emptyArray;

	/**
	 * Episode isAudiobookChapter.
	 * @member {boolean} isAudiobookChapter
	 * @memberof Episode
	 * @instance
	 */
	Episode.prototype.isAudiobookChapter = false;

	/**
	 * Creates a new Episode instance using the specified properties.
	 * @function create
	 * @memberof Episode
	 * @static
	 * @param {IEpisode=} [properties] Properties to set
	 * @returns {Episode} Episode instance
	 */
	Episode.create = function create(properties) {
		return new Episode(properties);
	};

	/**
	 * Encodes the specified Episode message. Does not implicitly {@link Episode.verify|verify} messages.
	 * @function encode
	 * @memberof Episode
	 * @static
	 * @param {IEpisode} message Episode message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Episode.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.gid != null && Object.hasOwnProperty.call(message, "gid")) writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.gid);
		if (message.name != null && Object.hasOwnProperty.call(message, "name"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
		if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
			writer.uint32(/* id 7, wireType 0 =*/ 56).sint32(message.duration);
		if (message.audio != null && message.audio.length)
			for (var i = 0; i < message.audio.length; ++i)
				$root.AudioFile.encode(message.audio[i], writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
		if (message.description != null && Object.hasOwnProperty.call(message, "description"))
			writer.uint32(/* id 64, wireType 2 =*/ 514).string(message.description);
		if (message.number != null && Object.hasOwnProperty.call(message, "number"))
			writer.uint32(/* id 65, wireType 0 =*/ 520).sint32(message.number);
		if (message.publishTime != null && Object.hasOwnProperty.call(message, "publishTime"))
			$root.Date.encode(message.publishTime, writer.uint32(/* id 66, wireType 2 =*/ 530).fork()).ldelim();
		if (message.deprecatedPopularity != null && Object.hasOwnProperty.call(message, "deprecatedPopularity"))
			writer.uint32(/* id 67, wireType 0 =*/ 536).sint32(message.deprecatedPopularity);
		if (message.coverImage != null && Object.hasOwnProperty.call(message, "coverImage"))
			$root.ImageGroup.encode(message.coverImage, writer.uint32(/* id 68, wireType 2 =*/ 546).fork()).ldelim();
		if (message.language != null && Object.hasOwnProperty.call(message, "language"))
			writer.uint32(/* id 69, wireType 2 =*/ 554).string(message.language);
		if (message.explicit != null && Object.hasOwnProperty.call(message, "explicit"))
			writer.uint32(/* id 70, wireType 0 =*/ 560).bool(message.explicit);
		if (message.show != null && Object.hasOwnProperty.call(message, "show"))
			$root.Show.encode(message.show, writer.uint32(/* id 71, wireType 2 =*/ 570).fork()).ldelim();
		if (message.video != null && message.video.length)
			for (var i = 0; i < message.video.length; ++i)
				$root.VideoFile.encode(message.video[i], writer.uint32(/* id 72, wireType 2 =*/ 578).fork()).ldelim();
		if (message.videoPreview != null && message.videoPreview.length)
			for (var i = 0; i < message.videoPreview.length; ++i)
				$root.VideoFile.encode(message.videoPreview[i], writer.uint32(/* id 73, wireType 2 =*/ 586).fork()).ldelim();
		if (message.audioPreview != null && message.audioPreview.length)
			for (var i = 0; i < message.audioPreview.length; ++i)
				$root.AudioFile.encode(message.audioPreview[i], writer.uint32(/* id 74, wireType 2 =*/ 594).fork()).ldelim();
		if (message.restriction != null && message.restriction.length)
			for (var i = 0; i < message.restriction.length; ++i)
				$root.Restriction.encode(message.restriction[i], writer.uint32(/* id 75, wireType 2 =*/ 602).fork()).ldelim();
		if (message.freezeFrame != null && Object.hasOwnProperty.call(message, "freezeFrame"))
			$root.ImageGroup.encode(message.freezeFrame, writer.uint32(/* id 76, wireType 2 =*/ 610).fork()).ldelim();
		if (message.keyword != null && message.keyword.length)
			for (var i = 0; i < message.keyword.length; ++i) writer.uint32(/* id 77, wireType 2 =*/ 618).string(message.keyword[i]);
		if (message.allowBackgroundPlayback != null && Object.hasOwnProperty.call(message, "allowBackgroundPlayback"))
			writer.uint32(/* id 81, wireType 0 =*/ 648).bool(message.allowBackgroundPlayback);
		if (message.availability != null && message.availability.length)
			for (var i = 0; i < message.availability.length; ++i)
				$root.Availability.encode(message.availability[i], writer.uint32(/* id 82, wireType 2 =*/ 658).fork()).ldelim();
		if (message.externalUrl != null && Object.hasOwnProperty.call(message, "externalUrl"))
			writer.uint32(/* id 83, wireType 2 =*/ 666).string(message.externalUrl);
		if (message.type != null && Object.hasOwnProperty.call(message, "type"))
			writer.uint32(/* id 87, wireType 0 =*/ 696).int32(message.type);
		if (message.musicAndTalk != null && Object.hasOwnProperty.call(message, "musicAndTalk"))
			writer.uint32(/* id 91, wireType 0 =*/ 728).bool(message.musicAndTalk);
		if (message.contentRating != null && message.contentRating.length)
			for (var i = 0; i < message.contentRating.length; ++i)
				$root.ContentRating.encode(message.contentRating[i], writer.uint32(/* id 95, wireType 2 =*/ 762).fork()).ldelim();
		if (message.isAudiobookChapter != null && Object.hasOwnProperty.call(message, "isAudiobookChapter"))
			writer.uint32(/* id 96, wireType 0 =*/ 768).bool(message.isAudiobookChapter);
		return writer;
	};

	/**
	 * Encodes the specified Episode message, length delimited. Does not implicitly {@link Episode.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Episode
	 * @static
	 * @param {IEpisode} message Episode message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Episode.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an Episode message from the specified reader or buffer.
	 * @function decode
	 * @memberof Episode
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Episode} Episode
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Episode.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Episode();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.gid = reader.bytes();
					break;
				}
				case 2: {
					message.name = reader.string();
					break;
				}
				case 7: {
					message.duration = reader.sint32();
					break;
				}
				case 12: {
					if (!(message.audio && message.audio.length)) message.audio = [];
					message.audio.push($root.AudioFile.decode(reader, reader.uint32()));
					break;
				}
				case 64: {
					message.description = reader.string();
					break;
				}
				case 65: {
					message.number = reader.sint32();
					break;
				}
				case 66: {
					message.publishTime = $root.Date.decode(reader, reader.uint32());
					break;
				}
				case 67: {
					message.deprecatedPopularity = reader.sint32();
					break;
				}
				case 68: {
					message.coverImage = $root.ImageGroup.decode(reader, reader.uint32());
					break;
				}
				case 69: {
					message.language = reader.string();
					break;
				}
				case 70: {
					message.explicit = reader.bool();
					break;
				}
				case 71: {
					message.show = $root.Show.decode(reader, reader.uint32());
					break;
				}
				case 72: {
					if (!(message.video && message.video.length)) message.video = [];
					message.video.push($root.VideoFile.decode(reader, reader.uint32()));
					break;
				}
				case 73: {
					if (!(message.videoPreview && message.videoPreview.length)) message.videoPreview = [];
					message.videoPreview.push($root.VideoFile.decode(reader, reader.uint32()));
					break;
				}
				case 74: {
					if (!(message.audioPreview && message.audioPreview.length)) message.audioPreview = [];
					message.audioPreview.push($root.AudioFile.decode(reader, reader.uint32()));
					break;
				}
				case 75: {
					if (!(message.restriction && message.restriction.length)) message.restriction = [];
					message.restriction.push($root.Restriction.decode(reader, reader.uint32()));
					break;
				}
				case 76: {
					message.freezeFrame = $root.ImageGroup.decode(reader, reader.uint32());
					break;
				}
				case 77: {
					if (!(message.keyword && message.keyword.length)) message.keyword = [];
					message.keyword.push(reader.string());
					break;
				}
				case 81: {
					message.allowBackgroundPlayback = reader.bool();
					break;
				}
				case 82: {
					if (!(message.availability && message.availability.length)) message.availability = [];
					message.availability.push($root.Availability.decode(reader, reader.uint32()));
					break;
				}
				case 83: {
					message.externalUrl = reader.string();
					break;
				}
				case 87: {
					message.type = reader.int32();
					break;
				}
				case 91: {
					message.musicAndTalk = reader.bool();
					break;
				}
				case 95: {
					if (!(message.contentRating && message.contentRating.length)) message.contentRating = [];
					message.contentRating.push($root.ContentRating.decode(reader, reader.uint32()));
					break;
				}
				case 96: {
					message.isAudiobookChapter = reader.bool();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an Episode message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Episode
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Episode} Episode
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Episode.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an Episode message.
	 * @function verify
	 * @memberof Episode
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Episode.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.gid != null && message.hasOwnProperty("gid"))
			if (!((message.gid && typeof message.gid.length === "number") || $util.isString(message.gid))) return "gid: buffer expected";
		if (message.name != null && message.hasOwnProperty("name")) if (!$util.isString(message.name)) return "name: string expected";
		if (message.duration != null && message.hasOwnProperty("duration"))
			if (!$util.isInteger(message.duration)) return "duration: integer expected";
		if (message.audio != null && message.hasOwnProperty("audio")) {
			if (!Array.isArray(message.audio)) return "audio: array expected";
			for (var i = 0; i < message.audio.length; ++i) {
				var error = $root.AudioFile.verify(message.audio[i]);
				if (error) return "audio." + error;
			}
		}
		if (message.description != null && message.hasOwnProperty("description"))
			if (!$util.isString(message.description)) return "description: string expected";
		if (message.number != null && message.hasOwnProperty("number"))
			if (!$util.isInteger(message.number)) return "number: integer expected";
		if (message.publishTime != null && message.hasOwnProperty("publishTime")) {
			var error = $root.Date.verify(message.publishTime);
			if (error) return "publishTime." + error;
		}
		if (message.deprecatedPopularity != null && message.hasOwnProperty("deprecatedPopularity"))
			if (!$util.isInteger(message.deprecatedPopularity)) return "deprecatedPopularity: integer expected";
		if (message.coverImage != null && message.hasOwnProperty("coverImage")) {
			var error = $root.ImageGroup.verify(message.coverImage);
			if (error) return "coverImage." + error;
		}
		if (message.language != null && message.hasOwnProperty("language"))
			if (!$util.isString(message.language)) return "language: string expected";
		if (message.explicit != null && message.hasOwnProperty("explicit"))
			if (typeof message.explicit !== "boolean") return "explicit: boolean expected";
		if (message.show != null && message.hasOwnProperty("show")) {
			var error = $root.Show.verify(message.show);
			if (error) return "show." + error;
		}
		if (message.video != null && message.hasOwnProperty("video")) {
			if (!Array.isArray(message.video)) return "video: array expected";
			for (var i = 0; i < message.video.length; ++i) {
				var error = $root.VideoFile.verify(message.video[i]);
				if (error) return "video." + error;
			}
		}
		if (message.videoPreview != null && message.hasOwnProperty("videoPreview")) {
			if (!Array.isArray(message.videoPreview)) return "videoPreview: array expected";
			for (var i = 0; i < message.videoPreview.length; ++i) {
				var error = $root.VideoFile.verify(message.videoPreview[i]);
				if (error) return "videoPreview." + error;
			}
		}
		if (message.audioPreview != null && message.hasOwnProperty("audioPreview")) {
			if (!Array.isArray(message.audioPreview)) return "audioPreview: array expected";
			for (var i = 0; i < message.audioPreview.length; ++i) {
				var error = $root.AudioFile.verify(message.audioPreview[i]);
				if (error) return "audioPreview." + error;
			}
		}
		if (message.restriction != null && message.hasOwnProperty("restriction")) {
			if (!Array.isArray(message.restriction)) return "restriction: array expected";
			for (var i = 0; i < message.restriction.length; ++i) {
				var error = $root.Restriction.verify(message.restriction[i]);
				if (error) return "restriction." + error;
			}
		}
		if (message.freezeFrame != null && message.hasOwnProperty("freezeFrame")) {
			var error = $root.ImageGroup.verify(message.freezeFrame);
			if (error) return "freezeFrame." + error;
		}
		if (message.keyword != null && message.hasOwnProperty("keyword")) {
			if (!Array.isArray(message.keyword)) return "keyword: array expected";
			for (var i = 0; i < message.keyword.length; ++i) if (!$util.isString(message.keyword[i])) return "keyword: string[] expected";
		}
		if (message.allowBackgroundPlayback != null && message.hasOwnProperty("allowBackgroundPlayback"))
			if (typeof message.allowBackgroundPlayback !== "boolean") return "allowBackgroundPlayback: boolean expected";
		if (message.availability != null && message.hasOwnProperty("availability")) {
			if (!Array.isArray(message.availability)) return "availability: array expected";
			for (var i = 0; i < message.availability.length; ++i) {
				var error = $root.Availability.verify(message.availability[i]);
				if (error) return "availability." + error;
			}
		}
		if (message.externalUrl != null && message.hasOwnProperty("externalUrl"))
			if (!$util.isString(message.externalUrl)) return "externalUrl: string expected";
		if (message.type != null && message.hasOwnProperty("type"))
			switch (message.type) {
				default:
					return "type: enum value expected";
				case 0:
				case 1:
				case 2:
					break;
			}
		if (message.musicAndTalk != null && message.hasOwnProperty("musicAndTalk"))
			if (typeof message.musicAndTalk !== "boolean") return "musicAndTalk: boolean expected";
		if (message.contentRating != null && message.hasOwnProperty("contentRating")) {
			if (!Array.isArray(message.contentRating)) return "contentRating: array expected";
			for (var i = 0; i < message.contentRating.length; ++i) {
				var error = $root.ContentRating.verify(message.contentRating[i]);
				if (error) return "contentRating." + error;
			}
		}
		if (message.isAudiobookChapter != null && message.hasOwnProperty("isAudiobookChapter"))
			if (typeof message.isAudiobookChapter !== "boolean") return "isAudiobookChapter: boolean expected";
		return null;
	};

	/**
	 * Creates an Episode message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Episode
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Episode} Episode
	 */
	Episode.fromObject = function fromObject(object) {
		if (object instanceof $root.Episode) return object;
		var message = new $root.Episode();
		if (object.gid != null)
			if (typeof object.gid === "string")
				$util.base64.decode(object.gid, (message.gid = $util.newBuffer($util.base64.length(object.gid))), 0);
			else if (object.gid.length >= 0) message.gid = object.gid;
		if (object.name != null) message.name = String(object.name);
		if (object.duration != null) message.duration = object.duration | 0;
		if (object.audio) {
			if (!Array.isArray(object.audio)) throw TypeError(".Episode.audio: array expected");
			message.audio = [];
			for (var i = 0; i < object.audio.length; ++i) {
				if (typeof object.audio[i] !== "object") throw TypeError(".Episode.audio: object expected");
				message.audio[i] = $root.AudioFile.fromObject(object.audio[i]);
			}
		}
		if (object.description != null) message.description = String(object.description);
		if (object.number != null) message.number = object.number | 0;
		if (object.publishTime != null) {
			if (typeof object.publishTime !== "object") throw TypeError(".Episode.publishTime: object expected");
			message.publishTime = $root.Date.fromObject(object.publishTime);
		}
		if (object.deprecatedPopularity != null) message.deprecatedPopularity = object.deprecatedPopularity | 0;
		if (object.coverImage != null) {
			if (typeof object.coverImage !== "object") throw TypeError(".Episode.coverImage: object expected");
			message.coverImage = $root.ImageGroup.fromObject(object.coverImage);
		}
		if (object.language != null) message.language = String(object.language);
		if (object.explicit != null) message.explicit = Boolean(object.explicit);
		if (object.show != null) {
			if (typeof object.show !== "object") throw TypeError(".Episode.show: object expected");
			message.show = $root.Show.fromObject(object.show);
		}
		if (object.video) {
			if (!Array.isArray(object.video)) throw TypeError(".Episode.video: array expected");
			message.video = [];
			for (var i = 0; i < object.video.length; ++i) {
				if (typeof object.video[i] !== "object") throw TypeError(".Episode.video: object expected");
				message.video[i] = $root.VideoFile.fromObject(object.video[i]);
			}
		}
		if (object.videoPreview) {
			if (!Array.isArray(object.videoPreview)) throw TypeError(".Episode.videoPreview: array expected");
			message.videoPreview = [];
			for (var i = 0; i < object.videoPreview.length; ++i) {
				if (typeof object.videoPreview[i] !== "object") throw TypeError(".Episode.videoPreview: object expected");
				message.videoPreview[i] = $root.VideoFile.fromObject(object.videoPreview[i]);
			}
		}
		if (object.audioPreview) {
			if (!Array.isArray(object.audioPreview)) throw TypeError(".Episode.audioPreview: array expected");
			message.audioPreview = [];
			for (var i = 0; i < object.audioPreview.length; ++i) {
				if (typeof object.audioPreview[i] !== "object") throw TypeError(".Episode.audioPreview: object expected");
				message.audioPreview[i] = $root.AudioFile.fromObject(object.audioPreview[i]);
			}
		}
		if (object.restriction) {
			if (!Array.isArray(object.restriction)) throw TypeError(".Episode.restriction: array expected");
			message.restriction = [];
			for (var i = 0; i < object.restriction.length; ++i) {
				if (typeof object.restriction[i] !== "object") throw TypeError(".Episode.restriction: object expected");
				message.restriction[i] = $root.Restriction.fromObject(object.restriction[i]);
			}
		}
		if (object.freezeFrame != null) {
			if (typeof object.freezeFrame !== "object") throw TypeError(".Episode.freezeFrame: object expected");
			message.freezeFrame = $root.ImageGroup.fromObject(object.freezeFrame);
		}
		if (object.keyword) {
			if (!Array.isArray(object.keyword)) throw TypeError(".Episode.keyword: array expected");
			message.keyword = [];
			for (var i = 0; i < object.keyword.length; ++i) message.keyword[i] = String(object.keyword[i]);
		}
		if (object.allowBackgroundPlayback != null) message.allowBackgroundPlayback = Boolean(object.allowBackgroundPlayback);
		if (object.availability) {
			if (!Array.isArray(object.availability)) throw TypeError(".Episode.availability: array expected");
			message.availability = [];
			for (var i = 0; i < object.availability.length; ++i) {
				if (typeof object.availability[i] !== "object") throw TypeError(".Episode.availability: object expected");
				message.availability[i] = $root.Availability.fromObject(object.availability[i]);
			}
		}
		if (object.externalUrl != null) message.externalUrl = String(object.externalUrl);
		switch (object.type) {
			default:
				if (typeof object.type === "number") {
					message.type = object.type;
					break;
				}
				break;
			case "FULL":
			case 0:
				message.type = 0;
				break;
			case "TRAILER":
			case 1:
				message.type = 1;
				break;
			case "BONUS":
			case 2:
				message.type = 2;
				break;
		}
		if (object.musicAndTalk != null) message.musicAndTalk = Boolean(object.musicAndTalk);
		if (object.contentRating) {
			if (!Array.isArray(object.contentRating)) throw TypeError(".Episode.contentRating: array expected");
			message.contentRating = [];
			for (var i = 0; i < object.contentRating.length; ++i) {
				if (typeof object.contentRating[i] !== "object") throw TypeError(".Episode.contentRating: object expected");
				message.contentRating[i] = $root.ContentRating.fromObject(object.contentRating[i]);
			}
		}
		if (object.isAudiobookChapter != null) message.isAudiobookChapter = Boolean(object.isAudiobookChapter);
		return message;
	};

	/**
	 * Creates a plain object from an Episode message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Episode
	 * @static
	 * @param {Episode} message Episode
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Episode.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) {
			object.audio = [];
			object.video = [];
			object.videoPreview = [];
			object.audioPreview = [];
			object.restriction = [];
			object.keyword = [];
			object.availability = [];
			object.contentRating = [];
		}
		if (options.defaults) {
			if (options.bytes === String) object.gid = "";
			else {
				object.gid = [];
				if (options.bytes !== Array) object.gid = $util.newBuffer(object.gid);
			}
			object.name = "";
			object.duration = 0;
			object.description = "";
			object.number = 0;
			object.publishTime = null;
			object.deprecatedPopularity = 0;
			object.coverImage = null;
			object.language = "";
			object.explicit = false;
			object.show = null;
			object.freezeFrame = null;
			object.allowBackgroundPlayback = false;
			object.externalUrl = "";
			object.type = options.enums === String ? "FULL" : 0;
			object.musicAndTalk = false;
			object.isAudiobookChapter = false;
		}
		if (message.gid != null && message.hasOwnProperty("gid"))
			object.gid =
				options.bytes === String
					? $util.base64.encode(message.gid, 0, message.gid.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.gid)
					: message.gid;
		if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
		if (message.duration != null && message.hasOwnProperty("duration")) object.duration = message.duration;
		if (message.audio && message.audio.length) {
			object.audio = [];
			for (var j = 0; j < message.audio.length; ++j) object.audio[j] = $root.AudioFile.toObject(message.audio[j], options);
		}
		if (message.description != null && message.hasOwnProperty("description")) object.description = message.description;
		if (message.number != null && message.hasOwnProperty("number")) object.number = message.number;
		if (message.publishTime != null && message.hasOwnProperty("publishTime"))
			object.publishTime = $root.Date.toObject(message.publishTime, options);
		if (message.deprecatedPopularity != null && message.hasOwnProperty("deprecatedPopularity"))
			object.deprecatedPopularity = message.deprecatedPopularity;
		if (message.coverImage != null && message.hasOwnProperty("coverImage"))
			object.coverImage = $root.ImageGroup.toObject(message.coverImage, options);
		if (message.language != null && message.hasOwnProperty("language")) object.language = message.language;
		if (message.explicit != null && message.hasOwnProperty("explicit")) object.explicit = message.explicit;
		if (message.show != null && message.hasOwnProperty("show")) object.show = $root.Show.toObject(message.show, options);
		if (message.video && message.video.length) {
			object.video = [];
			for (var j = 0; j < message.video.length; ++j) object.video[j] = $root.VideoFile.toObject(message.video[j], options);
		}
		if (message.videoPreview && message.videoPreview.length) {
			object.videoPreview = [];
			for (var j = 0; j < message.videoPreview.length; ++j)
				object.videoPreview[j] = $root.VideoFile.toObject(message.videoPreview[j], options);
		}
		if (message.audioPreview && message.audioPreview.length) {
			object.audioPreview = [];
			for (var j = 0; j < message.audioPreview.length; ++j)
				object.audioPreview[j] = $root.AudioFile.toObject(message.audioPreview[j], options);
		}
		if (message.restriction && message.restriction.length) {
			object.restriction = [];
			for (var j = 0; j < message.restriction.length; ++j)
				object.restriction[j] = $root.Restriction.toObject(message.restriction[j], options);
		}
		if (message.freezeFrame != null && message.hasOwnProperty("freezeFrame"))
			object.freezeFrame = $root.ImageGroup.toObject(message.freezeFrame, options);
		if (message.keyword && message.keyword.length) {
			object.keyword = [];
			for (var j = 0; j < message.keyword.length; ++j) object.keyword[j] = message.keyword[j];
		}
		if (message.allowBackgroundPlayback != null && message.hasOwnProperty("allowBackgroundPlayback"))
			object.allowBackgroundPlayback = message.allowBackgroundPlayback;
		if (message.availability && message.availability.length) {
			object.availability = [];
			for (var j = 0; j < message.availability.length; ++j)
				object.availability[j] = $root.Availability.toObject(message.availability[j], options);
		}
		if (message.externalUrl != null && message.hasOwnProperty("externalUrl")) object.externalUrl = message.externalUrl;
		if (message.type != null && message.hasOwnProperty("type"))
			object.type =
				options.enums === String
					? $root.Episode.EpisodeType[message.type] === undefined
						? message.type
						: $root.Episode.EpisodeType[message.type]
					: message.type;
		if (message.musicAndTalk != null && message.hasOwnProperty("musicAndTalk")) object.musicAndTalk = message.musicAndTalk;
		if (message.contentRating && message.contentRating.length) {
			object.contentRating = [];
			for (var j = 0; j < message.contentRating.length; ++j)
				object.contentRating[j] = $root.ContentRating.toObject(message.contentRating[j], options);
		}
		if (message.isAudiobookChapter != null && message.hasOwnProperty("isAudiobookChapter"))
			object.isAudiobookChapter = message.isAudiobookChapter;
		return object;
	};

	/**
	 * Converts this Episode to JSON.
	 * @function toJSON
	 * @memberof Episode
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Episode.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Episode
	 * @function getTypeUrl
	 * @memberof Episode
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Episode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Episode";
	};

	/**
	 * EpisodeType enum.
	 * @name Episode.EpisodeType
	 * @enum {number}
	 * @property {number} FULL=0 FULL value
	 * @property {number} TRAILER=1 TRAILER value
	 * @property {number} BONUS=2 BONUS value
	 */
	Episode.EpisodeType = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "FULL")] = 0;
		values[(valuesById[1] = "TRAILER")] = 1;
		values[(valuesById[2] = "BONUS")] = 2;
		return values;
	})();

	return Episode;
})();

$root.Licensor = (function () {
	/**
	 * Properties of a Licensor.
	 * @exports ILicensor
	 * @interface ILicensor
	 * @property {Uint8Array|null} [uuid] Licensor uuid
	 */

	/**
	 * Constructs a new Licensor.
	 * @exports Licensor
	 * @classdesc Represents a Licensor.
	 * @implements ILicensor
	 * @constructor
	 * @param {ILicensor=} [properties] Properties to set
	 */
	function Licensor(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Licensor uuid.
	 * @member {Uint8Array} uuid
	 * @memberof Licensor
	 * @instance
	 */
	Licensor.prototype.uuid = $util.newBuffer([]);

	/**
	 * Creates a new Licensor instance using the specified properties.
	 * @function create
	 * @memberof Licensor
	 * @static
	 * @param {ILicensor=} [properties] Properties to set
	 * @returns {Licensor} Licensor instance
	 */
	Licensor.create = function create(properties) {
		return new Licensor(properties);
	};

	/**
	 * Encodes the specified Licensor message. Does not implicitly {@link Licensor.verify|verify} messages.
	 * @function encode
	 * @memberof Licensor
	 * @static
	 * @param {ILicensor} message Licensor message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Licensor.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.uuid);
		return writer;
	};

	/**
	 * Encodes the specified Licensor message, length delimited. Does not implicitly {@link Licensor.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Licensor
	 * @static
	 * @param {ILicensor} message Licensor message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Licensor.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Licensor message from the specified reader or buffer.
	 * @function decode
	 * @memberof Licensor
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Licensor} Licensor
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Licensor.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Licensor();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.uuid = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Licensor message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Licensor
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Licensor} Licensor
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Licensor.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Licensor message.
	 * @function verify
	 * @memberof Licensor
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Licensor.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.uuid != null && message.hasOwnProperty("uuid"))
			if (!((message.uuid && typeof message.uuid.length === "number") || $util.isString(message.uuid)))
				return "uuid: buffer expected";
		return null;
	};

	/**
	 * Creates a Licensor message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Licensor
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Licensor} Licensor
	 */
	Licensor.fromObject = function fromObject(object) {
		if (object instanceof $root.Licensor) return object;
		var message = new $root.Licensor();
		if (object.uuid != null)
			if (typeof object.uuid === "string")
				$util.base64.decode(object.uuid, (message.uuid = $util.newBuffer($util.base64.length(object.uuid))), 0);
			else if (object.uuid.length >= 0) message.uuid = object.uuid;
		return message;
	};

	/**
	 * Creates a plain object from a Licensor message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Licensor
	 * @static
	 * @param {Licensor} message Licensor
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Licensor.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.uuid = "";
			else {
				object.uuid = [];
				if (options.bytes !== Array) object.uuid = $util.newBuffer(object.uuid);
			}
		if (message.uuid != null && message.hasOwnProperty("uuid"))
			object.uuid =
				options.bytes === String
					? $util.base64.encode(message.uuid, 0, message.uuid.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.uuid)
					: message.uuid;
		return object;
	};

	/**
	 * Converts this Licensor to JSON.
	 * @function toJSON
	 * @memberof Licensor
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Licensor.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Licensor
	 * @function getTypeUrl
	 * @memberof Licensor
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Licensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Licensor";
	};

	return Licensor;
})();

$root.TopTracks = (function () {
	/**
	 * Properties of a TopTracks.
	 * @exports ITopTracks
	 * @interface ITopTracks
	 * @property {string|null} [country] TopTracks country
	 * @property {Array.<ITrack>|null} [track] TopTracks track
	 */

	/**
	 * Constructs a new TopTracks.
	 * @exports TopTracks
	 * @classdesc Represents a TopTracks.
	 * @implements ITopTracks
	 * @constructor
	 * @param {ITopTracks=} [properties] Properties to set
	 */
	function TopTracks(properties) {
		this.track = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * TopTracks country.
	 * @member {string} country
	 * @memberof TopTracks
	 * @instance
	 */
	TopTracks.prototype.country = "";

	/**
	 * TopTracks track.
	 * @member {Array.<ITrack>} track
	 * @memberof TopTracks
	 * @instance
	 */
	TopTracks.prototype.track = $util.emptyArray;

	/**
	 * Creates a new TopTracks instance using the specified properties.
	 * @function create
	 * @memberof TopTracks
	 * @static
	 * @param {ITopTracks=} [properties] Properties to set
	 * @returns {TopTracks} TopTracks instance
	 */
	TopTracks.create = function create(properties) {
		return new TopTracks(properties);
	};

	/**
	 * Encodes the specified TopTracks message. Does not implicitly {@link TopTracks.verify|verify} messages.
	 * @function encode
	 * @memberof TopTracks
	 * @static
	 * @param {ITopTracks} message TopTracks message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	TopTracks.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.country != null && Object.hasOwnProperty.call(message, "country"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.country);
		if (message.track != null && message.track.length)
			for (var i = 0; i < message.track.length; ++i)
				$root.Track.encode(message.track[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified TopTracks message, length delimited. Does not implicitly {@link TopTracks.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof TopTracks
	 * @static
	 * @param {ITopTracks} message TopTracks message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	TopTracks.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a TopTracks message from the specified reader or buffer.
	 * @function decode
	 * @memberof TopTracks
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {TopTracks} TopTracks
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	TopTracks.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.TopTracks();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.country = reader.string();
					break;
				}
				case 2: {
					if (!(message.track && message.track.length)) message.track = [];
					message.track.push($root.Track.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a TopTracks message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof TopTracks
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {TopTracks} TopTracks
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	TopTracks.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a TopTracks message.
	 * @function verify
	 * @memberof TopTracks
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	TopTracks.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.country != null && message.hasOwnProperty("country"))
			if (!$util.isString(message.country)) return "country: string expected";
		if (message.track != null && message.hasOwnProperty("track")) {
			if (!Array.isArray(message.track)) return "track: array expected";
			for (var i = 0; i < message.track.length; ++i) {
				var error = $root.Track.verify(message.track[i]);
				if (error) return "track." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a TopTracks message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof TopTracks
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {TopTracks} TopTracks
	 */
	TopTracks.fromObject = function fromObject(object) {
		if (object instanceof $root.TopTracks) return object;
		var message = new $root.TopTracks();
		if (object.country != null) message.country = String(object.country);
		if (object.track) {
			if (!Array.isArray(object.track)) throw TypeError(".TopTracks.track: array expected");
			message.track = [];
			for (var i = 0; i < object.track.length; ++i) {
				if (typeof object.track[i] !== "object") throw TypeError(".TopTracks.track: object expected");
				message.track[i] = $root.Track.fromObject(object.track[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a TopTracks message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof TopTracks
	 * @static
	 * @param {TopTracks} message TopTracks
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	TopTracks.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.track = [];
		if (options.defaults) object.country = "";
		if (message.country != null && message.hasOwnProperty("country")) object.country = message.country;
		if (message.track && message.track.length) {
			object.track = [];
			for (var j = 0; j < message.track.length; ++j) object.track[j] = $root.Track.toObject(message.track[j], options);
		}
		return object;
	};

	/**
	 * Converts this TopTracks to JSON.
	 * @function toJSON
	 * @memberof TopTracks
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	TopTracks.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for TopTracks
	 * @function getTypeUrl
	 * @memberof TopTracks
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	TopTracks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/TopTracks";
	};

	return TopTracks;
})();

$root.ActivityPeriod = (function () {
	/**
	 * Properties of an ActivityPeriod.
	 * @exports IActivityPeriod
	 * @interface IActivityPeriod
	 * @property {number|null} [startYear] ActivityPeriod startYear
	 * @property {number|null} [endYear] ActivityPeriod endYear
	 * @property {number|null} [decade] ActivityPeriod decade
	 */

	/**
	 * Constructs a new ActivityPeriod.
	 * @exports ActivityPeriod
	 * @classdesc Represents an ActivityPeriod.
	 * @implements IActivityPeriod
	 * @constructor
	 * @param {IActivityPeriod=} [properties] Properties to set
	 */
	function ActivityPeriod(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ActivityPeriod startYear.
	 * @member {number} startYear
	 * @memberof ActivityPeriod
	 * @instance
	 */
	ActivityPeriod.prototype.startYear = 0;

	/**
	 * ActivityPeriod endYear.
	 * @member {number} endYear
	 * @memberof ActivityPeriod
	 * @instance
	 */
	ActivityPeriod.prototype.endYear = 0;

	/**
	 * ActivityPeriod decade.
	 * @member {number} decade
	 * @memberof ActivityPeriod
	 * @instance
	 */
	ActivityPeriod.prototype.decade = 0;

	/**
	 * Creates a new ActivityPeriod instance using the specified properties.
	 * @function create
	 * @memberof ActivityPeriod
	 * @static
	 * @param {IActivityPeriod=} [properties] Properties to set
	 * @returns {ActivityPeriod} ActivityPeriod instance
	 */
	ActivityPeriod.create = function create(properties) {
		return new ActivityPeriod(properties);
	};

	/**
	 * Encodes the specified ActivityPeriod message. Does not implicitly {@link ActivityPeriod.verify|verify} messages.
	 * @function encode
	 * @memberof ActivityPeriod
	 * @static
	 * @param {IActivityPeriod} message ActivityPeriod message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ActivityPeriod.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.startYear != null && Object.hasOwnProperty.call(message, "startYear"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.startYear);
		if (message.endYear != null && Object.hasOwnProperty.call(message, "endYear"))
			writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.endYear);
		if (message.decade != null && Object.hasOwnProperty.call(message, "decade"))
			writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.decade);
		return writer;
	};

	/**
	 * Encodes the specified ActivityPeriod message, length delimited. Does not implicitly {@link ActivityPeriod.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ActivityPeriod
	 * @static
	 * @param {IActivityPeriod} message ActivityPeriod message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ActivityPeriod.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an ActivityPeriod message from the specified reader or buffer.
	 * @function decode
	 * @memberof ActivityPeriod
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ActivityPeriod} ActivityPeriod
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ActivityPeriod.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ActivityPeriod();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.startYear = reader.sint32();
					break;
				}
				case 2: {
					message.endYear = reader.sint32();
					break;
				}
				case 3: {
					message.decade = reader.sint32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an ActivityPeriod message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ActivityPeriod
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ActivityPeriod} ActivityPeriod
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ActivityPeriod.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an ActivityPeriod message.
	 * @function verify
	 * @memberof ActivityPeriod
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ActivityPeriod.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.startYear != null && message.hasOwnProperty("startYear"))
			if (!$util.isInteger(message.startYear)) return "startYear: integer expected";
		if (message.endYear != null && message.hasOwnProperty("endYear"))
			if (!$util.isInteger(message.endYear)) return "endYear: integer expected";
		if (message.decade != null && message.hasOwnProperty("decade"))
			if (!$util.isInteger(message.decade)) return "decade: integer expected";
		return null;
	};

	/**
	 * Creates an ActivityPeriod message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ActivityPeriod
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ActivityPeriod} ActivityPeriod
	 */
	ActivityPeriod.fromObject = function fromObject(object) {
		if (object instanceof $root.ActivityPeriod) return object;
		var message = new $root.ActivityPeriod();
		if (object.startYear != null) message.startYear = object.startYear | 0;
		if (object.endYear != null) message.endYear = object.endYear | 0;
		if (object.decade != null) message.decade = object.decade | 0;
		return message;
	};

	/**
	 * Creates a plain object from an ActivityPeriod message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ActivityPeriod
	 * @static
	 * @param {ActivityPeriod} message ActivityPeriod
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ActivityPeriod.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.startYear = 0;
			object.endYear = 0;
			object.decade = 0;
		}
		if (message.startYear != null && message.hasOwnProperty("startYear")) object.startYear = message.startYear;
		if (message.endYear != null && message.hasOwnProperty("endYear")) object.endYear = message.endYear;
		if (message.decade != null && message.hasOwnProperty("decade")) object.decade = message.decade;
		return object;
	};

	/**
	 * Converts this ActivityPeriod to JSON.
	 * @function toJSON
	 * @memberof ActivityPeriod
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ActivityPeriod.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ActivityPeriod
	 * @function getTypeUrl
	 * @memberof ActivityPeriod
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ActivityPeriod.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ActivityPeriod";
	};

	return ActivityPeriod;
})();

$root.AlbumGroup = (function () {
	/**
	 * Properties of an AlbumGroup.
	 * @exports IAlbumGroup
	 * @interface IAlbumGroup
	 * @property {Array.<IAlbum>|null} [album] AlbumGroup album
	 */

	/**
	 * Constructs a new AlbumGroup.
	 * @exports AlbumGroup
	 * @classdesc Represents an AlbumGroup.
	 * @implements IAlbumGroup
	 * @constructor
	 * @param {IAlbumGroup=} [properties] Properties to set
	 */
	function AlbumGroup(properties) {
		this.album = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * AlbumGroup album.
	 * @member {Array.<IAlbum>} album
	 * @memberof AlbumGroup
	 * @instance
	 */
	AlbumGroup.prototype.album = $util.emptyArray;

	/**
	 * Creates a new AlbumGroup instance using the specified properties.
	 * @function create
	 * @memberof AlbumGroup
	 * @static
	 * @param {IAlbumGroup=} [properties] Properties to set
	 * @returns {AlbumGroup} AlbumGroup instance
	 */
	AlbumGroup.create = function create(properties) {
		return new AlbumGroup(properties);
	};

	/**
	 * Encodes the specified AlbumGroup message. Does not implicitly {@link AlbumGroup.verify|verify} messages.
	 * @function encode
	 * @memberof AlbumGroup
	 * @static
	 * @param {IAlbumGroup} message AlbumGroup message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AlbumGroup.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.album != null && message.album.length)
			for (var i = 0; i < message.album.length; ++i)
				$root.Album.encode(message.album[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified AlbumGroup message, length delimited. Does not implicitly {@link AlbumGroup.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof AlbumGroup
	 * @static
	 * @param {IAlbumGroup} message AlbumGroup message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AlbumGroup.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an AlbumGroup message from the specified reader or buffer.
	 * @function decode
	 * @memberof AlbumGroup
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {AlbumGroup} AlbumGroup
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AlbumGroup.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.AlbumGroup();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (!(message.album && message.album.length)) message.album = [];
					message.album.push($root.Album.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an AlbumGroup message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof AlbumGroup
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {AlbumGroup} AlbumGroup
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AlbumGroup.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an AlbumGroup message.
	 * @function verify
	 * @memberof AlbumGroup
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	AlbumGroup.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.album != null && message.hasOwnProperty("album")) {
			if (!Array.isArray(message.album)) return "album: array expected";
			for (var i = 0; i < message.album.length; ++i) {
				var error = $root.Album.verify(message.album[i]);
				if (error) return "album." + error;
			}
		}
		return null;
	};

	/**
	 * Creates an AlbumGroup message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof AlbumGroup
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {AlbumGroup} AlbumGroup
	 */
	AlbumGroup.fromObject = function fromObject(object) {
		if (object instanceof $root.AlbumGroup) return object;
		var message = new $root.AlbumGroup();
		if (object.album) {
			if (!Array.isArray(object.album)) throw TypeError(".AlbumGroup.album: array expected");
			message.album = [];
			for (var i = 0; i < object.album.length; ++i) {
				if (typeof object.album[i] !== "object") throw TypeError(".AlbumGroup.album: object expected");
				message.album[i] = $root.Album.fromObject(object.album[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from an AlbumGroup message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof AlbumGroup
	 * @static
	 * @param {AlbumGroup} message AlbumGroup
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	AlbumGroup.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.album = [];
		if (message.album && message.album.length) {
			object.album = [];
			for (var j = 0; j < message.album.length; ++j) object.album[j] = $root.Album.toObject(message.album[j], options);
		}
		return object;
	};

	/**
	 * Converts this AlbumGroup to JSON.
	 * @function toJSON
	 * @memberof AlbumGroup
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	AlbumGroup.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for AlbumGroup
	 * @function getTypeUrl
	 * @memberof AlbumGroup
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	AlbumGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/AlbumGroup";
	};

	return AlbumGroup;
})();

$root.Date = (function () {
	/**
	 * Properties of a Date.
	 * @exports IDate
	 * @interface IDate
	 * @property {number|null} [year] Date year
	 * @property {number|null} [month] Date month
	 * @property {number|null} [day] Date day
	 * @property {number|null} [hour] Date hour
	 * @property {number|null} [minute] Date minute
	 */

	/**
	 * Constructs a new Date.
	 * @exports Date
	 * @classdesc Represents a Date.
	 * @implements IDate
	 * @constructor
	 * @param {IDate=} [properties] Properties to set
	 */
	function Date(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Date year.
	 * @member {number} year
	 * @memberof Date
	 * @instance
	 */
	Date.prototype.year = 0;

	/**
	 * Date month.
	 * @member {number} month
	 * @memberof Date
	 * @instance
	 */
	Date.prototype.month = 0;

	/**
	 * Date day.
	 * @member {number} day
	 * @memberof Date
	 * @instance
	 */
	Date.prototype.day = 0;

	/**
	 * Date hour.
	 * @member {number} hour
	 * @memberof Date
	 * @instance
	 */
	Date.prototype.hour = 0;

	/**
	 * Date minute.
	 * @member {number} minute
	 * @memberof Date
	 * @instance
	 */
	Date.prototype.minute = 0;

	/**
	 * Creates a new Date instance using the specified properties.
	 * @function create
	 * @memberof Date
	 * @static
	 * @param {IDate=} [properties] Properties to set
	 * @returns {Date} Date instance
	 */
	Date.create = function create(properties) {
		return new Date(properties);
	};

	/**
	 * Encodes the specified Date message. Does not implicitly {@link Date.verify|verify} messages.
	 * @function encode
	 * @memberof Date
	 * @static
	 * @param {IDate} message Date message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Date.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.year != null && Object.hasOwnProperty.call(message, "year"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.year);
		if (message.month != null && Object.hasOwnProperty.call(message, "month"))
			writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.month);
		if (message.day != null && Object.hasOwnProperty.call(message, "day"))
			writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.day);
		if (message.hour != null && Object.hasOwnProperty.call(message, "hour"))
			writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.hour);
		if (message.minute != null && Object.hasOwnProperty.call(message, "minute"))
			writer.uint32(/* id 5, wireType 0 =*/ 40).sint32(message.minute);
		return writer;
	};

	/**
	 * Encodes the specified Date message, length delimited. Does not implicitly {@link Date.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Date
	 * @static
	 * @param {IDate} message Date message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Date.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Date message from the specified reader or buffer.
	 * @function decode
	 * @memberof Date
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Date} Date
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Date.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Date();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.year = reader.sint32();
					break;
				}
				case 2: {
					message.month = reader.sint32();
					break;
				}
				case 3: {
					message.day = reader.sint32();
					break;
				}
				case 4: {
					message.hour = reader.sint32();
					break;
				}
				case 5: {
					message.minute = reader.sint32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Date message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Date
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Date} Date
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Date.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Date message.
	 * @function verify
	 * @memberof Date
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Date.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.year != null && message.hasOwnProperty("year")) if (!$util.isInteger(message.year)) return "year: integer expected";
		if (message.month != null && message.hasOwnProperty("month")) if (!$util.isInteger(message.month)) return "month: integer expected";
		if (message.day != null && message.hasOwnProperty("day")) if (!$util.isInteger(message.day)) return "day: integer expected";
		if (message.hour != null && message.hasOwnProperty("hour")) if (!$util.isInteger(message.hour)) return "hour: integer expected";
		if (message.minute != null && message.hasOwnProperty("minute"))
			if (!$util.isInteger(message.minute)) return "minute: integer expected";
		return null;
	};

	/**
	 * Creates a Date message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Date
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Date} Date
	 */
	Date.fromObject = function fromObject(object) {
		if (object instanceof $root.Date) return object;
		var message = new $root.Date();
		if (object.year != null) message.year = object.year | 0;
		if (object.month != null) message.month = object.month | 0;
		if (object.day != null) message.day = object.day | 0;
		if (object.hour != null) message.hour = object.hour | 0;
		if (object.minute != null) message.minute = object.minute | 0;
		return message;
	};

	/**
	 * Creates a plain object from a Date message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Date
	 * @static
	 * @param {Date} message Date
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Date.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.year = 0;
			object.month = 0;
			object.day = 0;
			object.hour = 0;
			object.minute = 0;
		}
		if (message.year != null && message.hasOwnProperty("year")) object.year = message.year;
		if (message.month != null && message.hasOwnProperty("month")) object.month = message.month;
		if (message.day != null && message.hasOwnProperty("day")) object.day = message.day;
		if (message.hour != null && message.hasOwnProperty("hour")) object.hour = message.hour;
		if (message.minute != null && message.hasOwnProperty("minute")) object.minute = message.minute;
		return object;
	};

	/**
	 * Converts this Date to JSON.
	 * @function toJSON
	 * @memberof Date
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Date.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Date
	 * @function getTypeUrl
	 * @memberof Date
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Date.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Date";
	};

	return Date;
})();

$root.Image = (function () {
	/**
	 * Properties of an Image.
	 * @exports IImage
	 * @interface IImage
	 * @property {Uint8Array|null} [fileId] Image fileId
	 * @property {Image.Size|null} [size] Image size
	 * @property {number|null} [width] Image width
	 * @property {number|null} [height] Image height
	 */

	/**
	 * Constructs a new Image.
	 * @exports Image
	 * @classdesc Represents an Image.
	 * @implements IImage
	 * @constructor
	 * @param {IImage=} [properties] Properties to set
	 */
	function Image(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Image fileId.
	 * @member {Uint8Array} fileId
	 * @memberof Image
	 * @instance
	 */
	Image.prototype.fileId = $util.newBuffer([]);

	/**
	 * Image size.
	 * @member {Image.Size} size
	 * @memberof Image
	 * @instance
	 */
	Image.prototype.size = 0;

	/**
	 * Image width.
	 * @member {number} width
	 * @memberof Image
	 * @instance
	 */
	Image.prototype.width = 0;

	/**
	 * Image height.
	 * @member {number} height
	 * @memberof Image
	 * @instance
	 */
	Image.prototype.height = 0;

	/**
	 * Creates a new Image instance using the specified properties.
	 * @function create
	 * @memberof Image
	 * @static
	 * @param {IImage=} [properties] Properties to set
	 * @returns {Image} Image instance
	 */
	Image.create = function create(properties) {
		return new Image(properties);
	};

	/**
	 * Encodes the specified Image message. Does not implicitly {@link Image.verify|verify} messages.
	 * @function encode
	 * @memberof Image
	 * @static
	 * @param {IImage} message Image message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Image.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.fileId);
		if (message.size != null && Object.hasOwnProperty.call(message, "size"))
			writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.size);
		if (message.width != null && Object.hasOwnProperty.call(message, "width"))
			writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.width);
		if (message.height != null && Object.hasOwnProperty.call(message, "height"))
			writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.height);
		return writer;
	};

	/**
	 * Encodes the specified Image message, length delimited. Does not implicitly {@link Image.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Image
	 * @static
	 * @param {IImage} message Image message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Image.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an Image message from the specified reader or buffer.
	 * @function decode
	 * @memberof Image
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Image} Image
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Image.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Image();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.fileId = reader.bytes();
					break;
				}
				case 2: {
					message.size = reader.int32();
					break;
				}
				case 3: {
					message.width = reader.sint32();
					break;
				}
				case 4: {
					message.height = reader.sint32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an Image message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Image
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Image} Image
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Image.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an Image message.
	 * @function verify
	 * @memberof Image
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Image.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.fileId != null && message.hasOwnProperty("fileId"))
			if (!((message.fileId && typeof message.fileId.length === "number") || $util.isString(message.fileId)))
				return "fileId: buffer expected";
		if (message.size != null && message.hasOwnProperty("size"))
			switch (message.size) {
				default:
					return "size: enum value expected";
				case 0:
				case 1:
				case 2:
				case 3:
					break;
			}
		if (message.width != null && message.hasOwnProperty("width")) if (!$util.isInteger(message.width)) return "width: integer expected";
		if (message.height != null && message.hasOwnProperty("height"))
			if (!$util.isInteger(message.height)) return "height: integer expected";
		return null;
	};

	/**
	 * Creates an Image message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Image
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Image} Image
	 */
	Image.fromObject = function fromObject(object) {
		if (object instanceof $root.Image) return object;
		var message = new $root.Image();
		if (object.fileId != null)
			if (typeof object.fileId === "string")
				$util.base64.decode(object.fileId, (message.fileId = $util.newBuffer($util.base64.length(object.fileId))), 0);
			else if (object.fileId.length >= 0) message.fileId = object.fileId;
		switch (object.size) {
			default:
				if (typeof object.size === "number") {
					message.size = object.size;
					break;
				}
				break;
			case "DEFAULT":
			case 0:
				message.size = 0;
				break;
			case "SMALL":
			case 1:
				message.size = 1;
				break;
			case "LARGE":
			case 2:
				message.size = 2;
				break;
			case "XLARGE":
			case 3:
				message.size = 3;
				break;
		}
		if (object.width != null) message.width = object.width | 0;
		if (object.height != null) message.height = object.height | 0;
		return message;
	};

	/**
	 * Creates a plain object from an Image message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Image
	 * @static
	 * @param {Image} message Image
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Image.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			if (options.bytes === String) object.fileId = "";
			else {
				object.fileId = [];
				if (options.bytes !== Array) object.fileId = $util.newBuffer(object.fileId);
			}
			object.size = options.enums === String ? "DEFAULT" : 0;
			object.width = 0;
			object.height = 0;
		}
		if (message.fileId != null && message.hasOwnProperty("fileId"))
			object.fileId =
				options.bytes === String
					? $util.base64.encode(message.fileId, 0, message.fileId.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.fileId)
					: message.fileId;
		if (message.size != null && message.hasOwnProperty("size"))
			object.size =
				options.enums === String
					? $root.Image.Size[message.size] === undefined
						? message.size
						: $root.Image.Size[message.size]
					: message.size;
		if (message.width != null && message.hasOwnProperty("width")) object.width = message.width;
		if (message.height != null && message.hasOwnProperty("height")) object.height = message.height;
		return object;
	};

	/**
	 * Converts this Image to JSON.
	 * @function toJSON
	 * @memberof Image
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Image.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Image
	 * @function getTypeUrl
	 * @memberof Image
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Image.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Image";
	};

	/**
	 * Size enum.
	 * @name Image.Size
	 * @enum {number}
	 * @property {number} DEFAULT=0 DEFAULT value
	 * @property {number} SMALL=1 SMALL value
	 * @property {number} LARGE=2 LARGE value
	 * @property {number} XLARGE=3 XLARGE value
	 */
	Image.Size = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "DEFAULT")] = 0;
		values[(valuesById[1] = "SMALL")] = 1;
		values[(valuesById[2] = "LARGE")] = 2;
		values[(valuesById[3] = "XLARGE")] = 3;
		return values;
	})();

	return Image;
})();

$root.ImageGroup = (function () {
	/**
	 * Properties of an ImageGroup.
	 * @exports IImageGroup
	 * @interface IImageGroup
	 * @property {Array.<IImage>|null} [image] ImageGroup image
	 */

	/**
	 * Constructs a new ImageGroup.
	 * @exports ImageGroup
	 * @classdesc Represents an ImageGroup.
	 * @implements IImageGroup
	 * @constructor
	 * @param {IImageGroup=} [properties] Properties to set
	 */
	function ImageGroup(properties) {
		this.image = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ImageGroup image.
	 * @member {Array.<IImage>} image
	 * @memberof ImageGroup
	 * @instance
	 */
	ImageGroup.prototype.image = $util.emptyArray;

	/**
	 * Creates a new ImageGroup instance using the specified properties.
	 * @function create
	 * @memberof ImageGroup
	 * @static
	 * @param {IImageGroup=} [properties] Properties to set
	 * @returns {ImageGroup} ImageGroup instance
	 */
	ImageGroup.create = function create(properties) {
		return new ImageGroup(properties);
	};

	/**
	 * Encodes the specified ImageGroup message. Does not implicitly {@link ImageGroup.verify|verify} messages.
	 * @function encode
	 * @memberof ImageGroup
	 * @static
	 * @param {IImageGroup} message ImageGroup message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ImageGroup.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.image != null && message.image.length)
			for (var i = 0; i < message.image.length; ++i)
				$root.Image.encode(message.image[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified ImageGroup message, length delimited. Does not implicitly {@link ImageGroup.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ImageGroup
	 * @static
	 * @param {IImageGroup} message ImageGroup message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ImageGroup.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an ImageGroup message from the specified reader or buffer.
	 * @function decode
	 * @memberof ImageGroup
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ImageGroup} ImageGroup
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ImageGroup.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ImageGroup();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (!(message.image && message.image.length)) message.image = [];
					message.image.push($root.Image.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an ImageGroup message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ImageGroup
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ImageGroup} ImageGroup
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ImageGroup.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an ImageGroup message.
	 * @function verify
	 * @memberof ImageGroup
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ImageGroup.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.image != null && message.hasOwnProperty("image")) {
			if (!Array.isArray(message.image)) return "image: array expected";
			for (var i = 0; i < message.image.length; ++i) {
				var error = $root.Image.verify(message.image[i]);
				if (error) return "image." + error;
			}
		}
		return null;
	};

	/**
	 * Creates an ImageGroup message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ImageGroup
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ImageGroup} ImageGroup
	 */
	ImageGroup.fromObject = function fromObject(object) {
		if (object instanceof $root.ImageGroup) return object;
		var message = new $root.ImageGroup();
		if (object.image) {
			if (!Array.isArray(object.image)) throw TypeError(".ImageGroup.image: array expected");
			message.image = [];
			for (var i = 0; i < object.image.length; ++i) {
				if (typeof object.image[i] !== "object") throw TypeError(".ImageGroup.image: object expected");
				message.image[i] = $root.Image.fromObject(object.image[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from an ImageGroup message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ImageGroup
	 * @static
	 * @param {ImageGroup} message ImageGroup
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ImageGroup.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.image = [];
		if (message.image && message.image.length) {
			object.image = [];
			for (var j = 0; j < message.image.length; ++j) object.image[j] = $root.Image.toObject(message.image[j], options);
		}
		return object;
	};

	/**
	 * Converts this ImageGroup to JSON.
	 * @function toJSON
	 * @memberof ImageGroup
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ImageGroup.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ImageGroup
	 * @function getTypeUrl
	 * @memberof ImageGroup
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ImageGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ImageGroup";
	};

	return ImageGroup;
})();

$root.Biography = (function () {
	/**
	 * Properties of a Biography.
	 * @exports IBiography
	 * @interface IBiography
	 * @property {string|null} [text] Biography text
	 * @property {Array.<IImage>|null} [portrait] Biography portrait
	 * @property {Array.<IImageGroup>|null} [portraitGroup] Biography portraitGroup
	 */

	/**
	 * Constructs a new Biography.
	 * @exports Biography
	 * @classdesc Represents a Biography.
	 * @implements IBiography
	 * @constructor
	 * @param {IBiography=} [properties] Properties to set
	 */
	function Biography(properties) {
		this.portrait = [];
		this.portraitGroup = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Biography text.
	 * @member {string} text
	 * @memberof Biography
	 * @instance
	 */
	Biography.prototype.text = "";

	/**
	 * Biography portrait.
	 * @member {Array.<IImage>} portrait
	 * @memberof Biography
	 * @instance
	 */
	Biography.prototype.portrait = $util.emptyArray;

	/**
	 * Biography portraitGroup.
	 * @member {Array.<IImageGroup>} portraitGroup
	 * @memberof Biography
	 * @instance
	 */
	Biography.prototype.portraitGroup = $util.emptyArray;

	/**
	 * Creates a new Biography instance using the specified properties.
	 * @function create
	 * @memberof Biography
	 * @static
	 * @param {IBiography=} [properties] Properties to set
	 * @returns {Biography} Biography instance
	 */
	Biography.create = function create(properties) {
		return new Biography(properties);
	};

	/**
	 * Encodes the specified Biography message. Does not implicitly {@link Biography.verify|verify} messages.
	 * @function encode
	 * @memberof Biography
	 * @static
	 * @param {IBiography} message Biography message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Biography.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.text != null && Object.hasOwnProperty.call(message, "text"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.text);
		if (message.portrait != null && message.portrait.length)
			for (var i = 0; i < message.portrait.length; ++i)
				$root.Image.encode(message.portrait[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		if (message.portraitGroup != null && message.portraitGroup.length)
			for (var i = 0; i < message.portraitGroup.length; ++i)
				$root.ImageGroup.encode(message.portraitGroup[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified Biography message, length delimited. Does not implicitly {@link Biography.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Biography
	 * @static
	 * @param {IBiography} message Biography message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Biography.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Biography message from the specified reader or buffer.
	 * @function decode
	 * @memberof Biography
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Biography} Biography
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Biography.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Biography();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.text = reader.string();
					break;
				}
				case 2: {
					if (!(message.portrait && message.portrait.length)) message.portrait = [];
					message.portrait.push($root.Image.decode(reader, reader.uint32()));
					break;
				}
				case 3: {
					if (!(message.portraitGroup && message.portraitGroup.length)) message.portraitGroup = [];
					message.portraitGroup.push($root.ImageGroup.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Biography message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Biography
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Biography} Biography
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Biography.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Biography message.
	 * @function verify
	 * @memberof Biography
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Biography.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.text != null && message.hasOwnProperty("text")) if (!$util.isString(message.text)) return "text: string expected";
		if (message.portrait != null && message.hasOwnProperty("portrait")) {
			if (!Array.isArray(message.portrait)) return "portrait: array expected";
			for (var i = 0; i < message.portrait.length; ++i) {
				var error = $root.Image.verify(message.portrait[i]);
				if (error) return "portrait." + error;
			}
		}
		if (message.portraitGroup != null && message.hasOwnProperty("portraitGroup")) {
			if (!Array.isArray(message.portraitGroup)) return "portraitGroup: array expected";
			for (var i = 0; i < message.portraitGroup.length; ++i) {
				var error = $root.ImageGroup.verify(message.portraitGroup[i]);
				if (error) return "portraitGroup." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a Biography message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Biography
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Biography} Biography
	 */
	Biography.fromObject = function fromObject(object) {
		if (object instanceof $root.Biography) return object;
		var message = new $root.Biography();
		if (object.text != null) message.text = String(object.text);
		if (object.portrait) {
			if (!Array.isArray(object.portrait)) throw TypeError(".Biography.portrait: array expected");
			message.portrait = [];
			for (var i = 0; i < object.portrait.length; ++i) {
				if (typeof object.portrait[i] !== "object") throw TypeError(".Biography.portrait: object expected");
				message.portrait[i] = $root.Image.fromObject(object.portrait[i]);
			}
		}
		if (object.portraitGroup) {
			if (!Array.isArray(object.portraitGroup)) throw TypeError(".Biography.portraitGroup: array expected");
			message.portraitGroup = [];
			for (var i = 0; i < object.portraitGroup.length; ++i) {
				if (typeof object.portraitGroup[i] !== "object") throw TypeError(".Biography.portraitGroup: object expected");
				message.portraitGroup[i] = $root.ImageGroup.fromObject(object.portraitGroup[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a Biography message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Biography
	 * @static
	 * @param {Biography} message Biography
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Biography.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) {
			object.portrait = [];
			object.portraitGroup = [];
		}
		if (options.defaults) object.text = "";
		if (message.text != null && message.hasOwnProperty("text")) object.text = message.text;
		if (message.portrait && message.portrait.length) {
			object.portrait = [];
			for (var j = 0; j < message.portrait.length; ++j) object.portrait[j] = $root.Image.toObject(message.portrait[j], options);
		}
		if (message.portraitGroup && message.portraitGroup.length) {
			object.portraitGroup = [];
			for (var j = 0; j < message.portraitGroup.length; ++j)
				object.portraitGroup[j] = $root.ImageGroup.toObject(message.portraitGroup[j], options);
		}
		return object;
	};

	/**
	 * Converts this Biography to JSON.
	 * @function toJSON
	 * @memberof Biography
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Biography.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Biography
	 * @function getTypeUrl
	 * @memberof Biography
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Biography.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Biography";
	};

	return Biography;
})();

$root.Disc = (function () {
	/**
	 * Properties of a Disc.
	 * @exports IDisc
	 * @interface IDisc
	 * @property {number|null} [number] Disc number
	 * @property {string|null} [name] Disc name
	 * @property {Array.<ITrack>|null} [track] Disc track
	 */

	/**
	 * Constructs a new Disc.
	 * @exports Disc
	 * @classdesc Represents a Disc.
	 * @implements IDisc
	 * @constructor
	 * @param {IDisc=} [properties] Properties to set
	 */
	function Disc(properties) {
		this.track = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Disc number.
	 * @member {number} number
	 * @memberof Disc
	 * @instance
	 */
	Disc.prototype.number = 0;

	/**
	 * Disc name.
	 * @member {string} name
	 * @memberof Disc
	 * @instance
	 */
	Disc.prototype.name = "";

	/**
	 * Disc track.
	 * @member {Array.<ITrack>} track
	 * @memberof Disc
	 * @instance
	 */
	Disc.prototype.track = $util.emptyArray;

	/**
	 * Creates a new Disc instance using the specified properties.
	 * @function create
	 * @memberof Disc
	 * @static
	 * @param {IDisc=} [properties] Properties to set
	 * @returns {Disc} Disc instance
	 */
	Disc.create = function create(properties) {
		return new Disc(properties);
	};

	/**
	 * Encodes the specified Disc message. Does not implicitly {@link Disc.verify|verify} messages.
	 * @function encode
	 * @memberof Disc
	 * @static
	 * @param {IDisc} message Disc message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Disc.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.number != null && Object.hasOwnProperty.call(message, "number"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.number);
		if (message.name != null && Object.hasOwnProperty.call(message, "name"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
		if (message.track != null && message.track.length)
			for (var i = 0; i < message.track.length; ++i)
				$root.Track.encode(message.track[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified Disc message, length delimited. Does not implicitly {@link Disc.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Disc
	 * @static
	 * @param {IDisc} message Disc message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Disc.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Disc message from the specified reader or buffer.
	 * @function decode
	 * @memberof Disc
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Disc} Disc
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Disc.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Disc();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.number = reader.sint32();
					break;
				}
				case 2: {
					message.name = reader.string();
					break;
				}
				case 3: {
					if (!(message.track && message.track.length)) message.track = [];
					message.track.push($root.Track.decode(reader, reader.uint32()));
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Disc message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Disc
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Disc} Disc
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Disc.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Disc message.
	 * @function verify
	 * @memberof Disc
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Disc.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.number != null && message.hasOwnProperty("number"))
			if (!$util.isInteger(message.number)) return "number: integer expected";
		if (message.name != null && message.hasOwnProperty("name")) if (!$util.isString(message.name)) return "name: string expected";
		if (message.track != null && message.hasOwnProperty("track")) {
			if (!Array.isArray(message.track)) return "track: array expected";
			for (var i = 0; i < message.track.length; ++i) {
				var error = $root.Track.verify(message.track[i]);
				if (error) return "track." + error;
			}
		}
		return null;
	};

	/**
	 * Creates a Disc message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Disc
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Disc} Disc
	 */
	Disc.fromObject = function fromObject(object) {
		if (object instanceof $root.Disc) return object;
		var message = new $root.Disc();
		if (object.number != null) message.number = object.number | 0;
		if (object.name != null) message.name = String(object.name);
		if (object.track) {
			if (!Array.isArray(object.track)) throw TypeError(".Disc.track: array expected");
			message.track = [];
			for (var i = 0; i < object.track.length; ++i) {
				if (typeof object.track[i] !== "object") throw TypeError(".Disc.track: object expected");
				message.track[i] = $root.Track.fromObject(object.track[i]);
			}
		}
		return message;
	};

	/**
	 * Creates a plain object from a Disc message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Disc
	 * @static
	 * @param {Disc} message Disc
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Disc.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.track = [];
		if (options.defaults) {
			object.number = 0;
			object.name = "";
		}
		if (message.number != null && message.hasOwnProperty("number")) object.number = message.number;
		if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
		if (message.track && message.track.length) {
			object.track = [];
			for (var j = 0; j < message.track.length; ++j) object.track[j] = $root.Track.toObject(message.track[j], options);
		}
		return object;
	};

	/**
	 * Converts this Disc to JSON.
	 * @function toJSON
	 * @memberof Disc
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Disc.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Disc
	 * @function getTypeUrl
	 * @memberof Disc
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Disc.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Disc";
	};

	return Disc;
})();

$root.Copyright = (function () {
	/**
	 * Properties of a Copyright.
	 * @exports ICopyright
	 * @interface ICopyright
	 * @property {Copyright.Type|null} [type] Copyright type
	 * @property {string|null} [text] Copyright text
	 */

	/**
	 * Constructs a new Copyright.
	 * @exports Copyright
	 * @classdesc Represents a Copyright.
	 * @implements ICopyright
	 * @constructor
	 * @param {ICopyright=} [properties] Properties to set
	 */
	function Copyright(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Copyright type.
	 * @member {Copyright.Type} type
	 * @memberof Copyright
	 * @instance
	 */
	Copyright.prototype.type = 0;

	/**
	 * Copyright text.
	 * @member {string} text
	 * @memberof Copyright
	 * @instance
	 */
	Copyright.prototype.text = "";

	/**
	 * Creates a new Copyright instance using the specified properties.
	 * @function create
	 * @memberof Copyright
	 * @static
	 * @param {ICopyright=} [properties] Properties to set
	 * @returns {Copyright} Copyright instance
	 */
	Copyright.create = function create(properties) {
		return new Copyright(properties);
	};

	/**
	 * Encodes the specified Copyright message. Does not implicitly {@link Copyright.verify|verify} messages.
	 * @function encode
	 * @memberof Copyright
	 * @static
	 * @param {ICopyright} message Copyright message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Copyright.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.type != null && Object.hasOwnProperty.call(message, "type"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
		if (message.text != null && Object.hasOwnProperty.call(message, "text"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.text);
		return writer;
	};

	/**
	 * Encodes the specified Copyright message, length delimited. Does not implicitly {@link Copyright.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Copyright
	 * @static
	 * @param {ICopyright} message Copyright message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Copyright.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Copyright message from the specified reader or buffer.
	 * @function decode
	 * @memberof Copyright
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Copyright} Copyright
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Copyright.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Copyright();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.type = reader.int32();
					break;
				}
				case 2: {
					message.text = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Copyright message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Copyright
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Copyright} Copyright
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Copyright.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Copyright message.
	 * @function verify
	 * @memberof Copyright
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Copyright.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.type != null && message.hasOwnProperty("type"))
			switch (message.type) {
				default:
					return "type: enum value expected";
				case 0:
				case 1:
					break;
			}
		if (message.text != null && message.hasOwnProperty("text")) if (!$util.isString(message.text)) return "text: string expected";
		return null;
	};

	/**
	 * Creates a Copyright message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Copyright
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Copyright} Copyright
	 */
	Copyright.fromObject = function fromObject(object) {
		if (object instanceof $root.Copyright) return object;
		var message = new $root.Copyright();
		switch (object.type) {
			default:
				if (typeof object.type === "number") {
					message.type = object.type;
					break;
				}
				break;
			case "P":
			case 0:
				message.type = 0;
				break;
			case "C":
			case 1:
				message.type = 1;
				break;
		}
		if (object.text != null) message.text = String(object.text);
		return message;
	};

	/**
	 * Creates a plain object from a Copyright message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Copyright
	 * @static
	 * @param {Copyright} message Copyright
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Copyright.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.type = options.enums === String ? "P" : 0;
			object.text = "";
		}
		if (message.type != null && message.hasOwnProperty("type"))
			object.type =
				options.enums === String
					? $root.Copyright.Type[message.type] === undefined
						? message.type
						: $root.Copyright.Type[message.type]
					: message.type;
		if (message.text != null && message.hasOwnProperty("text")) object.text = message.text;
		return object;
	};

	/**
	 * Converts this Copyright to JSON.
	 * @function toJSON
	 * @memberof Copyright
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Copyright.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Copyright
	 * @function getTypeUrl
	 * @memberof Copyright
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Copyright.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Copyright";
	};

	/**
	 * Type enum.
	 * @name Copyright.Type
	 * @enum {number}
	 * @property {number} P=0 P value
	 * @property {number} C=1 C value
	 */
	Copyright.Type = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "P")] = 0;
		values[(valuesById[1] = "C")] = 1;
		return values;
	})();

	return Copyright;
})();

$root.Restriction = (function () {
	/**
	 * Properties of a Restriction.
	 * @exports IRestriction
	 * @interface IRestriction
	 * @property {Array.<Restriction.Catalogue>|null} [catalogue] Restriction catalogue
	 * @property {Restriction.Type|null} [type] Restriction type
	 * @property {Array.<string>|null} [catalogueStr] Restriction catalogueStr
	 * @property {string|null} [countriesAllowed] Restriction countriesAllowed
	 * @property {string|null} [countriesForbidden] Restriction countriesForbidden
	 */

	/**
	 * Constructs a new Restriction.
	 * @exports Restriction
	 * @classdesc Represents a Restriction.
	 * @implements IRestriction
	 * @constructor
	 * @param {IRestriction=} [properties] Properties to set
	 */
	function Restriction(properties) {
		this.catalogue = [];
		this.catalogueStr = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Restriction catalogue.
	 * @member {Array.<Restriction.Catalogue>} catalogue
	 * @memberof Restriction
	 * @instance
	 */
	Restriction.prototype.catalogue = $util.emptyArray;

	/**
	 * Restriction type.
	 * @member {Restriction.Type} type
	 * @memberof Restriction
	 * @instance
	 */
	Restriction.prototype.type = 0;

	/**
	 * Restriction catalogueStr.
	 * @member {Array.<string>} catalogueStr
	 * @memberof Restriction
	 * @instance
	 */
	Restriction.prototype.catalogueStr = $util.emptyArray;

	/**
	 * Restriction countriesAllowed.
	 * @member {string|null|undefined} countriesAllowed
	 * @memberof Restriction
	 * @instance
	 */
	Restriction.prototype.countriesAllowed = null;

	/**
	 * Restriction countriesForbidden.
	 * @member {string|null|undefined} countriesForbidden
	 * @memberof Restriction
	 * @instance
	 */
	Restriction.prototype.countriesForbidden = null;

	// OneOf field names bound to virtual getters and setters
	var $oneOfFields;

	/**
	 * Restriction countryRestriction.
	 * @member {"countriesAllowed"|"countriesForbidden"|undefined} countryRestriction
	 * @memberof Restriction
	 * @instance
	 */
	Object.defineProperty(Restriction.prototype, "countryRestriction", {
		get: $util.oneOfGetter(($oneOfFields = ["countriesAllowed", "countriesForbidden"])),
		set: $util.oneOfSetter($oneOfFields),
	});

	/**
	 * Creates a new Restriction instance using the specified properties.
	 * @function create
	 * @memberof Restriction
	 * @static
	 * @param {IRestriction=} [properties] Properties to set
	 * @returns {Restriction} Restriction instance
	 */
	Restriction.create = function create(properties) {
		return new Restriction(properties);
	};

	/**
	 * Encodes the specified Restriction message. Does not implicitly {@link Restriction.verify|verify} messages.
	 * @function encode
	 * @memberof Restriction
	 * @static
	 * @param {IRestriction} message Restriction message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Restriction.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.catalogue != null && message.catalogue.length)
			for (var i = 0; i < message.catalogue.length; ++i) writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.catalogue[i]);
		if (message.countriesAllowed != null && Object.hasOwnProperty.call(message, "countriesAllowed"))
			writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.countriesAllowed);
		if (message.countriesForbidden != null && Object.hasOwnProperty.call(message, "countriesForbidden"))
			writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.countriesForbidden);
		if (message.type != null && Object.hasOwnProperty.call(message, "type"))
			writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.type);
		if (message.catalogueStr != null && message.catalogueStr.length)
			for (var i = 0; i < message.catalogueStr.length; ++i) writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.catalogueStr[i]);
		return writer;
	};

	/**
	 * Encodes the specified Restriction message, length delimited. Does not implicitly {@link Restriction.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Restriction
	 * @static
	 * @param {IRestriction} message Restriction message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Restriction.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a Restriction message from the specified reader or buffer.
	 * @function decode
	 * @memberof Restriction
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Restriction} Restriction
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Restriction.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Restriction();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (!(message.catalogue && message.catalogue.length)) message.catalogue = [];
					if ((tag & 7) === 2) {
						var end2 = reader.uint32() + reader.pos;
						while (reader.pos < end2) message.catalogue.push(reader.int32());
					} else message.catalogue.push(reader.int32());
					break;
				}
				case 4: {
					message.type = reader.int32();
					break;
				}
				case 5: {
					if (!(message.catalogueStr && message.catalogueStr.length)) message.catalogueStr = [];
					message.catalogueStr.push(reader.string());
					break;
				}
				case 2: {
					message.countriesAllowed = reader.string();
					break;
				}
				case 3: {
					message.countriesForbidden = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a Restriction message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Restriction
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Restriction} Restriction
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Restriction.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a Restriction message.
	 * @function verify
	 * @memberof Restriction
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Restriction.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		var properties = {};
		if (message.catalogue != null && message.hasOwnProperty("catalogue")) {
			if (!Array.isArray(message.catalogue)) return "catalogue: array expected";
			for (var i = 0; i < message.catalogue.length; ++i)
				switch (message.catalogue[i]) {
					default:
						return "catalogue: enum value[] expected";
					case 0:
					case 1:
					case 2:
					case 3:
					case 4:
						break;
				}
		}
		if (message.type != null && message.hasOwnProperty("type"))
			switch (message.type) {
				default:
					return "type: enum value expected";
				case 0:
					break;
			}
		if (message.catalogueStr != null && message.hasOwnProperty("catalogueStr")) {
			if (!Array.isArray(message.catalogueStr)) return "catalogueStr: array expected";
			for (var i = 0; i < message.catalogueStr.length; ++i)
				if (!$util.isString(message.catalogueStr[i])) return "catalogueStr: string[] expected";
		}
		if (message.countriesAllowed != null && message.hasOwnProperty("countriesAllowed")) {
			properties.countryRestriction = 1;
			if (!$util.isString(message.countriesAllowed)) return "countriesAllowed: string expected";
		}
		if (message.countriesForbidden != null && message.hasOwnProperty("countriesForbidden")) {
			if (properties.countryRestriction === 1) return "countryRestriction: multiple values";
			properties.countryRestriction = 1;
			if (!$util.isString(message.countriesForbidden)) return "countriesForbidden: string expected";
		}
		return null;
	};

	/**
	 * Creates a Restriction message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Restriction
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Restriction} Restriction
	 */
	Restriction.fromObject = function fromObject(object) {
		if (object instanceof $root.Restriction) return object;
		var message = new $root.Restriction();
		if (object.catalogue) {
			if (!Array.isArray(object.catalogue)) throw TypeError(".Restriction.catalogue: array expected");
			message.catalogue = [];
			for (var i = 0; i < object.catalogue.length; ++i)
				switch (object.catalogue[i]) {
					default:
						if (typeof object.catalogue[i] === "number") {
							message.catalogue[i] = object.catalogue[i];
							break;
						}
					case "AD":
					case 0:
						message.catalogue[i] = 0;
						break;
					case "SUBSCRIPTION":
					case 1:
						message.catalogue[i] = 1;
						break;
					case "CATALOGUE_ALL":
					case 2:
						message.catalogue[i] = 2;
						break;
					case "SHUFFLE":
					case 3:
						message.catalogue[i] = 3;
						break;
					case "COMMERCIAL":
					case 4:
						message.catalogue[i] = 4;
						break;
				}
		}
		switch (object.type) {
			default:
				if (typeof object.type === "number") {
					message.type = object.type;
					break;
				}
				break;
			case "STREAMING":
			case 0:
				message.type = 0;
				break;
		}
		if (object.catalogueStr) {
			if (!Array.isArray(object.catalogueStr)) throw TypeError(".Restriction.catalogueStr: array expected");
			message.catalogueStr = [];
			for (var i = 0; i < object.catalogueStr.length; ++i) message.catalogueStr[i] = String(object.catalogueStr[i]);
		}
		if (object.countriesAllowed != null) message.countriesAllowed = String(object.countriesAllowed);
		if (object.countriesForbidden != null) message.countriesForbidden = String(object.countriesForbidden);
		return message;
	};

	/**
	 * Creates a plain object from a Restriction message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Restriction
	 * @static
	 * @param {Restriction} message Restriction
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Restriction.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) {
			object.catalogue = [];
			object.catalogueStr = [];
		}
		if (options.defaults) object.type = options.enums === String ? "STREAMING" : 0;
		if (message.catalogue && message.catalogue.length) {
			object.catalogue = [];
			for (var j = 0; j < message.catalogue.length; ++j)
				object.catalogue[j] =
					options.enums === String
						? $root.Restriction.Catalogue[message.catalogue[j]] === undefined
							? message.catalogue[j]
							: $root.Restriction.Catalogue[message.catalogue[j]]
						: message.catalogue[j];
		}
		if (message.countriesAllowed != null && message.hasOwnProperty("countriesAllowed")) {
			object.countriesAllowed = message.countriesAllowed;
			if (options.oneofs) object.countryRestriction = "countriesAllowed";
		}
		if (message.countriesForbidden != null && message.hasOwnProperty("countriesForbidden")) {
			object.countriesForbidden = message.countriesForbidden;
			if (options.oneofs) object.countryRestriction = "countriesForbidden";
		}
		if (message.type != null && message.hasOwnProperty("type"))
			object.type =
				options.enums === String
					? $root.Restriction.Type[message.type] === undefined
						? message.type
						: $root.Restriction.Type[message.type]
					: message.type;
		if (message.catalogueStr && message.catalogueStr.length) {
			object.catalogueStr = [];
			for (var j = 0; j < message.catalogueStr.length; ++j) object.catalogueStr[j] = message.catalogueStr[j];
		}
		return object;
	};

	/**
	 * Converts this Restriction to JSON.
	 * @function toJSON
	 * @memberof Restriction
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Restriction.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Restriction
	 * @function getTypeUrl
	 * @memberof Restriction
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Restriction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Restriction";
	};

	/**
	 * Catalogue enum.
	 * @name Restriction.Catalogue
	 * @enum {number}
	 * @property {number} AD=0 AD value
	 * @property {number} SUBSCRIPTION=1 SUBSCRIPTION value
	 * @property {number} CATALOGUE_ALL=2 CATALOGUE_ALL value
	 * @property {number} SHUFFLE=3 SHUFFLE value
	 * @property {number} COMMERCIAL=4 COMMERCIAL value
	 */
	Restriction.Catalogue = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "AD")] = 0;
		values[(valuesById[1] = "SUBSCRIPTION")] = 1;
		values[(valuesById[2] = "CATALOGUE_ALL")] = 2;
		values[(valuesById[3] = "SHUFFLE")] = 3;
		values[(valuesById[4] = "COMMERCIAL")] = 4;
		return values;
	})();

	/**
	 * Type enum.
	 * @name Restriction.Type
	 * @enum {number}
	 * @property {number} STREAMING=0 STREAMING value
	 */
	Restriction.Type = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "STREAMING")] = 0;
		return values;
	})();

	return Restriction;
})();

$root.Availability = (function () {
	/**
	 * Properties of an Availability.
	 * @exports IAvailability
	 * @interface IAvailability
	 * @property {Array.<string>|null} [catalogueStr] Availability catalogueStr
	 * @property {IDate|null} [start] Availability start
	 */

	/**
	 * Constructs a new Availability.
	 * @exports Availability
	 * @classdesc Represents an Availability.
	 * @implements IAvailability
	 * @constructor
	 * @param {IAvailability=} [properties] Properties to set
	 */
	function Availability(properties) {
		this.catalogueStr = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Availability catalogueStr.
	 * @member {Array.<string>} catalogueStr
	 * @memberof Availability
	 * @instance
	 */
	Availability.prototype.catalogueStr = $util.emptyArray;

	/**
	 * Availability start.
	 * @member {IDate|null|undefined} start
	 * @memberof Availability
	 * @instance
	 */
	Availability.prototype.start = null;

	/**
	 * Creates a new Availability instance using the specified properties.
	 * @function create
	 * @memberof Availability
	 * @static
	 * @param {IAvailability=} [properties] Properties to set
	 * @returns {Availability} Availability instance
	 */
	Availability.create = function create(properties) {
		return new Availability(properties);
	};

	/**
	 * Encodes the specified Availability message. Does not implicitly {@link Availability.verify|verify} messages.
	 * @function encode
	 * @memberof Availability
	 * @static
	 * @param {IAvailability} message Availability message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Availability.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.catalogueStr != null && message.catalogueStr.length)
			for (var i = 0; i < message.catalogueStr.length; ++i) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.catalogueStr[i]);
		if (message.start != null && Object.hasOwnProperty.call(message, "start"))
			$root.Date.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified Availability message, length delimited. Does not implicitly {@link Availability.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof Availability
	 * @static
	 * @param {IAvailability} message Availability message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	Availability.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an Availability message from the specified reader or buffer.
	 * @function decode
	 * @memberof Availability
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {Availability} Availability
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Availability.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.Availability();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (!(message.catalogueStr && message.catalogueStr.length)) message.catalogueStr = [];
					message.catalogueStr.push(reader.string());
					break;
				}
				case 2: {
					message.start = $root.Date.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an Availability message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof Availability
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Availability} Availability
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	Availability.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an Availability message.
	 * @function verify
	 * @memberof Availability
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Availability.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.catalogueStr != null && message.hasOwnProperty("catalogueStr")) {
			if (!Array.isArray(message.catalogueStr)) return "catalogueStr: array expected";
			for (var i = 0; i < message.catalogueStr.length; ++i)
				if (!$util.isString(message.catalogueStr[i])) return "catalogueStr: string[] expected";
		}
		if (message.start != null && message.hasOwnProperty("start")) {
			var error = $root.Date.verify(message.start);
			if (error) return "start." + error;
		}
		return null;
	};

	/**
	 * Creates an Availability message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof Availability
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {Availability} Availability
	 */
	Availability.fromObject = function fromObject(object) {
		if (object instanceof $root.Availability) return object;
		var message = new $root.Availability();
		if (object.catalogueStr) {
			if (!Array.isArray(object.catalogueStr)) throw TypeError(".Availability.catalogueStr: array expected");
			message.catalogueStr = [];
			for (var i = 0; i < object.catalogueStr.length; ++i) message.catalogueStr[i] = String(object.catalogueStr[i]);
		}
		if (object.start != null) {
			if (typeof object.start !== "object") throw TypeError(".Availability.start: object expected");
			message.start = $root.Date.fromObject(object.start);
		}
		return message;
	};

	/**
	 * Creates a plain object from an Availability message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof Availability
	 * @static
	 * @param {Availability} message Availability
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Availability.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.catalogueStr = [];
		if (options.defaults) object.start = null;
		if (message.catalogueStr && message.catalogueStr.length) {
			object.catalogueStr = [];
			for (var j = 0; j < message.catalogueStr.length; ++j) object.catalogueStr[j] = message.catalogueStr[j];
		}
		if (message.start != null && message.hasOwnProperty("start")) object.start = $root.Date.toObject(message.start, options);
		return object;
	};

	/**
	 * Converts this Availability to JSON.
	 * @function toJSON
	 * @memberof Availability
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	Availability.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for Availability
	 * @function getTypeUrl
	 * @memberof Availability
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	Availability.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/Availability";
	};

	return Availability;
})();

$root.SalePeriod = (function () {
	/**
	 * Properties of a SalePeriod.
	 * @exports ISalePeriod
	 * @interface ISalePeriod
	 * @property {Array.<IRestriction>|null} [restriction] SalePeriod restriction
	 * @property {IDate|null} [start] SalePeriod start
	 * @property {IDate|null} [end] SalePeriod end
	 */

	/**
	 * Constructs a new SalePeriod.
	 * @exports SalePeriod
	 * @classdesc Represents a SalePeriod.
	 * @implements ISalePeriod
	 * @constructor
	 * @param {ISalePeriod=} [properties] Properties to set
	 */
	function SalePeriod(properties) {
		this.restriction = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * SalePeriod restriction.
	 * @member {Array.<IRestriction>} restriction
	 * @memberof SalePeriod
	 * @instance
	 */
	SalePeriod.prototype.restriction = $util.emptyArray;

	/**
	 * SalePeriod start.
	 * @member {IDate|null|undefined} start
	 * @memberof SalePeriod
	 * @instance
	 */
	SalePeriod.prototype.start = null;

	/**
	 * SalePeriod end.
	 * @member {IDate|null|undefined} end
	 * @memberof SalePeriod
	 * @instance
	 */
	SalePeriod.prototype.end = null;

	/**
	 * Creates a new SalePeriod instance using the specified properties.
	 * @function create
	 * @memberof SalePeriod
	 * @static
	 * @param {ISalePeriod=} [properties] Properties to set
	 * @returns {SalePeriod} SalePeriod instance
	 */
	SalePeriod.create = function create(properties) {
		return new SalePeriod(properties);
	};

	/**
	 * Encodes the specified SalePeriod message. Does not implicitly {@link SalePeriod.verify|verify} messages.
	 * @function encode
	 * @memberof SalePeriod
	 * @static
	 * @param {ISalePeriod} message SalePeriod message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	SalePeriod.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.restriction != null && message.restriction.length)
			for (var i = 0; i < message.restriction.length; ++i)
				$root.Restriction.encode(message.restriction[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
		if (message.start != null && Object.hasOwnProperty.call(message, "start"))
			$root.Date.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
		if (message.end != null && Object.hasOwnProperty.call(message, "end"))
			$root.Date.encode(message.end, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
		return writer;
	};

	/**
	 * Encodes the specified SalePeriod message, length delimited. Does not implicitly {@link SalePeriod.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof SalePeriod
	 * @static
	 * @param {ISalePeriod} message SalePeriod message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	SalePeriod.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a SalePeriod message from the specified reader or buffer.
	 * @function decode
	 * @memberof SalePeriod
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {SalePeriod} SalePeriod
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	SalePeriod.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.SalePeriod();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (!(message.restriction && message.restriction.length)) message.restriction = [];
					message.restriction.push($root.Restriction.decode(reader, reader.uint32()));
					break;
				}
				case 2: {
					message.start = $root.Date.decode(reader, reader.uint32());
					break;
				}
				case 3: {
					message.end = $root.Date.decode(reader, reader.uint32());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a SalePeriod message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof SalePeriod
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {SalePeriod} SalePeriod
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	SalePeriod.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a SalePeriod message.
	 * @function verify
	 * @memberof SalePeriod
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	SalePeriod.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.restriction != null && message.hasOwnProperty("restriction")) {
			if (!Array.isArray(message.restriction)) return "restriction: array expected";
			for (var i = 0; i < message.restriction.length; ++i) {
				var error = $root.Restriction.verify(message.restriction[i]);
				if (error) return "restriction." + error;
			}
		}
		if (message.start != null && message.hasOwnProperty("start")) {
			var error = $root.Date.verify(message.start);
			if (error) return "start." + error;
		}
		if (message.end != null && message.hasOwnProperty("end")) {
			var error = $root.Date.verify(message.end);
			if (error) return "end." + error;
		}
		return null;
	};

	/**
	 * Creates a SalePeriod message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof SalePeriod
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {SalePeriod} SalePeriod
	 */
	SalePeriod.fromObject = function fromObject(object) {
		if (object instanceof $root.SalePeriod) return object;
		var message = new $root.SalePeriod();
		if (object.restriction) {
			if (!Array.isArray(object.restriction)) throw TypeError(".SalePeriod.restriction: array expected");
			message.restriction = [];
			for (var i = 0; i < object.restriction.length; ++i) {
				if (typeof object.restriction[i] !== "object") throw TypeError(".SalePeriod.restriction: object expected");
				message.restriction[i] = $root.Restriction.fromObject(object.restriction[i]);
			}
		}
		if (object.start != null) {
			if (typeof object.start !== "object") throw TypeError(".SalePeriod.start: object expected");
			message.start = $root.Date.fromObject(object.start);
		}
		if (object.end != null) {
			if (typeof object.end !== "object") throw TypeError(".SalePeriod.end: object expected");
			message.end = $root.Date.fromObject(object.end);
		}
		return message;
	};

	/**
	 * Creates a plain object from a SalePeriod message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof SalePeriod
	 * @static
	 * @param {SalePeriod} message SalePeriod
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	SalePeriod.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.restriction = [];
		if (options.defaults) {
			object.start = null;
			object.end = null;
		}
		if (message.restriction && message.restriction.length) {
			object.restriction = [];
			for (var j = 0; j < message.restriction.length; ++j)
				object.restriction[j] = $root.Restriction.toObject(message.restriction[j], options);
		}
		if (message.start != null && message.hasOwnProperty("start")) object.start = $root.Date.toObject(message.start, options);
		if (message.end != null && message.hasOwnProperty("end")) object.end = $root.Date.toObject(message.end, options);
		return object;
	};

	/**
	 * Converts this SalePeriod to JSON.
	 * @function toJSON
	 * @memberof SalePeriod
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	SalePeriod.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for SalePeriod
	 * @function getTypeUrl
	 * @memberof SalePeriod
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	SalePeriod.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/SalePeriod";
	};

	return SalePeriod;
})();

$root.ExternalId = (function () {
	/**
	 * Properties of an ExternalId.
	 * @exports IExternalId
	 * @interface IExternalId
	 * @property {string|null} [type] ExternalId type
	 * @property {string|null} [id] ExternalId id
	 */

	/**
	 * Constructs a new ExternalId.
	 * @exports ExternalId
	 * @classdesc Represents an ExternalId.
	 * @implements IExternalId
	 * @constructor
	 * @param {IExternalId=} [properties] Properties to set
	 */
	function ExternalId(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ExternalId type.
	 * @member {string} type
	 * @memberof ExternalId
	 * @instance
	 */
	ExternalId.prototype.type = "";

	/**
	 * ExternalId id.
	 * @member {string} id
	 * @memberof ExternalId
	 * @instance
	 */
	ExternalId.prototype.id = "";

	/**
	 * Creates a new ExternalId instance using the specified properties.
	 * @function create
	 * @memberof ExternalId
	 * @static
	 * @param {IExternalId=} [properties] Properties to set
	 * @returns {ExternalId} ExternalId instance
	 */
	ExternalId.create = function create(properties) {
		return new ExternalId(properties);
	};

	/**
	 * Encodes the specified ExternalId message. Does not implicitly {@link ExternalId.verify|verify} messages.
	 * @function encode
	 * @memberof ExternalId
	 * @static
	 * @param {IExternalId} message ExternalId message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ExternalId.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.type != null && Object.hasOwnProperty.call(message, "type"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type);
		if (message.id != null && Object.hasOwnProperty.call(message, "id")) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.id);
		return writer;
	};

	/**
	 * Encodes the specified ExternalId message, length delimited. Does not implicitly {@link ExternalId.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ExternalId
	 * @static
	 * @param {IExternalId} message ExternalId message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ExternalId.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an ExternalId message from the specified reader or buffer.
	 * @function decode
	 * @memberof ExternalId
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ExternalId} ExternalId
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ExternalId.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ExternalId();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.type = reader.string();
					break;
				}
				case 2: {
					message.id = reader.string();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an ExternalId message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ExternalId
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ExternalId} ExternalId
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ExternalId.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an ExternalId message.
	 * @function verify
	 * @memberof ExternalId
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ExternalId.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.type != null && message.hasOwnProperty("type")) if (!$util.isString(message.type)) return "type: string expected";
		if (message.id != null && message.hasOwnProperty("id")) if (!$util.isString(message.id)) return "id: string expected";
		return null;
	};

	/**
	 * Creates an ExternalId message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ExternalId
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ExternalId} ExternalId
	 */
	ExternalId.fromObject = function fromObject(object) {
		if (object instanceof $root.ExternalId) return object;
		var message = new $root.ExternalId();
		if (object.type != null) message.type = String(object.type);
		if (object.id != null) message.id = String(object.id);
		return message;
	};

	/**
	 * Creates a plain object from an ExternalId message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ExternalId
	 * @static
	 * @param {ExternalId} message ExternalId
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ExternalId.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			object.type = "";
			object.id = "";
		}
		if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
		if (message.id != null && message.hasOwnProperty("id")) object.id = message.id;
		return object;
	};

	/**
	 * Converts this ExternalId to JSON.
	 * @function toJSON
	 * @memberof ExternalId
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ExternalId.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ExternalId
	 * @function getTypeUrl
	 * @memberof ExternalId
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ExternalId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ExternalId";
	};

	return ExternalId;
})();

$root.AudioFile = (function () {
	/**
	 * Properties of an AudioFile.
	 * @exports IAudioFile
	 * @interface IAudioFile
	 * @property {Uint8Array|null} [fileId] AudioFile fileId
	 * @property {AudioFile.Format|null} [format] AudioFile format
	 */

	/**
	 * Constructs a new AudioFile.
	 * @exports AudioFile
	 * @classdesc Represents an AudioFile.
	 * @implements IAudioFile
	 * @constructor
	 * @param {IAudioFile=} [properties] Properties to set
	 */
	function AudioFile(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * AudioFile fileId.
	 * @member {Uint8Array} fileId
	 * @memberof AudioFile
	 * @instance
	 */
	AudioFile.prototype.fileId = $util.newBuffer([]);

	/**
	 * AudioFile format.
	 * @member {AudioFile.Format} format
	 * @memberof AudioFile
	 * @instance
	 */
	AudioFile.prototype.format = 0;

	/**
	 * Creates a new AudioFile instance using the specified properties.
	 * @function create
	 * @memberof AudioFile
	 * @static
	 * @param {IAudioFile=} [properties] Properties to set
	 * @returns {AudioFile} AudioFile instance
	 */
	AudioFile.create = function create(properties) {
		return new AudioFile(properties);
	};

	/**
	 * Encodes the specified AudioFile message. Does not implicitly {@link AudioFile.verify|verify} messages.
	 * @function encode
	 * @memberof AudioFile
	 * @static
	 * @param {IAudioFile} message AudioFile message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AudioFile.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.fileId);
		if (message.format != null && Object.hasOwnProperty.call(message, "format"))
			writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.format);
		return writer;
	};

	/**
	 * Encodes the specified AudioFile message, length delimited. Does not implicitly {@link AudioFile.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof AudioFile
	 * @static
	 * @param {IAudioFile} message AudioFile message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	AudioFile.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes an AudioFile message from the specified reader or buffer.
	 * @function decode
	 * @memberof AudioFile
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {AudioFile} AudioFile
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AudioFile.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.AudioFile();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.fileId = reader.bytes();
					break;
				}
				case 2: {
					message.format = reader.int32();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes an AudioFile message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof AudioFile
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {AudioFile} AudioFile
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	AudioFile.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies an AudioFile message.
	 * @function verify
	 * @memberof AudioFile
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	AudioFile.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.fileId != null && message.hasOwnProperty("fileId"))
			if (!((message.fileId && typeof message.fileId.length === "number") || $util.isString(message.fileId)))
				return "fileId: buffer expected";
		if (message.format != null && message.hasOwnProperty("format"))
			switch (message.format) {
				default:
					return "format: enum value expected";
				case 0:
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 16:
					break;
			}
		return null;
	};

	/**
	 * Creates an AudioFile message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof AudioFile
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {AudioFile} AudioFile
	 */
	AudioFile.fromObject = function fromObject(object) {
		if (object instanceof $root.AudioFile) return object;
		var message = new $root.AudioFile();
		if (object.fileId != null)
			if (typeof object.fileId === "string")
				$util.base64.decode(object.fileId, (message.fileId = $util.newBuffer($util.base64.length(object.fileId))), 0);
			else if (object.fileId.length >= 0) message.fileId = object.fileId;
		switch (object.format) {
			default:
				if (typeof object.format === "number") {
					message.format = object.format;
					break;
				}
				break;
			case "OGG_VORBIS_96":
			case 0:
				message.format = 0;
				break;
			case "OGG_VORBIS_160":
			case 1:
				message.format = 1;
				break;
			case "OGG_VORBIS_320":
			case 2:
				message.format = 2;
				break;
			case "MP3_256":
			case 3:
				message.format = 3;
				break;
			case "MP3_320":
			case 4:
				message.format = 4;
				break;
			case "MP3_160":
			case 5:
				message.format = 5;
				break;
			case "MP3_96":
			case 6:
				message.format = 6;
				break;
			case "MP3_160_ENC":
			case 7:
				message.format = 7;
				break;
			case "AAC_24":
			case 8:
				message.format = 8;
				break;
			case "AAC_48":
			case 9:
				message.format = 9;
				break;
			case "FLAC_FLAC":
			case 16:
				message.format = 16;
				break;
		}
		return message;
	};

	/**
	 * Creates a plain object from an AudioFile message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof AudioFile
	 * @static
	 * @param {AudioFile} message AudioFile
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	AudioFile.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults) {
			if (options.bytes === String) object.fileId = "";
			else {
				object.fileId = [];
				if (options.bytes !== Array) object.fileId = $util.newBuffer(object.fileId);
			}
			object.format = options.enums === String ? "OGG_VORBIS_96" : 0;
		}
		if (message.fileId != null && message.hasOwnProperty("fileId"))
			object.fileId =
				options.bytes === String
					? $util.base64.encode(message.fileId, 0, message.fileId.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.fileId)
					: message.fileId;
		if (message.format != null && message.hasOwnProperty("format"))
			object.format =
				options.enums === String
					? $root.AudioFile.Format[message.format] === undefined
						? message.format
						: $root.AudioFile.Format[message.format]
					: message.format;
		return object;
	};

	/**
	 * Converts this AudioFile to JSON.
	 * @function toJSON
	 * @memberof AudioFile
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	AudioFile.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for AudioFile
	 * @function getTypeUrl
	 * @memberof AudioFile
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	AudioFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/AudioFile";
	};

	/**
	 * Format enum.
	 * @name AudioFile.Format
	 * @enum {number}
	 * @property {number} OGG_VORBIS_96=0 OGG_VORBIS_96 value
	 * @property {number} OGG_VORBIS_160=1 OGG_VORBIS_160 value
	 * @property {number} OGG_VORBIS_320=2 OGG_VORBIS_320 value
	 * @property {number} MP3_256=3 MP3_256 value
	 * @property {number} MP3_320=4 MP3_320 value
	 * @property {number} MP3_160=5 MP3_160 value
	 * @property {number} MP3_96=6 MP3_96 value
	 * @property {number} MP3_160_ENC=7 MP3_160_ENC value
	 * @property {number} AAC_24=8 AAC_24 value
	 * @property {number} AAC_48=9 AAC_48 value
	 * @property {number} FLAC_FLAC=16 FLAC_FLAC value
	 */
	AudioFile.Format = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "OGG_VORBIS_96")] = 0;
		values[(valuesById[1] = "OGG_VORBIS_160")] = 1;
		values[(valuesById[2] = "OGG_VORBIS_320")] = 2;
		values[(valuesById[3] = "MP3_256")] = 3;
		values[(valuesById[4] = "MP3_320")] = 4;
		values[(valuesById[5] = "MP3_160")] = 5;
		values[(valuesById[6] = "MP3_96")] = 6;
		values[(valuesById[7] = "MP3_160_ENC")] = 7;
		values[(valuesById[8] = "AAC_24")] = 8;
		values[(valuesById[9] = "AAC_48")] = 9;
		values[(valuesById[16] = "FLAC_FLAC")] = 16;
		return values;
	})();

	return AudioFile;
})();

$root.VideoFile = (function () {
	/**
	 * Properties of a VideoFile.
	 * @exports IVideoFile
	 * @interface IVideoFile
	 * @property {Uint8Array|null} [fileId] VideoFile fileId
	 */

	/**
	 * Constructs a new VideoFile.
	 * @exports VideoFile
	 * @classdesc Represents a VideoFile.
	 * @implements IVideoFile
	 * @constructor
	 * @param {IVideoFile=} [properties] Properties to set
	 */
	function VideoFile(properties) {
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * VideoFile fileId.
	 * @member {Uint8Array} fileId
	 * @memberof VideoFile
	 * @instance
	 */
	VideoFile.prototype.fileId = $util.newBuffer([]);

	/**
	 * Creates a new VideoFile instance using the specified properties.
	 * @function create
	 * @memberof VideoFile
	 * @static
	 * @param {IVideoFile=} [properties] Properties to set
	 * @returns {VideoFile} VideoFile instance
	 */
	VideoFile.create = function create(properties) {
		return new VideoFile(properties);
	};

	/**
	 * Encodes the specified VideoFile message. Does not implicitly {@link VideoFile.verify|verify} messages.
	 * @function encode
	 * @memberof VideoFile
	 * @static
	 * @param {IVideoFile} message VideoFile message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	VideoFile.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.fileId);
		return writer;
	};

	/**
	 * Encodes the specified VideoFile message, length delimited. Does not implicitly {@link VideoFile.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof VideoFile
	 * @static
	 * @param {IVideoFile} message VideoFile message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	VideoFile.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a VideoFile message from the specified reader or buffer.
	 * @function decode
	 * @memberof VideoFile
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {VideoFile} VideoFile
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	VideoFile.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.VideoFile();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.fileId = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a VideoFile message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof VideoFile
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {VideoFile} VideoFile
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	VideoFile.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a VideoFile message.
	 * @function verify
	 * @memberof VideoFile
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	VideoFile.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.fileId != null && message.hasOwnProperty("fileId"))
			if (!((message.fileId && typeof message.fileId.length === "number") || $util.isString(message.fileId)))
				return "fileId: buffer expected";
		return null;
	};

	/**
	 * Creates a VideoFile message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof VideoFile
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {VideoFile} VideoFile
	 */
	VideoFile.fromObject = function fromObject(object) {
		if (object instanceof $root.VideoFile) return object;
		var message = new $root.VideoFile();
		if (object.fileId != null)
			if (typeof object.fileId === "string")
				$util.base64.decode(object.fileId, (message.fileId = $util.newBuffer($util.base64.length(object.fileId))), 0);
			else if (object.fileId.length >= 0) message.fileId = object.fileId;
		return message;
	};

	/**
	 * Creates a plain object from a VideoFile message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof VideoFile
	 * @static
	 * @param {VideoFile} message VideoFile
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	VideoFile.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.defaults)
			if (options.bytes === String) object.fileId = "";
			else {
				object.fileId = [];
				if (options.bytes !== Array) object.fileId = $util.newBuffer(object.fileId);
			}
		if (message.fileId != null && message.hasOwnProperty("fileId"))
			object.fileId =
				options.bytes === String
					? $util.base64.encode(message.fileId, 0, message.fileId.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.fileId)
					: message.fileId;
		return object;
	};

	/**
	 * Converts this VideoFile to JSON.
	 * @function toJSON
	 * @memberof VideoFile
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	VideoFile.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for VideoFile
	 * @function getTypeUrl
	 * @memberof VideoFile
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	VideoFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/VideoFile";
	};

	return VideoFile;
})();

$root.ContentRating = (function () {
	/**
	 * Properties of a ContentRating.
	 * @exports IContentRating
	 * @interface IContentRating
	 * @property {string|null} [country] ContentRating country
	 * @property {Array.<string>|null} [tag] ContentRating tag
	 */

	/**
	 * Constructs a new ContentRating.
	 * @exports ContentRating
	 * @classdesc Represents a ContentRating.
	 * @implements IContentRating
	 * @constructor
	 * @param {IContentRating=} [properties] Properties to set
	 */
	function ContentRating(properties) {
		this.tag = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * ContentRating country.
	 * @member {string} country
	 * @memberof ContentRating
	 * @instance
	 */
	ContentRating.prototype.country = "";

	/**
	 * ContentRating tag.
	 * @member {Array.<string>} tag
	 * @memberof ContentRating
	 * @instance
	 */
	ContentRating.prototype.tag = $util.emptyArray;

	/**
	 * Creates a new ContentRating instance using the specified properties.
	 * @function create
	 * @memberof ContentRating
	 * @static
	 * @param {IContentRating=} [properties] Properties to set
	 * @returns {ContentRating} ContentRating instance
	 */
	ContentRating.create = function create(properties) {
		return new ContentRating(properties);
	};

	/**
	 * Encodes the specified ContentRating message. Does not implicitly {@link ContentRating.verify|verify} messages.
	 * @function encode
	 * @memberof ContentRating
	 * @static
	 * @param {IContentRating} message ContentRating message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ContentRating.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.country != null && Object.hasOwnProperty.call(message, "country"))
			writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.country);
		if (message.tag != null && message.tag.length)
			for (var i = 0; i < message.tag.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.tag[i]);
		return writer;
	};

	/**
	 * Encodes the specified ContentRating message, length delimited. Does not implicitly {@link ContentRating.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof ContentRating
	 * @static
	 * @param {IContentRating} message ContentRating message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	ContentRating.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a ContentRating message from the specified reader or buffer.
	 * @function decode
	 * @memberof ContentRating
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {ContentRating} ContentRating
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ContentRating.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.ContentRating();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.country = reader.string();
					break;
				}
				case 2: {
					if (!(message.tag && message.tag.length)) message.tag = [];
					message.tag.push(reader.string());
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a ContentRating message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof ContentRating
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {ContentRating} ContentRating
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	ContentRating.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a ContentRating message.
	 * @function verify
	 * @memberof ContentRating
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	ContentRating.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.country != null && message.hasOwnProperty("country"))
			if (!$util.isString(message.country)) return "country: string expected";
		if (message.tag != null && message.hasOwnProperty("tag")) {
			if (!Array.isArray(message.tag)) return "tag: array expected";
			for (var i = 0; i < message.tag.length; ++i) if (!$util.isString(message.tag[i])) return "tag: string[] expected";
		}
		return null;
	};

	/**
	 * Creates a ContentRating message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof ContentRating
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {ContentRating} ContentRating
	 */
	ContentRating.fromObject = function fromObject(object) {
		if (object instanceof $root.ContentRating) return object;
		var message = new $root.ContentRating();
		if (object.country != null) message.country = String(object.country);
		if (object.tag) {
			if (!Array.isArray(object.tag)) throw TypeError(".ContentRating.tag: array expected");
			message.tag = [];
			for (var i = 0; i < object.tag.length; ++i) message.tag[i] = String(object.tag[i]);
		}
		return message;
	};

	/**
	 * Creates a plain object from a ContentRating message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof ContentRating
	 * @static
	 * @param {ContentRating} message ContentRating
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	ContentRating.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.tag = [];
		if (options.defaults) object.country = "";
		if (message.country != null && message.hasOwnProperty("country")) object.country = message.country;
		if (message.tag && message.tag.length) {
			object.tag = [];
			for (var j = 0; j < message.tag.length; ++j) object.tag[j] = message.tag[j];
		}
		return object;
	};

	/**
	 * Converts this ContentRating to JSON.
	 * @function toJSON
	 * @memberof ContentRating
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	ContentRating.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for ContentRating
	 * @function getTypeUrl
	 * @memberof ContentRating
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	ContentRating.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/ContentRating";
	};

	return ContentRating;
})();

$root.StorageResolveResponse = (function () {
	/**
	 * Properties of a StorageResolveResponse.
	 * @exports IStorageResolveResponse
	 * @interface IStorageResolveResponse
	 * @property {StorageResolveResponse.Result|null} [result] StorageResolveResponse result
	 * @property {Array.<string>|null} [cdnurl] StorageResolveResponse cdnurl
	 * @property {Uint8Array|null} [fileid] StorageResolveResponse fileid
	 */

	/**
	 * Constructs a new StorageResolveResponse.
	 * @exports StorageResolveResponse
	 * @classdesc Represents a StorageResolveResponse.
	 * @implements IStorageResolveResponse
	 * @constructor
	 * @param {IStorageResolveResponse=} [properties] Properties to set
	 */
	function StorageResolveResponse(properties) {
		this.cdnurl = [];
		if (properties)
			for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
				if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
	}

	/**
	 * StorageResolveResponse result.
	 * @member {StorageResolveResponse.Result} result
	 * @memberof StorageResolveResponse
	 * @instance
	 */
	StorageResolveResponse.prototype.result = 0;

	/**
	 * StorageResolveResponse cdnurl.
	 * @member {Array.<string>} cdnurl
	 * @memberof StorageResolveResponse
	 * @instance
	 */
	StorageResolveResponse.prototype.cdnurl = $util.emptyArray;

	/**
	 * StorageResolveResponse fileid.
	 * @member {Uint8Array} fileid
	 * @memberof StorageResolveResponse
	 * @instance
	 */
	StorageResolveResponse.prototype.fileid = $util.newBuffer([]);

	/**
	 * Creates a new StorageResolveResponse instance using the specified properties.
	 * @function create
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {IStorageResolveResponse=} [properties] Properties to set
	 * @returns {StorageResolveResponse} StorageResolveResponse instance
	 */
	StorageResolveResponse.create = function create(properties) {
		return new StorageResolveResponse(properties);
	};

	/**
	 * Encodes the specified StorageResolveResponse message. Does not implicitly {@link StorageResolveResponse.verify|verify} messages.
	 * @function encode
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {IStorageResolveResponse} message StorageResolveResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	StorageResolveResponse.encode = function encode(message, writer) {
		if (!writer) writer = $Writer.create();
		if (message.result != null && Object.hasOwnProperty.call(message, "result"))
			writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result);
		if (message.cdnurl != null && message.cdnurl.length)
			for (var i = 0; i < message.cdnurl.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.cdnurl[i]);
		if (message.fileid != null && Object.hasOwnProperty.call(message, "fileid"))
			writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.fileid);
		return writer;
	};

	/**
	 * Encodes the specified StorageResolveResponse message, length delimited. Does not implicitly {@link StorageResolveResponse.verify|verify} messages.
	 * @function encodeDelimited
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {IStorageResolveResponse} message StorageResolveResponse message or plain object to encode
	 * @param {$protobuf.Writer} [writer] Writer to encode to
	 * @returns {$protobuf.Writer} Writer
	 */
	StorageResolveResponse.encodeDelimited = function encodeDelimited(message, writer) {
		return this.encode(message, writer).ldelim();
	};

	/**
	 * Decodes a StorageResolveResponse message from the specified reader or buffer.
	 * @function decode
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Message length if known beforehand
	 * @returns {StorageResolveResponse} StorageResolveResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	StorageResolveResponse.decode = function decode(reader, length) {
		if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
		var end = length === undefined ? reader.len : reader.pos + length,
			message = new $root.StorageResolveResponse();
		while (reader.pos < end) {
			var tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					message.result = reader.int32();
					break;
				}
				case 2: {
					if (!(message.cdnurl && message.cdnurl.length)) message.cdnurl = [];
					message.cdnurl.push(reader.string());
					break;
				}
				case 4: {
					message.fileid = reader.bytes();
					break;
				}
				default:
					reader.skipType(tag & 7);
					break;
			}
		}
		return message;
	};

	/**
	 * Decodes a StorageResolveResponse message from the specified reader or buffer, length delimited.
	 * @function decodeDelimited
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {StorageResolveResponse} StorageResolveResponse
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {$protobuf.util.ProtocolError} If required fields are missing
	 */
	StorageResolveResponse.decodeDelimited = function decodeDelimited(reader) {
		if (!(reader instanceof $Reader)) reader = new $Reader(reader);
		return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies a StorageResolveResponse message.
	 * @function verify
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	StorageResolveResponse.verify = function verify(message) {
		if (typeof message !== "object" || message === null) return "object expected";
		if (message.result != null && message.hasOwnProperty("result"))
			switch (message.result) {
				default:
					return "result: enum value expected";
				case 0:
				case 1:
				case 3:
					break;
			}
		if (message.cdnurl != null && message.hasOwnProperty("cdnurl")) {
			if (!Array.isArray(message.cdnurl)) return "cdnurl: array expected";
			for (var i = 0; i < message.cdnurl.length; ++i) if (!$util.isString(message.cdnurl[i])) return "cdnurl: string[] expected";
		}
		if (message.fileid != null && message.hasOwnProperty("fileid"))
			if (!((message.fileid && typeof message.fileid.length === "number") || $util.isString(message.fileid)))
				return "fileid: buffer expected";
		return null;
	};

	/**
	 * Creates a StorageResolveResponse message from a plain object. Also converts values to their respective internal types.
	 * @function fromObject
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {Object.<string,*>} object Plain object
	 * @returns {StorageResolveResponse} StorageResolveResponse
	 */
	StorageResolveResponse.fromObject = function fromObject(object) {
		if (object instanceof $root.StorageResolveResponse) return object;
		var message = new $root.StorageResolveResponse();
		switch (object.result) {
			default:
				if (typeof object.result === "number") {
					message.result = object.result;
					break;
				}
				break;
			case "CDN":
			case 0:
				message.result = 0;
				break;
			case "STORAGE":
			case 1:
				message.result = 1;
				break;
			case "RESTRICTED":
			case 3:
				message.result = 3;
				break;
		}
		if (object.cdnurl) {
			if (!Array.isArray(object.cdnurl)) throw TypeError(".StorageResolveResponse.cdnurl: array expected");
			message.cdnurl = [];
			for (var i = 0; i < object.cdnurl.length; ++i) message.cdnurl[i] = String(object.cdnurl[i]);
		}
		if (object.fileid != null)
			if (typeof object.fileid === "string")
				$util.base64.decode(object.fileid, (message.fileid = $util.newBuffer($util.base64.length(object.fileid))), 0);
			else if (object.fileid.length >= 0) message.fileid = object.fileid;
		return message;
	};

	/**
	 * Creates a plain object from a StorageResolveResponse message. Also converts values to other types if specified.
	 * @function toObject
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {StorageResolveResponse} message StorageResolveResponse
	 * @param {$protobuf.IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	StorageResolveResponse.toObject = function toObject(message, options) {
		if (!options) options = {};
		var object = {};
		if (options.arrays || options.defaults) object.cdnurl = [];
		if (options.defaults) {
			object.result = options.enums === String ? "CDN" : 0;
			if (options.bytes === String) object.fileid = "";
			else {
				object.fileid = [];
				if (options.bytes !== Array) object.fileid = $util.newBuffer(object.fileid);
			}
		}
		if (message.result != null && message.hasOwnProperty("result"))
			object.result =
				options.enums === String
					? $root.StorageResolveResponse.Result[message.result] === undefined
						? message.result
						: $root.StorageResolveResponse.Result[message.result]
					: message.result;
		if (message.cdnurl && message.cdnurl.length) {
			object.cdnurl = [];
			for (var j = 0; j < message.cdnurl.length; ++j) object.cdnurl[j] = message.cdnurl[j];
		}
		if (message.fileid != null && message.hasOwnProperty("fileid"))
			object.fileid =
				options.bytes === String
					? $util.base64.encode(message.fileid, 0, message.fileid.length)
					: options.bytes === Array
					? Array.prototype.slice.call(message.fileid)
					: message.fileid;
		return object;
	};

	/**
	 * Converts this StorageResolveResponse to JSON.
	 * @function toJSON
	 * @memberof StorageResolveResponse
	 * @instance
	 * @returns {Object.<string,*>} JSON object
	 */
	StorageResolveResponse.prototype.toJSON = function toJSON() {
		return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	};

	/**
	 * Gets the default type url for StorageResolveResponse
	 * @function getTypeUrl
	 * @memberof StorageResolveResponse
	 * @static
	 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	 * @returns {string} The default type url
	 */
	StorageResolveResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
		if (typeUrlPrefix === undefined) {
			typeUrlPrefix = "type.googleapis.com";
		}
		return typeUrlPrefix + "/StorageResolveResponse";
	};

	/**
	 * Result enum.
	 * @name StorageResolveResponse.Result
	 * @enum {number}
	 * @property {number} CDN=0 CDN value
	 * @property {number} STORAGE=1 STORAGE value
	 * @property {number} RESTRICTED=3 RESTRICTED value
	 */
	StorageResolveResponse.Result = (function () {
		var valuesById = {},
			values = Object.create(valuesById);
		values[(valuesById[0] = "CDN")] = 0;
		values[(valuesById[1] = "STORAGE")] = 1;
		values[(valuesById[3] = "RESTRICTED")] = 3;
		return values;
	})();

	return StorageResolveResponse;
})();

module.exports = $root;
